/* Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 and
* only version 2 as published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*/

/*
 * this file was generated by NunniFSMGen
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/ioctl.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/err.h>
#include <linux/list.h>
#include <linux/errno.h>
#include <linux/mutex.h>
#include <linux/slab.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/spi/spi.h>
#include <linux/io.h>
#include <linux/dma-mapping.h>
#include <linux/version.h>
#include <linux/proc_fs.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <asm/segment.h>
#include <linux/uaccess.h>
#include <linux/buffer_head.h>
#include  <linux/of_gpio.h>
#include <linux/regulator/consumer.h>
#include <linux/clk.h>
#include <linux/pinctrl/consumer.h>

#include "include/altek_state.h"
#include "include/error/altek_state_err.h"
#include "include/miniisp.h"
#include "include/miniisp_ctrl.h"
#include "include/ispctrl_if_master.h"
#include "include/miniisp_customer_define.h"

#define MINI_ISP_LOG_TAG	"[[miniisp]altek_state]"

int state_open(void *o)
{
	/* add your code hereafter... */
	int ret = 0;
	struct misp_global_variable *dev_global_variable;

	misp_info("%s - enter", __func__);
	dev_global_variable = get_mini_isp_global_variable();
	ret = request_threaded_irq(gpio_to_irq(dev_global_variable->irq_gpio),
		NULL, mini_isp_irq,
		IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "mini_isp", o);

	if (ret != 0) {
		misp_err("%s err, %x", __func__, ret);
		return ret;
	}

	misp_info("%s request_threaded_irq succeed, irq_gpio: %d, irg_num %d"
				, __func__, dev_global_variable->irq_gpio,
				gpio_to_irq(dev_global_variable->irq_gpio));

	if (RESET_GPIO != NULL) {
		gpio_direction_output(dev_global_variable->reset_gpio, 0);
		gpio_set_value(dev_global_variable->reset_gpio, 0);
		msleep(20);
	}
	if (VCC1_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc1_gpio, 0);
	if (VCC2_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc2_gpio, 0);
	if (VCC3_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc3_gpio, 0);

	msleep(20);

	if (VCC1_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc1_gpio, 1);
	if (VCC2_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc2_gpio, 1);
	if (VCC3_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc3_gpio, 1);

	msleep(20);
	if (ISP_CLK != NULL)
		if (clk_prepare_enable(dev_global_variable->isp_clk) < 0)
			misp_err("mini_isp_poweron clk_prepare_enable failed");

	if (RESET_GPIO != NULL) {
		gpio_direction_output(dev_global_variable->reset_gpio, 1);
		gpio_set_value(dev_global_variable->reset_gpio, 1);
		msleep(20);
	}

	if (RESET_GPIO != NULL)
		misp_err("%s -reset_gpio gpio_get_value = %d", __func__,
			gpio_get_value(dev_global_variable->reset_gpio));
	if (VCC1_GPIO != NULL)
		misp_err("%s -vcc1_gpio gpio_get_value = %d", __func__,
			gpio_get_value(dev_global_variable->vcc1_gpio));
	if (VCC2_GPIO != NULL)
		misp_err("%s -vcc2_gpio gpio_get_value = %d", __func__,
			gpio_get_value(dev_global_variable->vcc2_gpio));
	if (VCC3_GPIO != NULL)
		misp_err("%s -vcc3_gpio gpio_get_value = %d", __func__,
			gpio_get_value(dev_global_variable->vcc3_gpio));

	misp_err("%s - leave", __func__);
	return ret;
}


int error_sequence(void *o)
{
	/* add your code hereafter... */
	return ERR_MINIISP_STATE_ERROR_SEQUENCE;
}


int redundant_sequence(void *o)
{
	/* add your code hereafter... */
	return ERR_MINIISP_STATE_REDUNDANT_SEQUENCE;
}


int state_enter_hwpt(void *o)
{
	int ret = 0;
	/* add your code hereafter... */
	/*check bypass mode be set or not*/
	/*if yes, leave bypass mode*/
	mini_isp_check_and_leave_bypass_mode();
	/*Pure bypass by sensor*/
	ret = mini_isp_pure_bypass((*(u16 *)o));
	return ret;
}


int state_coldboot(void *o)
{
	int err = 0;
	/* add your code hereafter... */
	/*check bypass mode be set or not*/
	/*if yes, leave bypass mode*/
	mini_isp_check_and_leave_bypass_mode();
	/*normal case load FW*/
	err = mini_isp_drv_load_fw();
	return err;
}


int state_close(void *o)
{
	struct misp_global_variable *dev_global_variable;

	dev_global_variable = get_mini_isp_global_variable();
	/* add your code hereafter... */
	if (RESET_GPIO != NULL)
		gpio_set_value(dev_global_variable->reset_gpio, 0);
	msleep(20);
	if (VCC1_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc1_gpio, 0);
	if (VCC2_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc2_gpio, 0);
	if (VCC3_GPIO != NULL)
		gpio_set_value(dev_global_variable->vcc3_gpio, 0);
	if (ISP_CLK != NULL)
		clk_disable_unprepare(dev_global_variable->isp_clk);
	msleep(20);
	dev_global_variable->be_set_to_bypass = 0;
	dev_global_variable->before_booting = 1;
	if (IRQ_GPIO != NULL)
		free_irq(gpio_to_irq(dev_global_variable->irq_gpio), o);

	return 0;
}


int state_leave_hwpt(void *o)
{
	/* add your code hereafter... */
	/*check bypass mode be set or not*/
	/*if yes, leave bypass mode*/
	mini_isp_check_and_leave_bypass_mode();
	return 0;
}


int state_scenario_chg(void *o)
{
	int err = 0;

	/* Set Sensor Mode*/
	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);

	return err;
}


int state_strm_on_off(void *o)
{
	int err = 0;

	/* Preview stream on/off*/
	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);
	return err;
}


int state_enter_cp(void *o)
{
	int err = 0;
	struct misp_global_variable *dev_global_variable;

	dev_global_variable = get_mini_isp_global_variable();

	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_E))
		mini_isp_e_to_a();
	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);
	if (err != 0)
		return err;

	dev_global_variable->spi_low_speed_mode = 1;

	if (dev_global_variable->intf_status & INTF_SPI_READY)
		mini_isp_a_to_e();
	/*enter code here*/
	mini_isp_cp_mode_suspend_flow();
	return err;
}


int state_set_qp(void *o)
{
	int err = 0;

	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);
	return err;
}


int state_stop(void *o)
{
	int err = 0;

	/* Set Sensor Mode*/
	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);

	return err;
}


int state_leave_cp(void *o)
{
	int err = 0;
	int original_altek_spi_mode;
	struct misp_global_variable *dev_global_variable;

	dev_global_variable = get_mini_isp_global_variable();
	original_altek_spi_mode = dev_global_variable->altek_spi_mode;

	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
		(original_altek_spi_mode == ALTEK_SPI_MODE_A))
		mini_isp_a_to_e();
	mini_isp_cp_mode_resume_flow();

	dev_global_variable->spi_low_speed_mode = 0;

	if (dev_global_variable->intf_status & INTF_SPI_READY)
		mini_isp_e_to_a();

	/* Set Sensor Mode*/
	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
			((struct transferdata *)o)->data);
	return err;
}


int state_leave_cp_standy(void *o)
{
	int err = 0;
	struct misp_global_variable *dev_global_variable;

	dev_global_variable = get_mini_isp_global_variable();

	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_A))
		mini_isp_a_to_e();
	mini_isp_cp_mode_resume_flow();

	dev_global_variable->spi_low_speed_mode = 0;

	if (dev_global_variable->intf_status & INTF_SPI_READY)
		mini_isp_e_to_a();

	return err;
}
