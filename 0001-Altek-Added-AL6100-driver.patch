From 8b3b7ccac592534d4449b026e88066ad266ce9b3 Mon Sep 17 00:00:00 2001
From: Li <lizc0826@thundersoft.com>
Date: Tue, 13 Nov 2018 15:02:26 +0800
Subject: [PATCH] [Altek] Added AL6100 driver

Change-Id: I65fb5d08e9f4c2162513ce88c2bd8a6362eeaba8
---
 arch/arm64/boot/dts/qcom/sdm845-mtp.dtsi           |   21 +
 arch/arm64/boot/dts/qcom/sdm845.dtsi               |    2 +-
 drivers/media/platform/msm/camera/Makefile         |    1 +
 drivers/media/platform/msm/camera/al6100/Makefile  |   23 +
 .../media/platform/msm/camera/al6100/altek_state.c |  305 ++++
 .../platform/msm/camera/al6100/altek_statefsm.c    |  775 +++++++++
 .../platform/msm/camera/al6100/basic_setting_cmd.c |  109 ++
 .../platform/msm/camera/al6100/bulk_data_cmd.c     |  605 +++++++
 .../msm/camera/al6100/camera_profile_cmd.c         |  401 +++++
 .../msm/camera/al6100/include/altek_state.h        |   38 +
 .../msm/camera/al6100/include/altek_statefsm.h     |   89 ++
 .../platform/msm/camera/al6100/include/error.h     |   57 +
 .../camera/al6100/include/error/altek_state_err.h  |   18 +
 .../al6100/include/error/ispctrl_if_master_err.h   |   38 +
 .../msm/camera/al6100/include/error/miniisp_err.h  |   17 +
 .../platform/msm/camera/al6100/include/error_pj.h  |   24 +
 .../msm/camera/al6100/include/isp_camera_cmd.h     |  449 ++++++
 .../msm/camera/al6100/include/ispctrl_if_master.h  |  153 ++
 .../al6100/include/ispctrl_if_master_local.h       |  395 +++++
 .../platform/msm/camera/al6100/include/miniisp.h   |  245 +++
 .../al6100/include/miniisp_chip_base_define.h      |  670 ++++++++
 .../msm/camera/al6100/include/miniisp_ctrl.h       |  326 ++++
 .../msm/camera/al6100/include/miniisp_ctrl_intf.h  |   13 +
 .../al6100/include/miniisp_customer_define.h       |   61 +
 .../msm/camera/al6100/include/miniisp_debug_if.h   |   52 +
 .../platform/msm/camera/al6100/include/moduleid.h  |   51 +
 .../msm/camera/al6100/include/moduleid_pj.h        |   19 +
 .../platform/msm/camera/al6100/include/mtype.h     |   19 +
 .../platform/msm/camera/al6100/ispctrl_if_master.c |  855 ++++++++++
 .../msm/camera/al6100/miniisp_chip_base_define.c   |  615 +++++++
 .../platform/msm/camera/al6100/miniisp_ctrl.c      | 1367 ++++++++++++++++
 .../platform/msm/camera/al6100/miniisp_ctrl_intf.c |  421 +++++
 .../msm/camera/al6100/miniisp_customer_define.c    |  317 ++++
 .../platform/msm/camera/al6100/miniisp_debug_if.c  |  643 ++++++++
 .../platform/msm/camera/al6100/miniisp_intf_i2c.c  |  429 +++++
 .../platform/msm/camera/al6100/miniisp_intf_spi.c  |  607 +++++++
 .../media/platform/msm/camera/al6100/miniisp_isp.c |  432 +++++
 .../media/platform/msm/camera/al6100/miniisp_top.c | 1681 ++++++++++++++++++++
 .../platform/msm/camera/al6100/miniisp_utility.c   |   95 ++
 .../platform/msm/camera/al6100/operation_cmd.c     |  195 +++
 .../platform/msm/camera/al6100/sys_manage_cmd.c    |  226 +++
 include/uapi/Kbuild                                |    1 +
 include/uapi/miniISP/Kbuild                        |    2 +
 include/uapi/miniISP/miniISP_ioctl.h               |   93 ++
 include/uapi/miniISP/miniISP_ioctl32.h             |   28 +
 45 files changed, 12982 insertions(+), 1 deletion(-)
 create mode 100644 drivers/media/platform/msm/camera/al6100/Makefile
 create mode 100644 drivers/media/platform/msm/camera/al6100/altek_state.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/altek_statefsm.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/basic_setting_cmd.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/bulk_data_cmd.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/camera_profile_cmd.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/altek_state.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/altek_statefsm.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/error.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/error/altek_state_err.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/error/ispctrl_if_master_err.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/error/miniisp_err.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/error_pj.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/isp_camera_cmd.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master_local.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp_chip_base_define.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl_intf.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp_customer_define.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/miniisp_debug_if.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/moduleid.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/moduleid_pj.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/include/mtype.h
 create mode 100644 drivers/media/platform/msm/camera/al6100/ispctrl_if_master.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_chip_base_define.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_ctrl.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_ctrl_intf.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_customer_define.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_debug_if.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_intf_i2c.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_intf_spi.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_isp.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_top.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/miniisp_utility.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/operation_cmd.c
 create mode 100644 drivers/media/platform/msm/camera/al6100/sys_manage_cmd.c
 create mode 100644 include/uapi/miniISP/Kbuild
 create mode 100644 include/uapi/miniISP/miniISP_ioctl.h
 create mode 100644 include/uapi/miniISP/miniISP_ioctl32.h

diff --git a/arch/arm64/boot/dts/qcom/sdm845-mtp.dtsi b/arch/arm64/boot/dts/qcom/sdm845-mtp.dtsi
index ec38204..9231ee5 100755
--- a/arch/arm64/boot/dts/qcom/sdm845-mtp.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdm845-mtp.dtsi
@@ -396,6 +396,27 @@
     };
 };
 
+///ALTEK_TAG_HwMiniISP>>>
+&qupv3_se5_spi {
+	status = "ok";
+	mini_isp@0 {
+		compatible = "altek_isp";
+		reg = <0>;
+		spi-max-frequency = <50000000>;
+		spi-cpol;
+		spi-cpha;
+		/*spi-cs-high;*/
+		//vcc-supply = <&pm8953_s3>;
+		reset-gpios = <&tlmm 12 0x00>;
+		irq-gpios = <&tlmm 24 0x00>;
+		vcc1-gpios = <&tlmm 69 0x00>;
+		//vcc2-gpios = <&tlmm 63 0x00>;
+		//status = "disabled";
+		status = "ok";
+	};
+};
+///ALTEK_TAG_HwMiniISP<<<
+
 &qupv3_se3_i2c {
 	status = "disabled";
 	nq@28 {
diff --git a/arch/arm64/boot/dts/qcom/sdm845.dtsi b/arch/arm64/boot/dts/qcom/sdm845.dtsi
index a1d9dbf..d529e6f 100644
--- a/arch/arm64/boot/dts/qcom/sdm845.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdm845.dtsi
@@ -44,7 +44,7 @@
 
 	aliases {
 		serial0 = &qupv3_se9_2uart;
-		spi0 = &qupv3_se8_spi;
+		spi0 = &qupv3_se5_spi;
 		i2c0 = &qupv3_se10_i2c;
 		i2c1 = &qupv3_se3_i2c;
 		hsuart0 = &qupv3_se6_4uart;
diff --git a/drivers/media/platform/msm/camera/Makefile b/drivers/media/platform/msm/camera/Makefile
index 9e0aee9..ff93b30 100644
--- a/drivers/media/platform/msm/camera/Makefile
+++ b/drivers/media/platform/msm/camera/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_SPECTRA_CAMERA) += cam_icp/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_jpeg/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_fd/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_lrme/
+obj-$(CONFIG_SPECTRA_CAMERA) += al6100/
diff --git a/drivers/media/platform/msm/camera/al6100/Makefile b/drivers/media/platform/msm/camera/al6100/Makefile
new file mode 100644
index 0000000..2d3abd4
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/Makefile
@@ -0,0 +1,23 @@
+#ccflags-y += -Idrivers/media/platform/msm/camera_v2
+#ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
+#ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
+#ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
+obj-y += basic_setting_cmd.o
+obj-y += bulk_data_cmd.o
+obj-y += camera_profile_cmd.o
+#obj-y += miniisp_intf_cci.o
+obj-y += miniisp_intf_i2c.o
+obj-y += miniisp_intf_spi.o
+obj-y += miniisp_isp.o
+obj-y += ispctrl_if_master.o
+obj-y += miniisp_customer_define.o
+obj-y += miniisp_top.o
+obj-y += miniisp_ctrl.o
+obj-y += operation_cmd.o
+obj-y += sys_manage_cmd.o
+obj-y += altek_state.o
+obj-y += altek_statefsm.o
+obj-y += miniisp_utility.o
+obj-y += miniisp_debug_if.o
+obj-y += miniisp_chip_base_define.o
+obj-y += miniisp_ctrl_intf.o
\ No newline at end of file
diff --git a/drivers/media/platform/msm/camera/al6100/altek_state.c b/drivers/media/platform/msm/camera/al6100/altek_state.c
new file mode 100644
index 0000000..6211d0b
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/altek_state.c
@@ -0,0 +1,305 @@
+/*
+ * this file was generated by NunniFSMGen
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/spi/spi.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm/segment.h>
+#include <linux/uaccess.h>
+#include <linux/buffer_head.h>
+#include  <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
+
+#include "include/altek_state.h"
+#include "include/error/altek_state_err.h"
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/ispctrl_if_master.h"
+#include "include/miniisp_customer_define.h"
+
+#define MINI_ISP_LOG_TAG	"[[miniisp]altek_state]"
+
+int state_open(void *o)
+{
+	/* add your code hereafter... */
+	int ret = 0;
+	struct misp_global_variable *dev_global_variable;
+	misp_info("%s - enter", __func__);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	ret = request_threaded_irq(gpio_to_irq(dev_global_variable->irq_gpio),
+		NULL, mini_isp_irq,
+		IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "mini_isp", o);
+
+	if (ret != 0) {
+		misp_err("%s err, %x", __func__, ret);
+		return ret;
+	}
+
+	misp_info("%s request_threaded_irq succeed, irq_gpio: %d, irg_num %d"
+				, __func__, dev_global_variable->irq_gpio,
+				gpio_to_irq(dev_global_variable->irq_gpio));
+
+	if (RESET_GPIO != NULL) {
+		gpio_direction_output(dev_global_variable->reset_gpio, 0);
+		gpio_set_value(dev_global_variable->reset_gpio, 0);
+		msleep(20);
+	}
+	if (VCC1_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc1_gpio, 0);
+	if (VCC2_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc2_gpio, 0);
+	if (VCC3_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc3_gpio, 0);
+
+	msleep(20);
+
+	if (VCC1_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc1_gpio, 1);
+	if (VCC2_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc2_gpio, 1);
+	if (VCC3_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc3_gpio, 1);
+
+	msleep(20);
+	if (ISP_CLK != NULL)
+		if (clk_prepare_enable(dev_global_variable->isp_clk) < 0)
+			misp_err("mini_isp_poweron clk_prepare_enable failed");
+
+	if (RESET_GPIO != NULL) {
+		gpio_direction_output(dev_global_variable->reset_gpio, 1);
+		gpio_set_value(dev_global_variable->reset_gpio, 1);
+		msleep(20);
+	}
+
+	if (RESET_GPIO != NULL)
+		misp_err("%s -reset_gpio gpio_get_value = %d", __func__,
+			gpio_get_value(dev_global_variable->reset_gpio));
+	if (VCC1_GPIO != NULL)
+		misp_err("%s -vcc1_gpio gpio_get_value = %d", __func__,
+			gpio_get_value(dev_global_variable->vcc1_gpio));
+	if (VCC2_GPIO != NULL)
+		misp_err("%s -vcc2_gpio gpio_get_value = %d", __func__,
+			gpio_get_value(dev_global_variable->vcc2_gpio));
+	if (VCC3_GPIO != NULL)
+		misp_err("%s -vcc3_gpio gpio_get_value = %d", __func__,
+			gpio_get_value(dev_global_variable->vcc3_gpio));
+
+	misp_err("%s - leave", __func__);
+	return ret;
+}
+
+
+int error_sequence(void *o)
+{
+	/* add your code hereafter... */
+	return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+}
+
+
+int redundant_sequence(void *o)
+{
+	/* add your code hereafter... */
+	return ERR_MINIISP_STATE_REDUNDANT_SEQUENCE;
+}
+
+
+int state_enter_hwpt(void *o)
+{
+	int ret = 0;
+	/* add your code hereafter... */
+	/*check bypass mode be set or not*/
+	/*if yes, leave bypass mode*/
+	mini_isp_check_and_leave_bypass_mode();
+	/*Pure bypass by sensor*/
+	ret = mini_isp_pure_bypass((*(u16 *)o));
+	return ret;
+}
+
+
+int state_coldboot(void *o)
+{
+	int err = 0;
+	/* add your code hereafter... */
+	/*check bypass mode be set or not*/
+	/*if yes, leave bypass mode*/
+	mini_isp_check_and_leave_bypass_mode();
+	/*normal case load FW*/
+	err = mini_isp_drv_load_fw();
+	return err;
+}
+
+
+int state_close(void *o)
+{
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	/* add your code hereafter... */
+	if (RESET_GPIO != NULL)
+		gpio_set_value(dev_global_variable->reset_gpio, 0);
+	msleep(20);
+	if (VCC1_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc1_gpio, 0);
+	if (VCC2_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc2_gpio, 0);
+	if (VCC3_GPIO != NULL)
+		gpio_set_value(dev_global_variable->vcc3_gpio, 0);
+	if (ISP_CLK != NULL)
+		clk_disable_unprepare(dev_global_variable->isp_clk);
+	msleep(20);
+	dev_global_variable->be_set_to_bypass = 0;
+	dev_global_variable->before_booting = 1;
+	if (IRQ_GPIO != NULL) {
+		free_irq(gpio_to_irq(dev_global_variable->irq_gpio), o);
+	}
+	return 0;
+}
+
+
+int state_leave_hwpt(void *o)
+{
+	/* add your code hereafter... */
+	/*check bypass mode be set or not*/
+	/*if yes, leave bypass mode*/
+	mini_isp_check_and_leave_bypass_mode();
+	return 0;
+}
+
+
+int state_scenario_chg(void *o)
+{
+	int err = 0;
+
+	/* Set Sensor Mode*/
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+
+	return err;
+}
+
+
+int state_strm_on_off(void *o)
+{
+	int err = 0;
+
+	/* Preview stream on/off*/
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+	return err;
+}
+
+
+int state_enter_cp(void *o)
+{
+	int err = 0;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_E))
+		mini_isp_e_to_a();
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+	if (err != 0)
+		return err;
+
+	dev_global_variable->spi_low_speed_mode = 1;
+
+	if (dev_global_variable->intf_status & INTF_SPI_READY)
+		mini_isp_a_to_e();
+	/*enter code here*/
+	mini_isp_cp_mode_suspend_flow();
+	return err;
+}
+
+
+int state_set_qp(void *o)
+{
+	int err = 0;
+
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+	return err;
+}
+
+
+int state_stop(void *o)
+{
+	int err = 0;
+
+	/* Set Sensor Mode*/
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+
+	return err;
+}
+
+
+int state_leave_cp(void *o)
+{
+	int err = 0;
+	int original_altek_spi_mode;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	original_altek_spi_mode = dev_global_variable->altek_spi_mode;
+
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+		(original_altek_spi_mode == ALTEK_SPI_MODE_A))
+		mini_isp_a_to_e();
+	mini_isp_cp_mode_resume_flow();
+
+	dev_global_variable->spi_low_speed_mode = 0;
+
+	if (dev_global_variable->intf_status & INTF_SPI_READY)
+		mini_isp_e_to_a();
+
+	/* Set Sensor Mode*/
+	err = ispctrl_if_mast_execute_cmd(((struct transferdata *)o)->opcode,
+			((struct transferdata *)o)->data);
+	return err;
+}
+
+
+int state_leave_cp_standy(void *o)
+{
+	int err = 0;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_A))
+		mini_isp_a_to_e();
+	mini_isp_cp_mode_resume_flow();
+
+	dev_global_variable->spi_low_speed_mode = 0;
+
+	if (dev_global_variable->intf_status & INTF_SPI_READY)
+		mini_isp_e_to_a();
+
+	return err;
+}
diff --git a/drivers/media/platform/msm/camera/al6100/altek_statefsm.c b/drivers/media/platform/msm/camera/al6100/altek_statefsm.c
new file mode 100644
index 0000000..9e26a33
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/altek_statefsm.c
@@ -0,0 +1,775 @@
+/*
+ * this file was generated by NunniFSMGen - do not edit!
+ */
+
+
+#include "include/altek_statefsm.h"
+#include "include/altek_state.h"
+#include "include/miniisp_ctrl.h"
+#include <linux/slab.h>
+
+#define maxfsms 1
+
+
+static int initialized;
+static struct altek_state altek_stateclosestate;
+static struct altek_state altek_stateopenstate;
+static struct altek_state altek_statehw_pass_thrustate;
+static struct altek_state altek_statestandbystate;
+static struct altek_state altek_stateoperationalstate;
+static struct altek_state altek_statecode_persistencestate;
+
+static struct altek_statefsm  *FSM[maxfsms];
+static int fsm_size;
+
+
+static int altek_stateclosestateispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_open(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateopenstate);
+	return ret;
+}
+
+
+static int altek_stateclosestateispdrv_enter_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateclosestate);
+	return ret;
+}
+
+
+#define altek_stateclosestateispdrv_leave_hwpt \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_coldboot \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_scenario_chg \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_strm_on_off \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_set_qp \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_stop \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_enter_cp \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_leave_cp \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_leave_cp_standy \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+#define altek_stateclosestateispdrv_close \
+			altek_stateclosestateispdrv_enter_hwpt
+
+
+static int altek_stateopenstateispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = redundant_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateopenstate);
+	return ret;
+}
+
+
+static int altek_stateopenstateispdrv_enter_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_enter_hwpt(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statehw_pass_thrustate);
+	return ret;
+}
+
+
+static int altek_stateopenstateispdrv_leave_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateopenstate);
+	return ret;
+}
+
+
+static int altek_stateopenstateispdrv_coldboot(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_coldboot(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statestandbystate);
+	return ret;
+}
+
+
+#define altek_stateopenstateispdrv_scenario_chg \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_strm_on_off \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_set_qp \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_stop \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_enter_cp \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_leave_cp \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+#define altek_stateopenstateispdrv_leave_cp_standy \
+			altek_stateopenstateispdrv_leave_hwpt
+
+
+static int altek_stateopenstateispdrv_close(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_close(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateclosestate);
+	return ret;
+}
+
+
+static int altek_statehw_pass_thrustateispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statehw_pass_thrustate);
+	return ret;
+}
+
+
+#define altek_statehw_pass_thrustateispdrv_enter_hwpt \
+			altek_stateopenstateispdrv_enter_hwpt
+
+
+static int altek_statehw_pass_thrustateispdrv_leave_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_leave_hwpt(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateopenstate);
+	return ret;
+}
+
+
+#define altek_statehw_pass_thrustateispdrv_coldboot \
+			altek_stateopenstateispdrv_coldboot
+
+
+static int altek_statehw_pass_thrustateispdrv_strm_on_off(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statestandbystate);
+	return ret;
+}
+
+
+#define altek_statehw_pass_thrustateispdrv_set_qp \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_scenario_chg \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_stop \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_enter_cp \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_leave_cp \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_leave_cp_standy \
+			altek_statehw_pass_thrustateispdrv_open
+
+
+#define altek_statehw_pass_thrustateispdrv_close \
+			altek_stateopenstateispdrv_close
+
+
+#define altek_statestandbystateispdrv_open \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_enter_hwpt \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_leave_hwpt \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_coldboot \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+static int altek_statestandbystateispdrv_scenario_chg(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_scenario_chg(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateoperationalstate);
+	return ret;
+}
+
+
+static int altek_statestandbystateispdrv_strm_on_off(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_strm_on_off(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateoperationalstate);
+	return ret;
+}
+
+
+#define altek_statestandbystateispdrv_set_qp \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_stop \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+static int altek_statestandbystateispdrv_enter_cp(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_enter_cp(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statecode_persistencestate);
+	return ret;
+}
+
+
+#define altek_statestandbystateispdrv_leave_cp \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_leave_cp_standy \
+			altek_statehw_pass_thrustateispdrv_strm_on_off
+
+
+#define altek_statestandbystateispdrv_close \
+			altek_stateopenstateispdrv_close
+
+
+static int altek_stateoperationalstateispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateoperationalstate);
+	return ret;
+}
+
+
+#define altek_stateoperationalstateispdrv_enter_hwpt \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_leave_hwpt \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_coldboot \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_scenario_chg \
+			altek_statestandbystateispdrv_scenario_chg
+
+
+#define altek_stateoperationalstateispdrv_strm_on_off \
+			altek_statestandbystateispdrv_strm_on_off
+
+
+static int altek_stateoperationalstateispdrv_set_qp(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_set_qp(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateoperationalstate);
+	return ret;
+}
+
+
+static int altek_stateoperationalstateispdrv_stop(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_stop(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statestandbystate);
+	return ret;
+}
+
+
+#define altek_stateoperationalstateispdrv_enter_cp \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_leave_cp \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_leave_cp_standy \
+			altek_stateoperationalstateispdrv_open
+
+
+#define altek_stateoperationalstateispdrv_close \
+			altek_stateoperationalstateispdrv_open
+
+
+static int altek_statecode_persistencestateispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = error_sequence(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statecode_persistencestate);
+	return ret;
+}
+
+
+static int altek_statecode_persistencestateispdrv_enter_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_enter_hwpt(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statecode_persistencestate);
+	return ret;
+}
+
+
+#define altek_statecode_persistencestateispdrv_leave_hwpt \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_coldboot \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_scenario_chg \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_strm_on_off \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_set_qp \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_stop \
+			altek_statecode_persistencestateispdrv_open
+
+
+#define altek_statecode_persistencestateispdrv_enter_cp \
+			altek_statecode_persistencestateispdrv_open
+
+
+static int altek_statecode_persistencestateispdrv_leave_cp(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_leave_cp(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_stateoperationalstate);
+	return ret;
+}
+
+
+static int altek_statecode_persistencestateispdrv_leave_cp_standy(
+			struct altek_statefsm *fsm, void *o)
+{
+	int ret = 0;
+
+	ret = state_leave_cp_standy(o);
+	if (ret == 0)
+		fsm->changestate(fsm, &altek_statestandbystate);
+	return ret;
+}
+
+
+#define altek_statecode_persistencestateispdrv_close \
+			altek_stateopenstateispdrv_close
+
+
+int altek_statefsmispdrv_open(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_open(fsm, o);
+}
+
+
+int altek_statefsmispdrv_enter_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_enter_hwpt(fsm, o);
+}
+
+
+int altek_statefsmispdrv_leave_hwpt(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_leave_hwpt(fsm, o);
+}
+
+
+int altek_statefsmispdrv_coldboot(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_coldboot(fsm, o);
+}
+
+
+int altek_statefsmispdrv_scenario_chg(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_scenario_chg(fsm, o);
+}
+
+
+int altek_statefsmispdrv_strm_on_off(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_strm_on_off(fsm, o);
+}
+
+
+int altek_statefsmispdrv_set_qp(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_set_qp(fsm, o);
+}
+
+
+int altek_statefsmispdrv_stop(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_stop(fsm, o);
+}
+
+
+int altek_statefsmispdrv_enter_cp(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_enter_cp(fsm, o);
+}
+
+
+int altek_statefsmispdrv_leave_cp(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_leave_cp(fsm, o);
+}
+
+
+int altek_statefsmispdrv_leave_cp_standy(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_leave_cp_standy(fsm, o);
+}
+
+
+int altek_statefsmispdrv_close(
+			struct altek_statefsm *fsm, void *o)
+{
+	return fsm->m_state->ispdrv_close(fsm, o);
+}
+
+
+void altek_statefsmchangestate(struct altek_statefsm *fsm,
+			struct altek_state *newstate)
+{
+		fsm->m_state = newstate;
+}
+
+
+struct altek_statefsm *altek_statefsmcreate(void)
+{
+	if (fsm_size >= maxfsms)
+		return 0;
+	if (!initialized) {
+		initialized = 1;
+		altek_stateclosestate.ispdrv_open =
+			altek_stateclosestateispdrv_open;
+		altek_stateclosestate.ispdrv_enter_hwpt =
+			altek_stateclosestateispdrv_enter_hwpt;
+		altek_stateclosestate.ispdrv_leave_hwpt =
+			altek_stateclosestateispdrv_leave_hwpt;
+		altek_stateclosestate.ispdrv_coldboot =
+			altek_stateclosestateispdrv_coldboot;
+		altek_stateclosestate.ispdrv_scenario_chg =
+			altek_stateclosestateispdrv_scenario_chg;
+		altek_stateclosestate.ispdrv_strm_on_off =
+			altek_stateclosestateispdrv_strm_on_off;
+		altek_stateclosestate.ispdrv_set_qp =
+			altek_stateclosestateispdrv_set_qp;
+		altek_stateclosestate.ispdrv_stop =
+			altek_stateclosestateispdrv_stop;
+		altek_stateclosestate.ispdrv_enter_cp =
+			altek_stateclosestateispdrv_enter_cp;
+		altek_stateclosestate.ispdrv_leave_cp =
+			altek_stateclosestateispdrv_leave_cp;
+		altek_stateclosestate.ispdrv_leave_cp_standy =
+			altek_stateclosestateispdrv_leave_cp_standy;
+		altek_stateclosestate.ispdrv_close =
+			altek_stateclosestateispdrv_close;
+		altek_stateopenstate.ispdrv_open =
+			altek_stateopenstateispdrv_open;
+		altek_stateopenstate.ispdrv_enter_hwpt =
+			altek_stateopenstateispdrv_enter_hwpt;
+		altek_stateopenstate.ispdrv_leave_hwpt =
+			altek_stateopenstateispdrv_leave_hwpt;
+		altek_stateopenstate.ispdrv_coldboot =
+			altek_stateopenstateispdrv_coldboot;
+		altek_stateopenstate.ispdrv_scenario_chg =
+			altek_stateopenstateispdrv_scenario_chg;
+		altek_stateopenstate.ispdrv_strm_on_off =
+			altek_stateopenstateispdrv_strm_on_off;
+		altek_stateopenstate.ispdrv_set_qp =
+			altek_stateopenstateispdrv_set_qp;
+		altek_stateopenstate.ispdrv_stop =
+			altek_stateopenstateispdrv_stop;
+		altek_stateopenstate.ispdrv_enter_cp =
+			altek_stateopenstateispdrv_enter_cp;
+		altek_stateopenstate.ispdrv_leave_cp =
+			altek_stateopenstateispdrv_leave_cp;
+		altek_stateopenstate.ispdrv_leave_cp_standy =
+			altek_stateopenstateispdrv_leave_cp_standy;
+		altek_stateopenstate.ispdrv_close =
+			altek_stateopenstateispdrv_close;
+		altek_statehw_pass_thrustate.ispdrv_open =
+			altek_statehw_pass_thrustateispdrv_open;
+		altek_statehw_pass_thrustate.ispdrv_enter_hwpt =
+			altek_statehw_pass_thrustateispdrv_enter_hwpt;
+		altek_statehw_pass_thrustate.ispdrv_leave_hwpt =
+			altek_statehw_pass_thrustateispdrv_leave_hwpt;
+		altek_statehw_pass_thrustate.ispdrv_coldboot =
+			altek_statehw_pass_thrustateispdrv_coldboot;
+		altek_statehw_pass_thrustate.ispdrv_strm_on_off =
+			altek_statehw_pass_thrustateispdrv_strm_on_off;
+		altek_statehw_pass_thrustate.ispdrv_set_qp =
+			altek_statehw_pass_thrustateispdrv_set_qp;
+		altek_statehw_pass_thrustate.ispdrv_scenario_chg =
+			altek_statehw_pass_thrustateispdrv_scenario_chg;
+		altek_statehw_pass_thrustate.ispdrv_stop =
+			altek_statehw_pass_thrustateispdrv_stop;
+		altek_statehw_pass_thrustate.ispdrv_enter_cp =
+			altek_statehw_pass_thrustateispdrv_enter_cp;
+		altek_statehw_pass_thrustate.ispdrv_leave_cp =
+			altek_statehw_pass_thrustateispdrv_leave_cp;
+		altek_statehw_pass_thrustate.ispdrv_leave_cp_standy =
+			altek_statehw_pass_thrustateispdrv_leave_cp_standy;
+		altek_statehw_pass_thrustate.ispdrv_close =
+			altek_statehw_pass_thrustateispdrv_close;
+		altek_statestandbystate.ispdrv_open =
+			altek_statestandbystateispdrv_open;
+		altek_statestandbystate.ispdrv_enter_hwpt =
+			altek_statestandbystateispdrv_enter_hwpt;
+		altek_statestandbystate.ispdrv_leave_hwpt =
+			altek_statestandbystateispdrv_leave_hwpt;
+		altek_statestandbystate.ispdrv_coldboot =
+			altek_statestandbystateispdrv_coldboot;
+		altek_statestandbystate.ispdrv_scenario_chg =
+			altek_statestandbystateispdrv_scenario_chg;
+		altek_statestandbystate.ispdrv_strm_on_off =
+			altek_statestandbystateispdrv_strm_on_off;
+		altek_statestandbystate.ispdrv_set_qp =
+			altek_statestandbystateispdrv_set_qp;
+		altek_statestandbystate.ispdrv_stop =
+			altek_statestandbystateispdrv_stop;
+		altek_statestandbystate.ispdrv_enter_cp =
+			altek_statestandbystateispdrv_enter_cp;
+		altek_statestandbystate.ispdrv_leave_cp =
+			altek_statestandbystateispdrv_leave_cp;
+		altek_statestandbystate.ispdrv_leave_cp_standy =
+			altek_statestandbystateispdrv_leave_cp_standy;
+		altek_statestandbystate.ispdrv_close =
+			altek_statestandbystateispdrv_close;
+		altek_stateoperationalstate.ispdrv_open =
+			altek_stateoperationalstateispdrv_open;
+		altek_stateoperationalstate.ispdrv_enter_hwpt =
+			altek_stateoperationalstateispdrv_enter_hwpt;
+		altek_stateoperationalstate.ispdrv_leave_hwpt =
+			altek_stateoperationalstateispdrv_leave_hwpt;
+		altek_stateoperationalstate.ispdrv_coldboot =
+			altek_stateoperationalstateispdrv_coldboot;
+		altek_stateoperationalstate.ispdrv_scenario_chg =
+			altek_stateoperationalstateispdrv_scenario_chg;
+		altek_stateoperationalstate.ispdrv_strm_on_off =
+			altek_stateoperationalstateispdrv_strm_on_off;
+		altek_stateoperationalstate.ispdrv_set_qp =
+			altek_stateoperationalstateispdrv_set_qp;
+		altek_stateoperationalstate.ispdrv_stop =
+			altek_stateoperationalstateispdrv_stop;
+		altek_stateoperationalstate.ispdrv_enter_cp =
+			altek_stateoperationalstateispdrv_enter_cp;
+		altek_stateoperationalstate.ispdrv_leave_cp =
+			altek_stateoperationalstateispdrv_leave_cp;
+		altek_stateoperationalstate.ispdrv_leave_cp_standy =
+			altek_stateoperationalstateispdrv_leave_cp_standy;
+		altek_stateoperationalstate.ispdrv_close =
+			altek_stateoperationalstateispdrv_close;
+		altek_statecode_persistencestate.ispdrv_open =
+			altek_statecode_persistencestateispdrv_open;
+		altek_statecode_persistencestate.ispdrv_enter_hwpt =
+			altek_statecode_persistencestateispdrv_enter_hwpt;
+		altek_statecode_persistencestate.ispdrv_leave_hwpt =
+			altek_statecode_persistencestateispdrv_leave_hwpt;
+		altek_statecode_persistencestate.ispdrv_coldboot =
+			altek_statecode_persistencestateispdrv_coldboot;
+		altek_statecode_persistencestate.ispdrv_scenario_chg =
+			altek_statecode_persistencestateispdrv_scenario_chg;
+		altek_statecode_persistencestate.ispdrv_strm_on_off =
+			altek_statecode_persistencestateispdrv_strm_on_off;
+		altek_statecode_persistencestate.ispdrv_set_qp =
+			altek_statecode_persistencestateispdrv_set_qp;
+		altek_statecode_persistencestate.ispdrv_stop =
+			altek_statecode_persistencestateispdrv_stop;
+		altek_statecode_persistencestate.ispdrv_enter_cp =
+			altek_statecode_persistencestateispdrv_enter_cp;
+		altek_statecode_persistencestate.ispdrv_leave_cp =
+			altek_statecode_persistencestateispdrv_leave_cp;
+		altek_statecode_persistencestate.ispdrv_leave_cp_standy =
+			altek_statecode_persistencestateispdrv_leave_cp_standy;
+		altek_statecode_persistencestate.ispdrv_close =
+			altek_statecode_persistencestateispdrv_close;
+	}
+	FSM[fsm_size] = kzalloc(sizeof(struct altek_statefsm), GFP_KERNEL);
+	FSM[fsm_size]->ispdrv_open =
+		altek_statefsmispdrv_open;
+	FSM[fsm_size]->ispdrv_enter_hwpt =
+		altek_statefsmispdrv_enter_hwpt;
+	FSM[fsm_size]->ispdrv_leave_hwpt =
+		altek_statefsmispdrv_leave_hwpt;
+	FSM[fsm_size]->ispdrv_coldboot =
+		altek_statefsmispdrv_coldboot;
+	FSM[fsm_size]->ispdrv_scenario_chg =
+		altek_statefsmispdrv_scenario_chg;
+	FSM[fsm_size]->ispdrv_strm_on_off =
+		altek_statefsmispdrv_strm_on_off;
+	FSM[fsm_size]->ispdrv_set_qp =
+		altek_statefsmispdrv_set_qp;
+	FSM[fsm_size]->ispdrv_stop =
+		altek_statefsmispdrv_stop;
+	FSM[fsm_size]->ispdrv_enter_cp =
+		altek_statefsmispdrv_enter_cp;
+	FSM[fsm_size]->ispdrv_leave_cp =
+		altek_statefsmispdrv_leave_cp;
+	FSM[fsm_size]->ispdrv_leave_cp_standy =
+		altek_statefsmispdrv_leave_cp_standy;
+	FSM[fsm_size]->ispdrv_close =
+		altek_statefsmispdrv_close;
+	FSM[fsm_size]->changestate = altek_statefsmchangestate;
+	FSM[fsm_size]->m_state = &altek_stateclosestate;
+	return FSM[fsm_size++];
+}
+
+
+void altek_statefsmdelete(struct altek_statefsm *fsm)
+{
+	int i;
+	int index = -1;
+
+	if (fsm_size == 0 || fsm == NULL)
+		return;
+
+	for (i = 0; i < fsm_size; ++i) {
+		if (FSM[i] == fsm) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index == -1)
+		return;
+
+	--fsm_size;
+
+	if (maxfsms != 1)
+		for (i = index; i < fsm_size; ++i)
+			FSM[i] = FSM[i+1];
+
+	if (fsm_size == index)
+		FSM[fsm_size] = NULL;
+
+	kfree(fsm);
+}
diff --git a/drivers/media/platform/msm/camera/al6100/basic_setting_cmd.c b/drivers/media/platform/msm/camera/al6100/basic_setting_cmd.c
new file mode 100644
index 0000000..bd615a6
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/basic_setting_cmd.c
@@ -0,0 +1,109 @@
+/*
+ * File: basic_setting_cmd.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/******Include File******/
+#include "include/isp_camera_cmd.h"
+#include "include/ispctrl_if_master.h"
+#include "include/error/ispctrl_if_master_err.h"
+#include "include/miniisp.h"
+#include "include/ispctrl_if_master_local.h"
+
+/******Private Constant Definition******/
+
+/******Private Type Declaration******/
+
+/******Private Function Prototype******/
+
+/******Private Global Variable******/
+
+/******Public Global Variable******/
+
+/******Public Function******/
+
+/*
+ *\brief Set Depth 3A Info
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_3a_info(void *devdata,
+							u16 opcode, u8 *param)
+{
+	/*Error Code */
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct isp_cmd_depth_3a_info);
+
+	/*Send command to slave */
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set Depth auto interleave mode
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_auto_interleave_mode(
+	void *devdata, u16 opcode, u8 *param)
+{
+	/*Error Code */
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct isp_cmd_depth_auto_interleave_param);
+
+	/*Send command to slave */
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set projector interleave mode with depth type
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_interleave_mode_depth_type(
+	void *devdata, u16 opcode, u8 *param)
+{
+	/*Error Code */
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct isp_cmd_interleave_mode_depth_type);
+
+	/*Send command to slave */
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set depth polish level
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_polish_level(
+	void *devdata, u16 opcode, u8 *param)
+{
+	/*Error Code */
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct isp_cmd_depth_polish_level);
+
+	/*Send command to slave */
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+/******End Of File******/
diff --git a/drivers/media/platform/msm/camera/al6100/bulk_data_cmd.c b/drivers/media/platform/msm/camera/al6100/bulk_data_cmd.c
new file mode 100644
index 0000000..bde5902
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/bulk_data_cmd.c
@@ -0,0 +1,605 @@
+/*
+ * File:  bulk_data_cmd.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Bruce Chung; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ *  2016/05/05; Louis Wang; Linux Coding Style
+ */
+
+/******Include File******/
+#include <linux/buffer_head.h>
+
+#include "include/isp_camera_cmd.h"
+#include "include/ispctrl_if_master.h"
+#include "include/error/ispctrl_if_master_err.h"
+#include "include/miniisp.h"
+#include "include/ispctrl_if_master_local.h"
+#include "include/miniisp_customer_define.h"
+/******Private Constant Definition******/
+#define LOGSIZE  (4*1024)
+//#define BLOCKSIZE SPI_TX_BULK_SIZE
+#define RAWBLOCKSIZE SPI_TX_BULK_SIZE_BOOT
+#define MINI_ISP_LOG_TAG	"[[miniisp]bulk_data_cmd]"
+#define MID_PJ_EXEBIN_BUF (1024*1024)
+
+/*Private Type Declaration*/
+/*Basic code buffer address*/
+static u8 *basic_code_buf_addr;
+/*Calibration data buffer address*/
+static u8 *calibration_data_buf_addr;
+
+/******Private Function Prototype******/
+static u16 calculate_check_sum(u8 *input_buffer_addr, u16 input_buffer_size);
+
+/******Private Global Variable******/
+
+
+/******Public Global Variable*******/
+
+/******Public Function******/
+
+
+/**
+ *\brief Write Boot Code
+ *\param devdata [In], misp_data
+ *\param param [In], CMD param
+ *\param filp [In], boot code file pointer
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_boot_code(void *devdata,
+						u8 *param, struct file *filp)
+{
+	errcode err = ERR_SUCCESS;
+	u32 total_size;
+	off_t currpos;
+
+	if (filp == NULL) {
+		misp_err("%s - file didn't exist.", __func__);
+		err = ~ERR_SUCCESS;
+		goto mast_bulk_data_cmd_write_boot_code_end;
+	}
+
+	/*get the file size*/
+	currpos = vfs_llseek(filp, 0L, SEEK_END);
+	if (currpos == -1) {
+		misp_err("%s  llseek failed", __func__);
+		err = ~ERR_SUCCESS;
+		goto mast_bulk_data_cmd_write_boot_code_end;
+	}
+	total_size = (u32)currpos;
+	/*misp_info("%s  filesize : %d", __func__, total_size);*/
+	vfs_llseek(filp, 0L, SEEK_SET);
+
+	/*misp_info("block_size %d", RAWBLOCKSIZE);*/
+
+	/*Transfer boot code*/ /* boot code & main code can only be sent by SPI */
+	err = ispctrl_if_mast_send_bulk(devdata,
+		basic_code_buf_addr, filp, total_size, RAWBLOCKSIZE, true);
+
+	if (err != ERR_SUCCESS)
+		goto mast_bulk_data_cmd_write_boot_code_end;
+
+	misp_info("%s send boot code success", __func__);
+
+mast_bulk_data_cmd_write_boot_code_end:
+
+	return err;
+}
+
+
+/**
+ *\brief Write Basic Code
+ *\param devdata [In], misp_data
+ *\param param [In], CMD param
+ *\param filp  [In], basic code file pointer
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_basic_code(void *devdata,
+						u8 *param, struct file *filp)
+{
+	errcode err = ERR_SUCCESS;
+	u8 fw_version[4];
+	u16 fw_version_before_point, fw_version_after_point;
+	char fw_build_by[9];
+	u32 para_size = ISPCMD_EXEBIN_INFOBYTES;
+	u32 *total_size = (u32 *)&param[ISPCMD_EXEBIN_ADDRBYTES];
+	u32 file_total_size;
+	u32 block_size;
+	off_t currpos;
+	loff_t offset;
+	mm_segment_t oldfs;
+
+	if (filp == NULL) {
+		misp_err("%s - file didn't exist.", __func__);
+		err = ~ERR_SUCCESS;
+		goto mast_bulk_data_cmd_write_basic_code_end;
+	}
+
+	block_size = ((struct misp_data *)devdata)->bulk_cmd_blocksize;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+
+	/*get the file size*/
+	currpos = vfs_llseek(filp, 0L, SEEK_END);
+	if (currpos == -1) {
+		set_fs(oldfs);
+		misp_err("%s - llseek end failed", __func__);
+		err = ~ERR_SUCCESS;
+		goto mast_bulk_data_cmd_write_basic_code_end;
+	}
+
+	file_total_size = (u32)currpos;
+	/*misp_info("%s  filesize : %u", __func__, file_total_size);*/
+
+	currpos = vfs_llseek(filp, 0L, SEEK_SET);
+	if (currpos == -1) {
+		set_fs(oldfs);
+		misp_err("%s - llseek set failed", __func__);
+		err = ~ERR_SUCCESS;
+		goto mast_bulk_data_cmd_write_basic_code_end;
+	}
+
+
+	/*read the header info (first 16 bytes in the basic code)*/
+	offset = filp->f_pos;
+	err = vfs_read(filp, param, ISPCMD_EXEBIN_INFOBYTES, &offset);
+	set_fs(oldfs);
+	if (err == -1) {
+		misp_err("%s - Read file failed.", __func__);
+		/*close the file*/
+		filp_close(filp, NULL);
+		goto mast_bulk_data_cmd_write_basic_code_end;
+	}
+	filp->f_pos = offset;
+
+	/*To copy checksum value to correct header point*/
+	memcpy((u8 *)(param + ISPCMD_EXEBIN_ADDRBYTES +
+		  ISPCMD_EXEBIN_TOTALSIZEBYTES + ISPCMD_EXEBIN_BLOCKSIZEBYTES),
+		(u8 *)(param + ISPCMD_EXEBIN_ADDRBYTES +
+		ISPCMD_EXEBIN_TOTALSIZEBYTES), sizeof(u32));
+	/*Assign block size to correct header point*/
+	memcpy((u8 *)(param + ISPCMD_EXEBIN_ADDRBYTES +
+		ISPCMD_EXEBIN_TOTALSIZEBYTES), &block_size, sizeof(u32));
+
+	/*misp_info("%s param[0][1][2][3]: %02x %02x %02x %02x",
+	 *__func__, param[0], param[1], param[2], param[3]);
+	 *misp_info("%s param[4][5][6][7]: %02x %02x %02x %02x",
+	 *__func__, param[4], param[5], param[6], param[7]);
+	 *misp_info("%s param[8][9][10][11]: %02x %02x %02x %02x",
+	 *__func__, param[8], param[9], param[10], param[11]);
+	 *misp_info("%s param[12][13][14][15]: %02x %02x %02x %02x",
+	 *__func__, param[12], param[13], param[14], param[15]);
+	 */
+
+	/*Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata,
+		ISPCMD_BULK_WRITE_BASICCODE, param, para_size);
+	if (err != ERR_SUCCESS)
+		goto mast_bulk_data_cmd_write_basic_code_end;
+
+	/*misp_info("%s send leaking packet success", __func__);*/
+
+	/*misp_info("block_size %d", BLOCKSIZE);*/
+
+	/*Transfer basic code*/
+	err = ispctrl_if_mast_send_bulk(devdata,
+		basic_code_buf_addr, filp, *total_size, block_size, false);
+	if (err != ERR_SUCCESS)
+		goto mast_bulk_data_cmd_write_basic_code_end;
+
+	misp_info("%s - send basic code success", __func__);
+
+	/*wait for the interrupt*/
+	err = mini_isp_wait_for_event(MINI_ISP_RCV_BULKDATA);
+
+	if (err != ERR_SUCCESS)
+		goto mast_bulk_data_cmd_write_basic_code_end;
+
+	set_fs(KERNEL_DS);
+	offset = filp->f_pos;
+	currpos = vfs_llseek(filp, file_total_size - 12, SEEK_SET);
+	err = vfs_read(filp, fw_version, 4, &filp->f_pos);
+	err = vfs_read(filp, fw_build_by, 8, &filp->f_pos);
+	set_fs(oldfs);
+
+	if (err == -1) {
+		misp_info("%s - Read file failed.", __func__);
+	 } else {
+		 err = 0;
+		 fw_version_before_point = fw_version[1]*256 + fw_version[0];
+		 fw_version_after_point = fw_version[3]*256 + fw_version[2];
+		 fw_build_by[8] = '\0';
+		 misp_info("%s - fw version: %05d.%05d, build by %s",
+			__func__, fw_version_before_point,
+			fw_version_after_point, fw_build_by);
+}
+mast_bulk_data_cmd_write_basic_code_end:
+
+	return err;
+}
+
+
+
+/**
+ *\brief Write Calibration Data
+ *\param devdata [In], misp_data
+ *\param param [In], CMD param
+ *\param filp  [In], calibration data file pointer
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_calibration_data(void *devdata,
+						u8 *param, struct file *filp)
+{
+	errcode err = ERR_SUCCESS;
+	u8 infomode;
+	u16 ckecksum;
+	u32 build_date;
+	u32 para_size = 11;
+	u32 filesize;
+	u32 block_size;
+	off_t currpos;
+	loff_t offset;
+	mm_segment_t oldfs;
+
+	infomode = param[8];
+	block_size = ((struct misp_data *)devdata)->bulk_cmd_blocksize;
+
+
+	if ((infomode >= 2) && (infomode < 7)) { // Trasfered files have been opened in kernel when mini_isp_drv_load_fw().
+		if (filp == NULL) {
+			misp_err("%s - file didn't exist.", __func__);
+			err = ~ERR_SUCCESS;
+			goto mast_bulk_data_cmd_write_calibration_data_end;
+		}
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+
+		/*get the file size*/
+		currpos = vfs_llseek(filp, 0L, SEEK_END);
+		if (currpos == -1) {
+			set_fs(oldfs);
+			misp_err("%s  llseek end failed", __func__);
+			err = ~ERR_SUCCESS;
+			goto mast_bulk_data_cmd_write_calibration_data_end;
+		}
+
+		filesize = (u32)currpos;
+		/*misp_info("%s  filesize : %u", __func__, filesize);*/
+
+		currpos = vfs_llseek(filp, 0L, SEEK_SET);
+		if (currpos == -1) {
+			set_fs(oldfs);
+			misp_err("%s  llseek set failed", __func__);
+			err = ~ERR_SUCCESS;
+			goto mast_bulk_data_cmd_write_calibration_data_end;
+		}
+
+		/*Request memory*/
+		calibration_data_buf_addr = kzalloc(filesize, GFP_KERNEL);
+		if (!calibration_data_buf_addr) {
+			err = ~ERR_SUCCESS;
+			kfree(calibration_data_buf_addr);
+			goto mast_bulk_data_cmd_write_calibration_data_fail;
+		}
+
+		if (infomode == 2) {  //if the file is SC table, print the SC table built day
+			vfs_llseek(filp, 16, SEEK_SET);
+			vfs_read(filp, calibration_data_buf_addr, 4,
+				&filp->f_pos);
+			build_date = calibration_data_buf_addr[3]*256*256*256 +
+				calibration_data_buf_addr[2]*256*256 +
+				calibration_data_buf_addr[1]*256 +
+				calibration_data_buf_addr[0];
+			misp_info("%s - SC table build date %d.", __func__,
+				build_date);
+			vfs_llseek(filp, 0L, SEEK_SET);
+		}
+
+		/*read the header info (first 16 bytes in the data)*/
+		offset = filp->f_pos;
+		err = vfs_read(filp, calibration_data_buf_addr, filesize,
+				&offset);
+		set_fs(oldfs);
+		if (err == -1) {
+			misp_err("%s Read file failed.", __func__);
+			/*close the file*/
+			filp_close(filp, NULL);
+			kfree(calibration_data_buf_addr);
+			goto mast_bulk_data_cmd_write_calibration_data_end;
+		}
+		filp->f_pos = offset;
+		vfs_llseek(filp, 0L, SEEK_SET);
+
+		ckecksum = calculate_check_sum((u8 *) calibration_data_buf_addr,
+						filesize);
+
+		/*Assign Info ID to correct header point*/
+		memcpy((u8 *)(param + 8), &infomode, sizeof(u8));
+		/*To copy Total Size to correct header point*/
+		memcpy((u8 *)param, &filesize, sizeof(u32));
+		/*Assign block size to correct header point*/
+		memcpy((u8 *)(param + 4), &block_size, sizeof(u32));
+		/*Assign check sum to correct header point*/
+		memcpy((u8 *)(param + 9), &ckecksum, sizeof(u16));
+
+		misp_info("%s [0][1][2][3]:%02x %02x %02x %02x",
+			__func__, param[0], param[1], param[2], param[3]);
+		misp_info("%s [4][5][6][7]:%02x %02x %02x %02x",
+			__func__, param[4], param[5], param[6], param[7]);
+		misp_info("%s [8][9][10]:%02x %02x %02x",
+			__func__, param[8], param[9], param[10]);
+
+	} else { // Trasfered buffer has opened in user space and passed to kernel.
+		memcpy(&filesize, param, sizeof(u32));
+		calibration_data_buf_addr = kzalloc(filesize, GFP_KERNEL);
+
+		if (!calibration_data_buf_addr) {
+			err = ~ERR_SUCCESS;
+			kfree(calibration_data_buf_addr);
+			goto mast_bulk_data_cmd_write_calibration_data_fail;
+		}
+		memcpy(calibration_data_buf_addr,
+			param + T_SPI_CMD_LENGTH, filesize);
+	}
+
+	/*Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata,
+		ISPCMD_BULK_WRITE_CALIBRATION_DATA, param, para_size);
+	if (err != ERR_SUCCESS) {
+		kfree(calibration_data_buf_addr);
+		goto mast_bulk_data_cmd_write_calibration_data_end;
+	}
+
+	/*misp_info("%s send leaking packet success", __func__);*/
+
+	/*misp_info("block_size %d", BLOCKSIZE);*/
+
+	err = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	if (err)
+		goto mast_bulk_data_cmd_write_calibration_data_fail;
+
+	err = ispctrl_if_mast_send_bulk(devdata,
+		calibration_data_buf_addr, filp, filesize, block_size,
+		false);
+
+	kfree(calibration_data_buf_addr);
+
+	if (err != ERR_SUCCESS)
+		goto mast_bulk_data_cmd_write_calibration_data_end;
+
+	err = mini_isp_wait_for_event(MINI_ISP_RCV_BULKDATA);
+	if (err)
+		goto mast_bulk_data_cmd_write_calibration_data_fail;
+
+	if (infomode == 0)
+		misp_info("%s write IQ calibration data success", __func__);
+	else if (infomode == 1)
+		misp_info("%s write depth packet data success", __func__);
+	else if (infomode == 2)
+		misp_info("%s write scenario table success", __func__);
+	else if (infomode == 3)
+		misp_info("%s write HDR Qmerge data success", __func__);
+	else if (infomode == 4)
+		misp_info("%s write IRP0 Qmerge data success", __func__);
+	else if (infomode == 5)
+		misp_info("%s write IRP1 Qmerge data success", __func__);
+	else if (infomode == 6)
+			misp_info("%s write PP map success", __func__);
+	else if (infomode == 7)
+			misp_info("%s write blending table success", __func__);
+	goto mast_bulk_data_cmd_write_calibration_data_end;
+
+mast_bulk_data_cmd_write_calibration_data_fail:
+	misp_err("%s mast_bulk_data_cmd_write_calibration_data_fail", __func__);
+
+mast_bulk_data_cmd_write_calibration_data_end:
+	return err;
+
+}
+
+/*
+ *\brief Read Memory Data
+ *\param devdata [In], misp_data
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_read_memory_data(void *devdata,
+							u8 *param)
+{
+	/*Error Code*/
+	errcode err = ERR_SUCCESS;
+	u8 *allocated_memmory = 0;
+	u32 read_size = 0;
+	u8 filename[80];
+	/*
+	 *Parameter size
+	 *4bytes for start addr, 4 bytes for total size, 4 bytes for block size,
+	 *4 bytes for memory dump mode
+	 */
+	u32 para_size = sizeof(struct memmory_dump_hdr_info);
+	/*Total size*/
+	u32 total_size;
+	struct memmory_dump_hdr_info *memory_dump_hdr_config;
+	struct file *f;
+	mm_segment_t fs;
+
+	read_size = MID_PJ_EXEBIN_BUF;
+
+	/*Request memory*/
+	allocated_memmory = kzalloc(read_size, GFP_KERNEL);
+	if (!allocated_memmory) {
+		err = ~ERR_SUCCESS;
+		goto allocate_memory_fail;
+	}
+
+
+	memory_dump_hdr_config = (struct memmory_dump_hdr_info *)param;
+
+	/*Assign total size*/
+	total_size = memory_dump_hdr_config->total_size;
+	if (total_size > read_size) {
+		err = ERR_MASTERCMDSIZE_MISMATCH;
+		goto mast_bulk_data_cmd_read_memory_data_end;
+	}
+
+	/*Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata,
+		ISPCMD_BULK_READ_MEMORY, param, para_size);
+	if (err != ERR_SUCCESS) {
+		kfree(allocated_memmory);
+		goto mast_bulk_data_cmd_read_memory_data_end;
+	}
+	/*Get memory data from slave*/
+	err = ispctrl_if_mast_recv_memory_data_from_slave(devdata,
+							allocated_memmory,
+							&total_size, true);
+	if (err != ERR_SUCCESS) {
+		kfree(allocated_memmory);
+		goto mast_bulk_data_cmd_read_memory_data_end;
+	}
+
+	misp_info("%s - Read memory finished.", __func__);
+	/*write out allocated_memmory to file here*/
+	/*** add your codes here ***/
+	snprintf(filename, 80, "%s/miniISP_memory.log",
+		MINIISP_INFO_DUMPLOCATION);
+	f = filp_open(filename, O_APPEND|O_CREAT, 0777);
+	/*Get current segment descriptor*/
+	fs = get_fs();
+	/*Set segment descriptor associated*/
+	set_fs(get_ds());
+	/*write the file*/
+	f->f_op->write(f, (char *)allocated_memmory, total_size,
+		&f->f_pos);
+	/*Restore segment descriptor*/
+	set_fs(fs);
+	filp_close(f, NULL);
+	/*** end of the codes ***/
+
+	goto mast_bulk_data_cmd_read_memory_data_end;
+
+allocate_memory_fail:
+
+	misp_err("%s Allocate memory failed.", __func__);
+mast_bulk_data_cmd_read_memory_data_end:
+	kfree(allocated_memmory);
+	return err;
+
+
+}
+
+/*
+ *\brief Read common log data
+ *\param devdata [In], misp_data
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode bulk_data_cmd_read_common_log(void *devdata, u8 *param)
+{
+	/*Error Code*/
+	errcode err = ERR_SUCCESS;
+	u8 *allocated_memmory = 0;
+	u32 read_size = LOGSIZE;
+	struct file *f;
+	mm_segment_t fs;
+	u8 filename[80];
+
+	/*Parameter size : 4 bytes for total size, 4 bytes for block size*/
+	u32 para_size = sizeof(struct common_log_hdr_info);
+	/*Total size*/
+	u32 total_size;
+	struct common_log_hdr_info *common_log_hdr_cfg;
+
+
+	/*Request memory*/
+	allocated_memmory = kzalloc(read_size, GFP_KERNEL);
+	if (!allocated_memmory) {
+		err = ~ERR_SUCCESS;
+		goto allocate_memory_fail;
+	}
+
+
+	common_log_hdr_cfg = (struct common_log_hdr_info *)param;
+
+	/*Assign total size*/
+	total_size = common_log_hdr_cfg->total_size;
+	if (total_size > read_size) {
+		err = ERR_MASTERCMDSIZE_MISMATCH;
+		kfree(allocated_memmory);
+		goto bulk_data_cmd_read_common_log_end;
+	}
+
+	/*Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata,
+		ISPCMD_BULK_READ_COMLOG, param, para_size);
+	if (err != ERR_SUCCESS) {
+		kfree(allocated_memmory);
+		goto bulk_data_cmd_read_common_log_end;
+	}
+	misp_info("%s - Start to read log.", __func__);
+
+	/*
+	 *Get memory data from slave,don't wait INT
+	 *and use polling interval to wait
+	 */
+	err = ispctrl_if_mast_recv_memory_data_from_slave(devdata,
+							allocated_memmory,
+							&total_size,
+							true);
+	if (err != ERR_SUCCESS) {
+		kfree(allocated_memmory);
+		goto bulk_data_cmd_read_common_log_end;
+	}
+	misp_info("%s - Read log finished.", __func__);
+	snprintf(filename, 80, "%s/miniISP_Common_Log.log",
+		MINIISP_INFO_DUMPLOCATION);
+	f = filp_open(filename, O_APPEND|O_CREAT, 0777);
+	/*Get current segment descriptor*/
+	fs = get_fs();
+	/*Set segment descriptor associated*/
+	set_fs(get_ds());
+	/*write the file*/
+	f->f_op->write(f, (char *)allocated_memmory, strlen(allocated_memmory),
+		&f->f_pos);
+	/*Restore segment descriptor*/
+	set_fs(fs);
+	filp_close(f, NULL);
+
+	goto bulk_data_cmd_read_common_log_end;
+allocate_memory_fail:
+
+	misp_err("%s Allocate memory failed.", __func__);
+bulk_data_cmd_read_common_log_end:
+	kfree(allocated_memmory);
+	return err;
+}
+
+
+/******Private Function******/
+static u16 calculate_check_sum(u8 *input_buffer_addr, u16 input_buffer_size)
+{
+	u16 i;
+	u32 sum = 0;
+	u16 sumvalue;
+
+	/*calculating unit is 2 bytes */
+	for (i = 0; i < input_buffer_size; i++) {
+		if (0 == (i%2))
+			sum += input_buffer_addr[i];
+		else
+			sum += (input_buffer_addr[i] << 8);
+	}
+
+	/*Do 2's complement */
+	sumvalue = (u16)(65536 - (sum & 0x0000FFFF));
+
+	return sumvalue;
+}
+
+/******End Of File******/
diff --git a/drivers/media/platform/msm/camera/al6100/camera_profile_cmd.c b/drivers/media/platform/msm/camera/al6100/camera_profile_cmd.c
new file mode 100644
index 0000000..20b7576
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/camera_profile_cmd.c
@@ -0,0 +1,401 @@
+/*
+ * File: camera_profile_cmd.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Bruce Chung; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/******Include File******/
+
+#include <linux/string.h>
+
+#include "include/mtype.h"
+#include "include/error.h"
+#include "include/miniisp.h"
+#include "include/isp_camera_cmd.h"
+#include "include/ispctrl_if_master.h"
+#include "include/ispctrl_if_master_local.h"
+
+/******Private Constant Definition******/
+#define MINI_ISP_LOG_TAG "[[miniisp]camera_profile_cmd]"
+
+/******Private Type Declaration******/
+
+/******Private Function Prototype******/
+
+/******Private Global Variable******/
+
+static struct isp_cmd_get_sensor_mode mast_sensors_info;
+
+/******Public Function******/
+
+/*
+ *\brief Camera profile parameters init
+ *\return None
+ */
+void isp_mast_camera_profile_para_init(void)
+{
+	/*Reset Camera profile parameters*/
+	memset(&mast_sensors_info, 0x0,
+		sizeof(struct isp_cmd_get_sensor_mode));
+}
+
+/*
+ *\brief Set Sensor Mode
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_sensor_mode(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_set_sensor_mode);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+				param, para_size);
+
+
+	if ((((struct isp_cmd_set_sensor_mode *)param)->sensor_on_off)
+			&& (err == ERR_SUCCESS))
+		err = mini_isp_wait_for_event(MINI_ISP_RCV_SETSENSORMODE);
+
+	return err;
+}
+
+/*
+ *\brief Get Sensor Mode
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_get_sensor_mode(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_get_sensor_mode);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode, NULL, 0);
+	if (err  != ERR_SUCCESS)
+		goto mast_camera_profile_cmd_get_sensor_mode_end;
+
+	/* Get data from slave*/
+	err = ispctrl_mast_recv_response_from_slave(devdata,
+			(u8 *)&mast_sensors_info, para_size, true);
+	if (err  != ERR_SUCCESS)
+		goto mast_camera_profile_cmd_get_sensor_mode_end;
+
+	/* copy to usr defined target addr*/
+	memcpy(param, &mast_sensors_info, para_size);
+
+mast_camera_profile_cmd_get_sensor_mode_end:
+	return err;
+}
+
+/*
+ *\brief Set Output Format
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_output_format(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_set_output_format);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode, param,
+						para_size);
+
+	return err;
+}
+
+/*
+ *\brief Set CP Mode
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_cp_mode(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+
+	misp_info("%s - enter", __func__);
+
+	para_size = 0;
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+				param, para_size);
+	if (err != ERR_SUCCESS)
+		goto mast_camera_profile_cmd_set_cp_mode_end;
+
+	err = mini_isp_wait_for_event(MINI_ISP_RCV_CPCHANGE);
+
+mast_camera_profile_cmd_set_cp_mode_end:
+	return err;
+}
+
+/*
+ *\brief Set AE statistics
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_ae_statistics(void *devdata,
+							u16 opcode, u8 *param)
+{
+	/*Error Code */
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct isp_cmd_ae_statistics);
+	misp_info("%s - enter", __func__);
+
+	/*Send command to slave */
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+
+/*
+ *\brief Preview stream on off
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_preview_stream_on_off(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_preview_stream_on_off);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief dual PD Y calculation weightings
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_dual_pd_y_cauculation_weightings(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_dual_pd_y_calculation_weightings);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief LED power control
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_led_power_control(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_led_power_control);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Active AE
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_active_ae(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_active_ae);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Control AE on/off
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_isp_ae_control_on_off(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_isp_ae_control_on_off);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set Frame Rate Limits
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_frame_rate_limits(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_frame_rate_limits);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set period drop frame
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_period_drop_frame(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_period_drop_frame);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set Max exposure
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_max_exposure(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_max_exposure);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/*
+ *\brief Set target mean
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_target_mean(
+						void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size;
+	misp_info("%s - enter", __func__);
+
+	para_size = sizeof(struct isp_cmd_target_mean);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+			param, para_size);
+	return err;
+}
+
+/************************** End Of File *******************************/
diff --git a/drivers/media/platform/msm/camera/al6100/include/altek_state.h b/drivers/media/platform/msm/camera/al6100/include/altek_state.h
new file mode 100644
index 0000000..9dce4ce
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/altek_state.h
@@ -0,0 +1,38 @@
+/*
+ * this file was generated by NunniFSMGen
+ */
+
+
+#ifndef altek_state_H
+#define altek_state_H
+
+#include "altek_statefsm.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif		/* __cplusplus */
+
+
+int state_open(void *o);
+int error_sequence(void *o);
+int redundant_sequence(void *o);
+int state_enter_hwpt(void *o);
+int state_coldboot(void *o);
+int state_close(void *o);
+int state_leave_hwpt(void *o);
+int state_scenario_chg(void *o);
+int state_strm_on_off(void *o);
+int state_enter_cp(void *o);
+int state_set_qp(void *o);
+int state_stop(void *o);
+int state_leave_cp(void *o);
+int state_leave_cp_standy(void *o);
+
+
+#ifdef __cplusplus
+}
+#endif		/* __cplusplus */
+
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/include/altek_statefsm.h b/drivers/media/platform/msm/camera/al6100/include/altek_statefsm.h
new file mode 100644
index 0000000..74fdab1
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/altek_statefsm.h
@@ -0,0 +1,89 @@
+/*
+ * this file was generated by NunniFSMGen - do not edit!
+ */
+
+
+#ifndef altek_statefsm_H
+#define altek_statefsm_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif		/* __cplusplus */
+
+
+struct altek_statefsm;
+
+struct altek_state {
+	int (*ispdrv_open)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_enter_hwpt)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_hwpt)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_coldboot)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_scenario_chg)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_strm_on_off)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_set_qp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_stop)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_enter_cp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_cp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_cp_standy)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_close)(struct altek_statefsm *fsm, void *o);
+};
+
+
+struct altek_statefsm {
+	int (*ispdrv_open)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_enter_hwpt)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_hwpt)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_coldboot)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_scenario_chg)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_strm_on_off)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_set_qp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_stop)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_enter_cp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_cp)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_leave_cp_standy)(struct altek_statefsm *fsm, void *o);
+	int (*ispdrv_close)(struct altek_statefsm *fsm, void *o);
+	void (*changestate)(struct altek_statefsm *fsm,
+		struct altek_state *nextstate);
+	struct altek_state *m_state;
+};
+
+extern struct altek_statefsm *altek_statefsmcreate(void);
+
+
+extern void altek_statefsmdelete(struct altek_statefsm *fsm);
+
+/* events */
+extern int altek_statefsmispdrv_open(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_enter_hwpt(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_leave_hwpt(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_coldboot(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_scenario_chg(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_strm_on_off(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_set_qp(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_stop(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_enter_cp(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_leave_cp(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_leave_cp_standy(
+	struct altek_statefsm *fsm, void *o);
+extern int altek_statefsmispdrv_close(
+	struct altek_statefsm *fsm, void *o);
+
+
+#ifdef __cplusplus
+}
+#endif		/* __cplusplus */
+
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/include/error.h b/drivers/media/platform/msm/camera/al6100/include/error.h
new file mode 100644
index 0000000..85e2d8e
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/error.h
@@ -0,0 +1,57 @@
+/*
+ * File: error.h
+ * Description: Error code base of modules
+ */
+/*
+ *@defgroup ErrorCode Error Code Definition
+ */
+
+/**
+ *@file error.h
+ *@brief TBirdOS 2.0 module error code definition.
+ *Error code definition:
+ *Bits 31~20: Module id
+ *Bits 19~12: Reserved
+ *Bits 11~0: Error code defined in each module
+ *@author Gene Hung
+ *@version 2005/08/22; Gene; Add Doxygen remark
+ *@see ModuleID
+ *@ingroup ErrorCode Error Code Definition
+ */
+
+/**
+ *@defgroup SysCtrlErr System Control Module Error Code
+ *@ingroup ErrorCode
+ */
+
+/**
+ *@defgroup SysMgrErr System Manager Module Error Code
+ *@ingroup ErrorCode
+ */
+
+#ifndef _ERROR_H_
+#define _ERROR_H_
+
+#ifndef _MODULEID_H_
+#include "moduleid.h"
+#endif
+/**
+ *@ingroup ErrorCode
+ *@{
+ */
+#define ERR_MODULEID_SHIFTBITS 20
+#define ERR_MODULEID(ErrorCode) ((ErrorCode) >> ERR_MODULEID_SHIFTBITS)
+#define ERR_BASE(ModuleId) ((ModuleId) << ERR_MODULEID_SHIFTBITS)
+
+/* No error*/
+#define ERR_SUCCESS 0
+
+/* The following constants define the module ID and the error code base*/
+
+#define ERR_BASE_PROJECT ERR_BASE(MODULEID_PROJECT)
+
+/**
+ *@}
+ */
+#endif /*_ERROR_H_*/
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/error/altek_state_err.h b/drivers/media/platform/msm/camera/al6100/include/error/altek_state_err.h
new file mode 100644
index 0000000..1fb3bd1
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/error/altek_state_err.h
@@ -0,0 +1,18 @@
+/*
+ * File: altek_state_err.h
+ * Description: miniISPISP error definition
+ */
+
+
+/******Include File******/
+
+#include "../error_pj.h"
+
+/******Public Define******/
+
+#define   ERR_MINIISP_STATE_REDUNDANT_SEQUENCE \
+		(ERR_BASE_PJ_MINIISP_STATE + 0x000)
+#define   ERR_MINIISP_STATE_ERROR_SEQUENCE \
+		(ERR_BASE_PJ_MINIISP_STATE + 0x001)
+
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/error/ispctrl_if_master_err.h b/drivers/media/platform/msm/camera/al6100/include/error/ispctrl_if_master_err.h
new file mode 100644
index 0000000..8197f9a
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/error/ispctrl_if_master_err.h
@@ -0,0 +1,38 @@
+/**
+ * File: ispctrl_if_master_err.h
+ * Description: ISP Ctrl IF Master error definition
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+#ifndef	_ISPCTRLIFMASTER_ERR_H_
+#define	_ISPCTRLIFMASTER_ERR_H_
+
+/******Include File******/
+
+
+#include "../error_pj.h"
+
+
+/******Public Define******/
+/* command Size mismatch*/
+#define ERR_MASTERCMDSIZE_MISMATCH (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x000)
+/* null buffer*/
+#define ERR_MASTERCMDBUF_NULL (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x001)
+/* command options unsupport*/
+#define ERR_MASTERCMDOPTION_UNSUPPORT (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x002)
+/* open file error*/
+#define ERR_MASTERCMDCKSM_INVALID (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x003)
+/* open file error*/
+#define ERR_MASTEROPENFILE_FAILED (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x004)
+/* open file error*/
+#define ERR_MASTEROPENFILE_FILENAME_INVALID (ERR_BASE_PJ_ISPCTRLIF_MASTER+\
+						0x005)
+/* event timeout*/
+#define ERR_MASTER_EVENT_TIMEOUT (ERR_BASE_PJ_ISPCTRLIF_MASTER + 0x006)
+
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/include/error/miniisp_err.h b/drivers/media/platform/msm/camera/al6100/include/error/miniisp_err.h
new file mode 100644
index 0000000..d7890eb
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/error/miniisp_err.h
@@ -0,0 +1,17 @@
+/*
+ * File: miniisp_err.h
+ * Description: miniISPISP error definition
+ */
+
+
+/******Include File******/
+
+#include "../error_pj.h"
+
+/******Public Define******/
+
+#define   ERR_MINIISP_BUFFERSIZE_OVERFLOW	   (ERR_BASE_PJ_MINIISP + 0x000)
+#define   ERR_MINIISP_REQUESTFIRMWARE_FAILED	(ERR_BASE_PJ_MINIISP + 0x001)
+#define   ERR_MINIISP_GETDATA_TIMEOUT		   (ERR_BASE_PJ_MINIISP + 0x002)
+
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/error_pj.h b/drivers/media/platform/msm/camera/al6100/include/error_pj.h
new file mode 100644
index 0000000..8db5a52
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/error_pj.h
@@ -0,0 +1,24 @@
+/*
+ * File: error_pj.h
+ * Description: Error code base of modules
+ */
+#ifndef _ERROR_PJ_H_
+#define _ERROR_PJ_H_
+
+#include "error.h"
+#include "moduleid_pj.h"
+
+/**
+ *@ingroup ErrorCode
+ *@{
+ */
+
+/* The following constants define the module ID and the error code base*/
+#define ERR_BASE_PJ_MINIISP_STATE	   ERR_BASE(MODULEID_PJ_MINIISP_STATE)
+#define ERR_BASE_PJ_ISPCTRLIF_SLAVE	 ERR_BASE(MODULEID_PJ_ISPCTRLIF_SLAVE)
+#define ERR_BASE_PJ_ISPCTRLIF_MASTER	ERR_BASE(MODULEID_PJ_ISPCTRLIF_MASTER)
+#define ERR_BASE_PJ_MINIISP			 ERR_BASE(MODULEID_PJ_MINIISP)
+
+
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/include/isp_camera_cmd.h b/drivers/media/platform/msm/camera/al6100/include/isp_camera_cmd.h
new file mode 100644
index 0000000..dfec9f6
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/isp_camera_cmd.h
@@ -0,0 +1,449 @@
+/*
+ * File: isp_camera_cmd.h
+ * Description: The structure and API definition ISP camera command
+ *  It is a header file that define structure and API for ISP camera command
+ * (C)Copyright Altek Digital Inc. 2013
+ *
+ * History
+ *   2013/09/18; Aaron Chuang; Initial version
+ *   2013/12/05; Bruce Chung; 2nd version
+ */
+
+
+#ifndef _ISPCAMERA_CMD_H_
+#define _ISPCAMERA_CMD_H_
+
+/*
+ *@addtogroup ISPCameraCmd
+ *@{
+ */
+
+/******Include File******/
+
+
+#include "mtype.h"
+
+
+/******Public Constant Definition******/
+
+#define T_MEMSIZE (936*1024)
+#define T_SPI_CMD_LENGTH 64
+
+#define ISPCMD_DUMMYBYTES 4
+#define FWVER_INFOSIZE_MAX 34
+
+#define ISPCMD_LENFLDBYTES 2
+#define ISPCMD_OPCODEBYTES 2
+#define ReportRegCount 27
+#define ISPCMD_CKSUMBYTES  2
+
+/*length field size = 2, opcode field size = 2 */
+#define ISPCMD_CMDSIZE ((ISPCMD_LENFLDBYTES) + (ISPCMD_OPCODEBYTES))
+
+/*length field size = 2, opcode field size = 2, dummy bytes = 4*/
+#define ISPCMD_CMDSIZEWDUMMY (ISPCMD_LENFLDBYTES+\
+				ISPCMD_OPCODEBYTES+\
+				ISPCMD_DUMMYBYTES)
+
+#define ISPCMD_FILENAME_SIZE 15
+
+#define ISPCMD_EXEBIN_ADDRBYTES 4
+#define ISPCMD_EXEBIN_TOTALSIZEBYTES 4
+#define ISPCMD_EXEBIN_BLOCKSIZEBYTES 4
+#define ISPCMD_EXEBIN_CKSUMBYTES 4
+#define ISPCMD_EXEBIN_INFOBYTES (ISPCMD_EXEBIN_ADDRBYTES+\
+				ISPCMD_EXEBIN_TOTALSIZEBYTES+\
+				ISPCMD_EXEBIN_BLOCKSIZEBYTES+\
+				ISPCMD_EXEBIN_CKSUMBYTES)
+
+/* Definition for Error code array number*/
+#define MAX_RECERRORCODE_NUM 10
+
+/*log buffer size*/
+#define	LEVEL_LOG_BUFFER_SIZE (1024*4)
+
+
+
+/*calibration profile*/
+#define ISPCMD_CAMERA_SET_SENSORMODE 0x300A
+#define ISPCMD_CAMERA_GET_SENSORMODE 0x300B
+#define ISPCMD_CAMERA_SET_OUTPUTFORMAT 0x300D
+#define ISPCMD_CAMERA_SET_CP_MODE 0x300E
+#define ISPCMD_CAMERA_SET_AE_STATISTICS 0x300F
+#define ISPCMD_CAMERA_PREVIEWSTREAMONOFF 0x3010
+#define ISPCMD_CAMERA_DUALPDYCALCULATIONWEIGHT 0x3011
+#define ISPCMD_LED_POWERCONTROL 0x3012
+#define ISPCMD_CAMERA_ACTIVE_AE 0x3013
+#define ISPCMD_ISP_AECONTROLONOFF 0x3014
+#define ISPCMD_CAMERA_SET_FRAMERATELIMITS 0x3015
+#define ISPCMD_CAMERA_SET_PERIODDROPFRAME 0x3016
+#define ISPCMD_CAMERA_SET_MAX_EXPOSURE 0x3017
+#define ISPCMD_CAMERA_SET_AE_TARGET_MEAN 0x3018
+
+/* Bulk Data*/
+#define ISPCMD_BULK_WRITE_BASICCODE 0x2002
+#define ISPCMD_BULK_WRITE_BOOTCODE 0x2008
+#define ISPCMD_BULK_READ_MEMORY 0x2101
+#define ISPCMD_BULK_READ_COMLOG 0x2102
+#define ISPCMD_BULK_WRITE_CALIBRATION_DATA 0x210B
+
+/*basic setting*/
+#define ISPCMD_BASIC_SET_DEPTH_3A_INFO 0x10B9
+#define ISPCMD_BASIC_SET_DEPTH_AUTO_INTERLEAVE_MODE 0x10BC
+#define ISPCMD_BASIC_SET_INTERLEAVE_MODE_DEPTH_TYPE 0x10BD
+#define ISPCMD_BASIC_SET_DEPTH_POLISH_LEVEL 0x10BE
+/*system cmd*/
+#define ISPCMD_SYSTEM_GET_STATUSOFLASTEXECUTEDCOMMAND 0x0015
+#define ISPCMD_SYSTEM_GET_ERRORCODE 0x0016
+#define ISPCMD_SYSTEM_SET_ISPREGISTER 0x0100
+#define ISPCMD_SYSTEM_GET_ISPREGISTER 0x0101
+/*#define ISPCMD_SYSTEM_SET_DEBUGCMD 0x0104*/
+#define ISPCMD_SYSTEM_SET_COMLOGLEVEL 0x0109
+#define ISPCMD_SYSTEM_GET_CHIPTESTREPORT 0x010A
+
+/*operarion code*/
+#define ISPCMD_MINIISPOPEN 0x4000
+
+/* constants for memory dump mode*/
+#define T_MEMDUMP_CPURUN 0
+#define T_MEMDUMP_CPUHALT 1
+
+/******Public Type Declaration******/
+/*mode id*/
+/*define for ISP decide mode*/
+enum mini_isp_mode {
+	MINI_ISP_MODE_NORMAL = 0x0000,
+	MINI_ISP_MODE_E2A = 0x0001,
+	MINI_ISP_MODE_A2E = 0x0002,
+	MINI_ISP_MODE_LEAVE_BYPASS = 0x0003,
+	MINI_ISP_MODE_GET_CHIP_ID = 0x0004,
+	MINI_ISP_MODE_SET_CP_MODE = 0x0005,
+	MINI_ISP_MODE_LEAVE_CP_MODE = 0x0006,
+	MINI_ISP_MODE_CHIP_INIT = 0x0007,
+	MINI_ISP_MODE_BYPASS = 0x1000,
+	MINI_ISP_MODE_QUARTER_BYPASS = 0x1001,
+};
+
+#pragma pack(1)
+struct transferdata {
+	u16 opcode;
+	void *data;
+};
+
+/*camera profile cmd use structure*/
+/**
+ *@struct isp_cmd_set_sensor_mode(opcode:300A)
+ *@brief ISP master cmd for set sensor mode
+ */
+#pragma pack(1)
+struct isp_cmd_set_sensor_mode {
+	u8 sensor_on_off;
+	u8 scenario_id;
+	u8 mipi_tx_skew;
+	u8 ae_weighting_table_index;
+	u8 merge_mode_enable;        //0: disable,1: enable
+	u8 reserve[2];
+};
+
+/**
+ *@struct isp_cmd_get_sensor_mode(opcode:300B)
+ *@brief ISP master cmd for get sensor mode
+ */
+#pragma pack(1)
+struct isp_cmd_get_sensor_mode {
+	bool on; /* On/off flag*/
+	u8 scenario_id; /* scenario mode*/
+	u8 reserve[4];
+};
+
+/**
+ *@struct isp_cmd_set_output_format(opcode:300D)
+ *@brief ISP master cmd for set depth output format
+ */
+#pragma pack(1)
+struct isp_cmd_set_output_format {
+	u8 depth_size;
+	u8 reserve[2];
+};
+
+/**
+ *@struct isp_cmd_ae_statistics(opcode:300F)
+ *@brief ae statistics
+ */
+#pragma pack(1)
+struct isp_cmd_ae_statistics {
+	u16 gr_channel_weight;
+	u16 gb_channel_weight;
+	u16 r_channel_weight;
+	u16 b_channel_weight;
+	u8 shift_bits;
+};
+
+/**
+ *@struct isp_cmd_preview_stream_on_off(opcode:3010)
+ *@briefISP master cmd for control tx stream on or off
+ */
+#pragma pack(1)
+struct isp_cmd_preview_stream_on_off {
+	u8 tx0_stream_on_off;
+	u8 tx1_stream_on_off;
+	u8 reserve;
+};
+
+/**
+ *@struct isp_cmd_dual_pd_y_calculation_weightings(opcode:3011)
+ *@briefISP master cmd for control dual pd y calculation weightings
+ */
+#pragma pack(1)
+struct isp_cmd_dual_pd_y_calculation_weightings {
+	u8 y_weight_gr_short;
+	u8 y_weight_gr_long;
+	u8 y_weight_r_short;
+	u8 y_weight_r_long;
+	u8 y_weight_b_short;
+	u8 y_weight_b_long;
+	u8 y_weight_gb_short;
+	u8 y_weight_gb_long;
+	u8 y_sum_right_shift;
+};
+
+/**
+ *@struct isp_cmd_led_power_control(opcode:3012)
+ *@briefISP master cmd for control led power
+ */
+#pragma pack(1)
+struct isp_cmd_led_power_control {
+	u8 led_on_off;                   //0: off   1: always on   2: AP control pulse mode  3: AHCC control pulse mode
+	u8 led_power_level;              //0~255
+	u8 control_projector_id;         //0: projector   1:illuminator
+	u32 delay_after_sof;             //when led_on_off = 2, use this param to set delay time between SOF and start pulse time
+	u32 pulse_time;                  //when led_on_off = 2, use this param to set pulse time
+	u8  control_mode;                //when led_on_off = 2, use this param to decide if pulse time met next SOF need triggler imediately or not
+	u8  pulse_mode_skip_frame;       //when led_on_off = 3, use this param to control if one frame pulse, how many followed frames need skeep pulse
+	u8 rolling_shutter;              //when led_on_off = 3, use this param to let projector/illuminator konw hoe exposure deal
+};
+
+/**
+ *@struct isp_cmd_active_ae(opcode:3013)
+ *@briefISP master cmd for avtive AE
+ */
+#pragma pack(1)
+struct isp_cmd_active_ae {
+	u8 active_ae;
+	u16 f_number_x1000;
+};
+
+/**
+ *@struct isp_cmd_isp_ae_control_on_off(opcode:3014)
+ *@briefISP master cmd for isp AE control on off
+ */
+#pragma pack(1)
+struct isp_cmd_isp_ae_control_on_off {
+	u8 isp_ae_control_mode_on_off;
+};
+
+
+/**
+ *@struct isp_cmd_frame_rate_limits(opcode:3015)
+ *@brief set frame rate limits
+ */
+#pragma pack(1)
+struct isp_cmd_frame_rate_limits {
+	u16 main_min_framerate_x100;
+	u16 main_max_framerate_x100;
+	u16 sub_min_framerate_x100;
+	u16 sub_max_framerate_x100;
+};
+
+/**
+ *@struct isp_cmd_period_drop_frame(opcode:3016)
+ *@brief set period drop frame
+ */
+#pragma pack(1)
+struct isp_cmd_period_drop_frame {
+	u8 period_drop_type;//0: no drop, 1: drop active, 2; drop passive
+};
+
+/**
+ *@struct isp_cmd_max_exporsure(opcode:3017)
+ *@brief set max exporsure
+ */
+#pragma pack(1)
+struct isp_cmd_max_exposure {
+	u32 max_exporsure;//us
+};
+
+/**
+ *@struct isp_cmd_target_mean(opcode:3018)
+ *@brief set target mean
+ */
+#pragma pack(1)
+struct isp_cmd_target_mean {
+	u16 target_mean;//0~255
+};
+
+
+/*basic cmd use structure*/
+
+/**
+ *@struct isp_cmd_depth_3a_info(opcode:10B9)
+ *@brief depth 3A information
+ */
+#pragma pack(1)
+struct isp_cmd_depth_3a_info {
+	u16 hdr_ratio;
+	u32 main_cam_exp_time;
+	u16 main_cam_exp_gain;
+	u16 main_cam_amb_r_gain;
+	u16 main_cam_amb_g_gain;
+	u16 main_cam_amb_b_gain;
+	u16 main_cam_iso;
+	u16 main_cam_bv;
+	s16 main_cam_vcm_position;
+	u8  main_cam_vcm_status;
+	u32 sub_cam_exp_time;
+	u16 sub_cam_exp_gain;
+	u16 sub_cam_amb_r_gain;
+	u16 sub_cam_amb_g_gain;
+	u16 sub_cam_amb_b_gain;
+	u16 sub_cam_iso;
+	u16 sub_cam_bv;
+	s16 sub_cam_vcm_position;
+	u8  sub_cam_vcm_status;
+	u16 main_cam_isp_d_gain;
+	u16 sub_cam_isp_d_gain;
+	s16 hdr_long_exp_ev_x1000;
+	s16 hdr_short_exp_ev_x1000;
+	u16 ghost_prevent_low;
+	u16 ghost_prevent_high;
+	u8 depth_dp_active;
+};
+
+/**
+ *@struct isp_cmd_depth_auto_interleave_param(opcode:10BC)
+ *@brief depth Interleave mode param
+ */
+#pragma pack(1)
+struct isp_cmd_depth_auto_interleave_param {
+	u8 depth_interleave_mode_on_off;/*1: on, 0: off*/
+	u8 skip_frame_num_after_illuminator_pulse;
+	u8 projector_power_level;/*0~255*/
+	u8 illuminator_power_level;/*0~255*/
+};
+
+/**
+ *@struct isp_cmd_interleave_mode_depth_type(opcode:10BD)
+ *@brief interleave mode projector with depth type
+ */
+#pragma pack(1)
+struct isp_cmd_interleave_mode_depth_type {
+	u8 projector_interleave_mode_with_depth_type;/*1: passive, 0: active, default active*/
+};
+
+/**
+ *@struct isp_cmd_depth_polish_level(opcode:10BE)
+ *@brief set depth polish level
+ */
+#pragma pack(1)
+struct isp_cmd_depth_polish_level {
+	u8 depth_polish_level;/*0~100*/
+};
+/*system cmd use structure*/
+
+/* ISP operation mode*/
+enum ispctrl_operation_mode {
+	ISPCTRL_TEST_MODE,
+	ISPCTRL_STILLLV_MODE,
+	ISPCTRL_VIDEOLV_MODE,
+	ISPCTRL_CONCURRENT_MODE,
+	ISPCTRL_BYPASS_MODE,
+	ISPCTRL_POWERDOWN_MODE
+};
+
+/**
+ *@struct system_cmd_isp_mode(opcode:0010 and 0011)
+ *@brief depth 3A information
+ */
+#pragma pack(1)
+struct system_cmd_isp_mode {
+	u8 isp_mode;  /*ispctrl_operation_mode*/
+};
+
+/**
+ *@struct system_cmd_status_of_last_command(opcode:0015)
+ *@brief last execution command status
+ */
+#pragma pack(1)
+struct system_cmd_status_of_last_command {
+	u16 opcode;
+	u32 execution_status;
+};
+
+/**
+ *@struct system_cmd_isp_register(opcode:0100 and 0101)
+ *@brief use on set/get isp register
+ */
+#pragma pack(1)
+struct system_cmd_isp_register {
+	u32 address;
+	u32 value;
+};
+
+/**
+ *@struct system_cmd_debug_mode(opcode:0104)
+ *@brief use on get irq status
+ */
+#pragma pack(1)
+struct system_cmd_debug_mode {
+	u8 on;
+};
+
+/**
+ *@struct system_cmd_common_log_level(opcode:0109)
+ *@brief use on set common log level
+ */
+#pragma pack(1)
+struct system_cmd_common_log_level {
+	u32 log_level;
+};
+
+
+
+/*bulk cmd use structure*/
+
+/**
+ *@struct memmory_dump_hdr_info
+ *@brief use on isp memory read
+ */
+#pragma pack(1)
+struct memmory_dump_hdr_info {
+	u32 start_addr;
+	u32 total_size;
+	u32 block_size;
+	u32 dump_mode;
+};
+
+
+/**
+ *@struct common_log_hdr_info
+ *@brief Bulk data for memory dump header
+ */
+#pragma pack(1)
+struct common_log_hdr_info {
+	u32 total_size;
+	u32 block_size;
+};
+
+
+
+
+/******Public Function Prototype******/
+
+
+/******End of File******/
+
+/**
+ *@}
+ */
+
+#endif /* _ISPCAMERA_CMD_H_*/
diff --git a/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master.h b/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master.h
new file mode 100644
index 0000000..25cb5dc
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master.h
@@ -0,0 +1,153 @@
+/*
+ * File: ispctrl_if_master.h
+ * Description: The structure and API definition ISP Ctrl IF Master
+ *It,s a header file that define structure and API for ISP Ctrl IF Master
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/09/18; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/**
+ * \file	 ispctrl_if_master.h
+ * \brief	ISP Ctrl IF Master and API define
+ * \version  0.01
+ * \author   Aaron Chuang
+ * \date	 2013/09/17
+ * \see	  ispctrl_if_master.h
+ */
+
+#ifndef _ISPCTRLIF_MASTER_H_
+#define _ISPCTRLIF_MASTER_H_
+
+/**
+ *@addtogroup ispctrl_if_master
+ *@{
+ */
+
+/******Include File******/
+#include <linux/interrupt.h>
+
+#include "mtype.h"
+#include "moduleid_pj.h"
+#include "miniisp.h"
+
+/******Public Constant Definition******/
+
+enum firmware_type {
+	BOOT_CODE,
+	BASIC_CODE,
+	ADVANCED_CODE,
+	SCENARIO_CODE,
+	HDR_CODE,
+	IRP0_CODE,
+	IRP1_CODE,
+	PPMAP_CODE,
+	FIRMWARE_MAX
+};
+
+extern int g_isMiniISP_sendboot;
+
+
+
+/******Public Type Declaration******/
+
+
+/******Public Function Prototype******/
+
+
+/**
+ *\brief Execute master command
+ *\param opcode [In], Op code
+ *\param param  [In], CMD param buffer
+ *\return Error code
+ */
+extern errcode ispctrl_if_mast_execute_cmd(u16 opcode, u8 *param);
+
+/**
+ *\brief Send command to slave
+ *\param devdata [In], misp_data
+ *\param opcode  [In], Op code
+ *\param param   [In], CMD param buffer
+ *\param len	 [In], CMD param size
+ *\return Error code
+ */
+errcode ispctrl_mast_send_cmd_to_slave(void *devdata,
+						u16 opcode,
+						u8 *param,
+						u32 len);
+
+/**
+ *\brief Receive response from slave
+ *\param devdata [In], misp_data
+ *\param param   [Out], Response buffer
+ *\param len	 [Out], Response size
+ *\return Error code
+ */
+errcode ispctrl_mast_recv_response_from_slave(void *devdata,
+							u8 *param,
+							u32 len,
+							bool wait_int);
+
+/**
+ *\brief Receive Memory data from slave
+ *\param devdata [In], misp_data
+ *\param response_buf [Out], Response buffer
+ *\param response_size [Out], Response size
+ *\param wait_int [In], waiting INT flag
+ *\return Error code
+ */
+errcode ispctrl_if_mast_recv_memory_data_from_slave(
+							void *devdata,
+							u8 *response_buf,
+							u32 *response_size,
+							bool wait_int);
+
+/** \brief  Master send bulk (large data) to slave
+ *\param devdata [In], misp_data
+ *\param buffer  [In], Data buffer to be sent, address 8-byte alignment
+ *\param filp	[In], file pointer, used to read the file and send the data
+ *\param total_size [In], file size
+ *\param block_size  [In], transfer buffer block size
+ *\param is_raw   [In], true: mini boot code  false: other files
+ *\return Error code
+ */
+errcode ispctrl_if_mast_send_bulk(void *devdata, u8 *buffer,
+					struct file *filp, u32 total_size,
+					u32 block_size, bool is_raw);
+
+/** \brief  Master open the firmware
+ *\param filename [In], file name of the firmware
+ *\param firmwaretype [In], firmware type
+ *\return Error code
+ */
+errcode ispctrl_if_mast_request_firmware(u8 *filename, u8 a_firmwaretype);
+
+/** \brief  Master get SPI status bytes
+ *\param  n/a
+ *\return status bytes(2 bytes)
+ */
+u16 ispctrl_if_mast_read_spi_status(void);
+
+/**
+ *\brief Receive ISP register response from slave
+ *\param devdata [In] misp_data
+ *\param response_buf [Out], Response buffer
+ *\param response_size [Out], Response size
+ *\param total_count [In], Total reg count
+ *\return Error code
+ */
+errcode ispctrl_if_mast_recv_isp_register_response_from_slave(
+						void *devdata,
+						u8 *response_buf,
+						u32 *response_size,
+						u32 total_count);
+
+
+/****** End of File******/
+
+/**
+ *@}
+ */
+
+#endif /* _ISPCTRLIF_MASTER_H_*/
diff --git a/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master_local.h b/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master_local.h
new file mode 100644
index 0000000..181b2e6
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/ispctrl_if_master_local.h
@@ -0,0 +1,395 @@
+/*
+ * File: ispctrl_if_master_local.h
+ * Description: The structure and API definition ISP Ctrl IF Master Local
+ *It,s a header file that define structure and API for ISP Ctrl IF Master Local
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+
+/**
+ * \file	 ispctrl_if_master_local.h
+ * \brief	ISP Ctrl IF Master Local and API define
+ * \version  0.01
+ * \author   Aaron Chuang
+ * \date	 2013/09/23
+ * \see	  ispctrl_if_master_local.h
+ */
+
+#ifndef _ISPCTRLIF_MASTER_LOCAL_H_
+#define _ISPCTRLIF_MASTER_LOCAL_H_
+
+/**
+ *@addtogroup ispctrl_if_master_local
+ *@{
+ */
+
+
+/******Include File******/
+
+#include "mtype.h"
+#include "miniisp.h"
+
+
+/******Public Constant Definition******/
+#define ISP_REGISTER_PARA_SIZE  8
+#define ISP_REGISTER_VALUE  4
+
+
+/******Public Function Prototype******/
+
+/*********************** System manage command ***********************/
+/**
+ *\brief Get status of last executed command
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_status_of_last_exec_command(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/**
+ *\brief Get error code CMD
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_error_code_command(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Set ISP register
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_set_isp_register(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Get ISP register
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_isp_register(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Set common log level
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_set_comomn_log_level(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Get chip test report
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_chip_test_report(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+void isp_mast_camera_profile_para_init(void);
+
+/*********************** Camera profile command ***********************/
+/**
+ *\brief Set Sensor Mode
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_sensor_mode(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Get Sensor Mode
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_get_sensor_mode(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/**
+ *\brief Set Output Format
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_output_format(void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/*
+ *\brief Set CP Mode
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_cp_mode(void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief Set AE statistics
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_ae_statistics(void *devdata,
+							u16 opcode, u8 *param);
+
+/**
+ *\brief Preview stream on
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_preview_stream_on_off(
+								void *devdata,
+								u16 opcode,
+								u8 *param);
+
+/*
+ *\brief dual PD Y calculation weightings
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_dual_pd_y_cauculation_weightings(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+
+/*
+ *\brief led power control
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_led_power_control(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+
+/*
+ *\brief Active AE
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_active_ae(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief ISP AE control on off
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_isp_ae_control_on_off(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief Set Frame Rate Limits
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_frame_rate_limits(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief Set Period Drop Frame
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_period_drop_frame(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief Set max exposure
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_max_exposure(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/*
+ *\brief Set target mean
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_camera_profile_cmd_set_target_mean(
+						void *devdata,
+						u16 opcode, u8 *param);
+
+/* Bulk data command*/
+
+/**
+ *\brief Write Boot Code
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\param filp [In], boot file
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_boot_code(void *devdata,
+								u8 *param,
+							struct file *filp);
+
+
+/**
+ *\brief Write Basic Code
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\param filp [In], basic file
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_basic_code(void *devdata,
+								u8 *param,
+							struct file *filp);
+
+/**
+ *\brief Write Calibration Data
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\param filp [In], sc table file
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_calibration_data(void *devdata,
+								u8 *param,
+							struct file *filp);
+
+/**
+ *\brief Write Qmerge Data
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\param filp [In], sc table file
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_write_qmerge_data(void *devdata,
+								u8 *param,
+							struct file *filp);
+
+/**
+ *\brief Read Calibration Data
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_bulk_data_cmd_read_memory_data(void *devdata,
+							u8 *param);
+
+/**
+ *\brief Read common log data
+ *\param devdata [In], misp device data
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode bulk_data_cmd_read_common_log(void *devdata,
+							u8 *param);
+
+/*********************** Basic setting command ************************/
+/**
+ *\brief Set Depth 3A Info
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_3a_info(void *devdata,
+						u16 opcode,
+						u8 *param);
+
+
+/*
+ *\brief Set Depth auto interleave mode
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_auto_interleave_mode(
+	void *devdata, u16 opcode, u8 *param);
+
+
+/*
+ *\brief Set projector interleave mode with depth type
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_interleave_mode_depth_type(
+	void *devdata, u16 opcode, u8 *param);
+
+/*
+ *\brief Set depth polish level
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_basic_setting_cmd_set_depth_polish_level(
+	void *devdata, u16 opcode, u8 *param);
+/*********************** operation command ***********************/
+/**
+ *\brief Mini ISP open
+ *\param devdata [In], misp device data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_operation_cmd_miniisp_open(void *devdata,
+						u16 opcode, u8 *param);
+
+
+/****************************** End of File *********************************/
+
+/**
+ *@}
+ */
+
+#endif /* _ISPCTRLIF_MASTER_LOCAL_H_*/
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp.h b/drivers/media/platform/msm/camera/al6100/include/miniisp.h
new file mode 100644
index 0000000..6903700
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp.h
@@ -0,0 +1,245 @@
+/*
+ * File: miniisp.h
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/11/01; Bruce Chung; Initial version
+ *  2017/03/30; LouisWang; 2rd version
+ */
+
+#ifndef _MINI_ISP_H_
+#define _MINI_ISP_H_
+
+/******Include File******/
+#include <linux/mutex.h>
+#include <linux/semaphore.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+
+#include "mtype.h"
+/******Public Constant Definition******/
+
+#define MINIISP_DRIVER_VERSION "v1.11"
+//#define AL6100_SPI_NOR
+
+//SPI_E_AND_I2C_SLAVE_RELATED
+#define CTRL_BYTE_REGRD 0x19
+#define CTRL_BYTE_REGWR 0x09
+#define CTRL_BYTE_MEMRD 0x15
+#define CTRL_BYTE_MEMWR 0x05
+#define EMODE_TXCMD_LEN (5)  //1byte ctrl byte + 4 bytes address
+
+//SPI_A_MODE_RELATED
+#define CTRL_BYTE_A2E 0x20
+#define SPI_TX_BULK_SIZE (64 * 1024)
+#define SPI_TX_BULK_SIZE_BOOT (8 * 1024)
+#define SPI_RX_DUMMY_LEN (16) //for spi waiting 0xa5
+
+//I2C_TOP_RELATED
+//#define I2C_BULK_SIZE (4 * 1024) // AQ360 can work
+#define I2C_TX_BULK_SIZE (1024)  //AL6100 can work
+#define I2C_RX_DUMMY_LEN (0)
+
+#define TX_BUF_SIZE	64
+#define RX_BUF_SIZE	64
+
+#define MINIISP_I2C_SLAVE 0
+#define MINIISP_I2C_TOP 1
+
+#define INTF_SPI_READY (1 << 0)
+#define INTF_I2C_READY (1 << 1)
+#define INTF_CCI_READY (1 << 2)
+
+#define DEBUG_ALERT 1
+#define DEBUG_TURNON 1
+
+/*#define ALTEK_TEST*/
+
+#ifdef DEBUG_TURNON
+
+	#ifdef DEBUG_ALERT
+	#define misp_info(fmt, ...) \
+			pr_err(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+
+	#define misp_warn(fmt, ...) \
+			pr_warn(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+
+	#define misp_err(fmt, ...) \
+			pr_err(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+	#else
+	#define misp_info(fmt, ...) \
+			pr_err(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+
+	#define misp_warn(fmt, ...) \
+			pr_debug(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+
+	#define misp_err(fmt, ...) \
+			pr_debug(MINI_ISP_LOG_TAG ": " fmt "\n",\
+				##__VA_ARGS__)
+	#endif
+
+#else
+	#define misp_info(fmt, ...)
+	#define misp_err(fmt, ...)
+	#define misp_warn(fmt, ...)
+
+#endif
+
+/*ALTEK SPI MODE*/
+/*define Altek SPI mode*/
+enum ALTEK_SPI_MODE {
+	ALTEK_SPI_MODE_E = 0,
+	ALTEK_SPI_MODE_A,
+};
+
+/*
+ *@typedef USPICTRL_MS_CB_ID
+ *@brief USPI control byte definition (for master control)
+ */
+enum {
+	/*!< Ctrl-Byte, original command */
+	USPICTRL_MS_CB_ORG				  = (0x00<<6),
+	/*!< Ctrl-Byte, polling status */
+	USPICTRL_MS_CB_STS				  = (0x01<<6),
+	/*!< Ctrl-Byte, get response */
+	USPICTRL_MS_CB_RSP				  = (0x02<<6),
+	/*!< Ctrl-Byte, disable Ctrl-Byte mode */
+	USPICTRL_MS_CB_DIS				  = (0x03<<6),
+};
+
+/*Event Bit define*/
+/*define ISP control Master event Bit*/
+enum MINI_ISP_EVENT {
+	MINI_ISP_RCV_WAITING  = 0, /* 0x00000000*/
+	MINI_ISP_RCV_CMD_READY = (1L << 0), /* 0x00000001*/
+	MINI_ISP_RCV_BULKDATA = (1L << 1), /* 0x00000002*/
+	MINI_ISP_RCV_CPCHANGE  = (1L << 2), /* 0x00000004*/
+	MINI_ISP_RCV_SETSENSORMODE = (1L << 3),/* 0x00000008*/
+	MINI_ISP_RCV_ERROR = (1L << 4),/* 0x00000010*/
+	MINI_ISP_RCV_ERROR2 = (1L << 5),/* 0x00000020*/
+	MINI_ISP_RCV_STRMOFF = (1L << 6),/* 0x00000040*/
+};
+
+/* Definition for IRQ status*/
+#define COMMAND_COMPLETE 0x0001/*cmd deal complete by altek chip*/
+#define BULK_DATA_COMPLETE 0x0002/*bulk data deal complete by altek chip*/
+#define CP_STATUS_CHANGE_DONE 0x0004/*code persistence mode change finish*/
+#define SET_SENSOR_MODE_READY 0x0008
+#define SYSTEM_ERROR_LEVEL1 0x0010/*(Get Report)*/
+#define SYSTEM_ERROR_LEVEL2 0x0020/*(Dump Register)*/
+#define STRMOFF_READY 0x0040/*default not use*/
+
+/******Public Type Declaration******/
+struct misp_intf_fn_t {
+	int (*send)(void *devdata, u32 len);
+	int (*recv)(void *devdata, u32 len, bool waitINT);
+	int (*read)(void *devdata, u8 *tx_buf, u32 tx_len, u8 *rx_buf, u32 rx_len);
+	int (*write)(void *devdata, u8 *tx_buf, u8 *rx_buf, u32 len);
+	int (*send_bulk)(void *devdata, struct file *filp, u32 total_size, u32 block_size, bool is_raw, u8 *Sendbulkbuffer);
+};
+
+struct misp_data {
+	union {
+		struct spi_device *spi;
+		struct i2c_client *i2c;
+		struct msm_camera_i2c_client *cci;
+	} __attribute__((packed)) cfg;
+
+	struct misp_intf_fn_t *intf_fn;
+	int bulk_cmd_blocksize;
+	u32 rx_dummy_len;
+	u8 tx_buf[TX_BUF_SIZE];
+	u8 rx_buf[RX_BUF_SIZE];
+};
+
+struct misp_global_variable {
+	int vcc1_gpio;
+	int vcc2_gpio;
+	int vcc3_gpio;
+	int irq_gpio;
+	int irq_num;
+	int reset_gpio;
+	int intf_status;
+	int before_booting;
+	int i2c_enable;
+	int altek_spi_mode;
+	int be_set_to_bypass;
+	int now_state;
+	int spi_low_speed_mode;
+	struct clk *isp_clk;
+	struct mutex busy_lock;
+};
+
+
+struct irp_and_depth_information {
+	u32 irp_image_address;
+	u32 irp_width;
+	u32 irp_height;
+	u8 irp_format;/*Y_only:0  YUV:1*/
+	u32 depth_image_address;
+	u32 depth_width;
+	u32 depth_height;
+	u8 fov_mode;
+} __attribute__ ((packed));
+
+/******Public Function Prototype******/
+extern irqreturn_t mini_isp_irq(int irq, void *handle);
+
+/*miniisp_spi.c*/
+extern struct misp_data *get_mini_isp_data(void);
+extern void set_mini_isp_data(struct misp_data *data, int intf_type);
+extern struct misp_data *get_mini_isp_intf(int i2c_type);
+extern struct misp_global_variable *get_mini_isp_global_variable(void);
+extern struct altek_statefsm *get_mini_isp_fsm(void);
+extern int mini_isp_get_bulk(struct misp_data *devdata, u8 *response_buf,
+					u32 total_size, u32 block_size);
+//extern u16 mini_isp_get_status(void); //currently not use
+
+/*miniisp_top.c*/
+extern void mini_isp_e_to_a(void);
+extern void mini_isp_a_to_e(void);
+extern void mini_isp_chip_init(void);
+extern void mini_isp_cp_mode_suspend_flow(void);
+extern void mini_isp_cp_mode_resume_flow(void);
+extern void mini_isp_check_and_leave_bypass_mode(void);
+extern int mini_isp_pure_bypass(u16 mini_isp_mode);
+extern void mini_isp_pure_bypass_debug(u16 mini_isp_mode);
+extern int mini_isp_get_chip_id(u32 mini_isp_reg_addr, u8 *id_buf);
+extern u32 mini_isp_register_read_then_write_file(u32 start_reg_addr,
+				u32 end_reg_addr, char *module_name);
+extern u32 mini_isp_register_read(u32 reg_addr, u32 *reg_value);
+extern errcode mini_isp_debug_dump(void);
+extern errcode mini_isp_memory_read_then_write_file(u32 start_addr, u32 len,
+	char *file_name);
+extern u32 mini_isp_memory_read(u32 start_addr, u8 *read_buffer, u32 len);
+extern int mini_isp_get_altek_status(void *devdata, u32 *altek_status);
+extern int mini_isp_wait_for_event(u32 MINI_ISP_EVENT);
+extern u32 mini_isp_get_currentevent(void);
+extern void mini_isp_register_write(u32 reg_addr, u32 reg_new_value);
+extern void mini_isp_memory_write(u32 memory_addr, u8 *write_buffer,
+				u32 write_len);
+extern int mini_isp_debug_dump_img(void);
+/*miniisp_utility.c*/
+extern errcode mini_isp_utility_read_reg_e_mode(void);
+extern errcode mini_isp_utility_read_reg_e_mode_for_bypass_use(void);
+extern errcode mini_isp_utility_get_irp_and_depth_information(
+	struct irp_and_depth_information *info);
+extern u32 mini_isp_check_rx_dummy(u8 **recv_buffer, u32 rx_dummy_len);
+
+/*miniisp_customer_define.c*/
+extern void mini_isp_poweron(void);
+extern void mini_isp_poweroff(void);
+extern int mini_isp_gpio_init(struct device *spi,
+			struct misp_data *drv_data,
+			struct misp_global_variable *drv_global_variable);
+#endif
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp_chip_base_define.h b/drivers/media/platform/msm/camera/al6100/include/miniisp_chip_base_define.h
new file mode 100644
index 0000000..8baa11d
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp_chip_base_define.h
@@ -0,0 +1,670 @@
+/*
+ * File: miniisp_chip_base_define.c.h
+ * Description: Mini ISP ChipBase Define Code
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/10/18; Louis Wang; Initial version
+ */
+
+/******Include File******/
+
+
+/******Public Constant Definition******/
+#define CHIP_ID_ADDR 0xffef0020
+
+#define INTERRUPT_STATUS_REGISTER_ADDR 0xffef00b4
+#define INTERRUPT_ENABLE_BIT_REGISTER_ADDR 0xffef00b0
+
+#define clk_gen_dump_field \
+{\
+0xFFE80040, 0xFFE8004C,\
+0xFFE80060, 0xFFE80064,\
+0xFFE80080, 0xFFE80084,\
+0xFFE800A0, 0xFFE800A4,\
+0xFFE800C0, 0xFFE800C4,\
+0xFFE800E0, 0xFFE800E4,\
+0xFFE80100, 0xFFE80104,\
+0xFFE80120, 0xFFE80124,\
+0xFFE80140, 0xFFE80144,\
+0xFFE80160, 0xFFE80164,\
+0xFFE80180, 0xFFE80184,\
+0xFFE801A0, 0xFFE801A8,\
+0xFFE801C8, 0xFFE801C8,\
+0xFFE80200, 0xFFE80204,\
+0xFFE80240, 0xFFE80244,\
+0xFFE80280, 0xFFE80284,\
+0xFFE80340, 0xFFE80344,\
+0xFFE80380, 0xFFE80384,\
+0xFFE80400, 0xFFE80404,\
+0xFFE80440, 0xFFE80444,\
+0xFFE80460, 0xFFE80464,\
+0xFFE80484, 0xFFE80484,\
+0xFFE804A4, 0xFFE804A4,\
+0xFFE804C4, 0xFFE804C4,\
+0xFFE804E4, 0xFFE804E4,\
+0xFFE80500, 0xFFE80504,\
+0xFFE80540, 0xFFE80548,\
+0xFFE80580, 0xFFE80588,\
+0xFFE805C0, 0xFFE805C8,\
+0xFFE80620, 0xFFE80630,\
+0xFFE80680, 0xFFE80684,\
+0xFFE806E0, 0xFFE806E4,\
+0xFFE80720, 0xFFE80724,\
+0xFFE807C0, 0xFFE807C4,\
+0xFFE80804, 0xFFE80804,\
+0xFFE80814, 0xFFE80814,\
+0xFFE80824, 0xFFE80824,\
+0xFFE80840, 0xFFE80844,\
+0xFFE80884, 0xFFE80884,\
+0xFFE80900, 0xFFE80904,\
+0xFFE80944, 0xFFE80944,\
+0xFFE80B00, 0xFFE80B04,\
+0xFFE80C00, 0xFFE80C04,\
+0xFFE80C40, 0xFFE80C44,\
+0xFFE81000, 0xFFE81004,\
+0xFFE81080, 0xFFE81080,\
+0xFFE81100, 0xFFE81114,\
+0xFFE81120, 0xFFE81134,\
+0xFFE81140, 0xFFE81154,\
+0xFFE81200, 0xFFE8122C,\
+0xFFE8F000, 0xFFE8F000,\
+}
+
+#define mipi_tx_phy_if_0_dump_field \
+{\
+0xFFED1000, 0xFFED1048,\
+0xFFED1100, 0xFFED1104,\
+}
+
+#define mipi_tx_phy_if_1_dump_field \
+{\
+0xFFED6000, 0xFFED6048,\
+0xFFED6100, 0xFFED6104,\
+}
+
+#define gen_reg_dump_field \
+{\
+0xffef0000, 0xffef0008,\
+0xffef0020,	0xffef0044,\
+0xffef0054,	0xffef005C,\
+0xffef0070,	0xffef00a8,\
+0xffef00b0,	0xffef00b4,\
+0xffef00f0,	0xffef00f8,\
+0xffef0100,	0xffef0100,\
+0xffef0208,	0xffef0208,\
+0xffef0240,	0xffef0240,\
+0xffef0248,	0xffef0248,\
+0xffef0250,	0xffef0258,\
+0xffef0280,	0xffef0284,\
+0xffef0410,	0xffef0414,\
+0xffef0500,	0xffef0500,\
+0xffef0f00,	0xffef0f00,\
+}
+
+#define mipi_slvds_rx_phy_if_0_dump_field \
+{\
+0xfff91000, 0xfff91008,\
+0xfff91010, 0xfff91040,\
+0xfff9104c,	0xfff9104c,\
+0xfff91068,	0xfff91078,\
+0xfff91084,	0xfff91084,\
+0xfff9108c,	0xfff9108c,\
+0xfff91094,	0xfff910c8,\
+0xfff91100,	0xfff9114c,\
+}
+
+#define mipi_slvds_rx_phy_if_1_dump_field \
+{\
+0xfff94000,	0xfff94008,\
+0xfff94010,	0xfff94040,\
+0xfff9404c,	0xfff9404c,\
+0xfff94068,	0xfff94078,\
+0xfff94084,	0xfff94084,\
+0xfff9408c,	0xfff9408c,\
+0xfff94094,	0xfff940c8,\
+0xfff94100,	0xfff9414c,\
+}
+
+#define ppi_bridge_a_0_dump_field \
+{\
+0xfff97000, 0xfff97040,\
+0xfff970a0, 0xfff970ac,\
+0xfff970f0,	0xfff970fc,\
+0xfff97110,	0xfff9716c,\
+0xfff972a0,	0xfff972a4,\
+0xfff97300,	0xfff97314,\
+}
+
+#define ppi_bridge_a_1_dump_field \
+{\
+0xfff98000,	0xfff98040,\
+0xfff980a0,	0xfff980ac,\
+0xfff980f0,	0xfff980fc,\
+0xfff98110,	0xfff9816c,\
+0xfff982a0,	0xfff982a4,\
+0xfff98300,	0xfff98314,\
+}
+
+#define ppi_bridge_a_1_dump_field \
+{\
+0xfff98000,	0xfff98040,\
+0xfff980a0,	0xfff980ac,\
+0xfff980f0,	0xfff980fc,\
+0xfff98110,	0xfff9816c,\
+0xfff982a0,	0xfff982a4,\
+0xfff98300,	0xfff98314,\
+}
+
+#define tx_top_out_mux_a_0_dump_field \
+{\
+0xffecb000,	0xffecb004,\
+0xffecb010,	0xffecb014,\
+0xffecb020,	0xffecb050,\
+0xffecb100,	0xffecb13c,\
+0xffecb200,	0xffecb220,\
+0xffecb300,	0xffecb32c,\
+0xffecbf00,	0xffecbf00,\
+}
+
+#define tx_top_out_mux_a_1_dump_field \
+{\
+0xffecc000,	0xffecc004,\
+0xffecc010,	0xffecc014,\
+0xffecc020,	0xffecc050,\
+0xffecc100, 0xffecc13c,\
+0xffecc200, 0xffecc220,\
+0xffecc300,	0xffecc32c,\
+0xffeccf00, 0xffeccf00,\
+}
+
+#define tx_line_merge_21_a_0_dump_field \
+{\
+0xffec1000,	0xffec1010,\
+0xffec1020,	0xffec1024,\
+0xffec1030,	0xffec1034,\
+0xffec1040,	0xffec1044,\
+0xffec104c,	0xffec105c,\
+0xffec1070,	0xffec1074,\
+0xffec108c,	0xffec108c,\
+0xffec1100,	0xffec1124,\
+0xffec1140,	0xffec1144,\
+0xffec1150,	0xffec1174,\
+0xffec1180,	0xffec1184,\
+0xffec1300,	0xffec1300,\
+0xffec1310,	0xffec1320,\
+0xffec1330,	0xffec135c,\
+0xffec1400,	0xffec1404,\
+0xffec1410,	0xffec145c,\
+0xffec1470,	0xffec1484,\
+0xffec1490,	0xffec14b0,\
+0xffec1a00,	0xffec1a00,\
+0xffec1a10,	0xffec1a34,\
+0xffec1a40,	0xffec1a84,\
+0xffec1a90,	0xffec1aac,\
+0xffec1ac0,	0xffec1ac4,\
+0xffec1ad0,	0xffec1adc,\
+0xffec1b00,	0xffec1b08,\
+0xffec1b10,	0xffec1b14,\
+0xffec1b20,	0xffec1b54,\
+0xffec1b68,	0xffec1b98,\
+0xffec1f00,	0xffec1f00,\
+}
+
+#define tx_line_merge_21_b_0_dump_field \
+{\
+0xffec2000,	0xffec2010,\
+0xffec2020,	0xffec2024,\
+0xffec2030,	0xffec2034,\
+0xffec2040,	0xffec2044,\
+0xffec204c,	0xffec205c,\
+0xffec2070,	0xffec2074,\
+0xffec208c,	0xffec208c,\
+0xffec2100,	0xffec2124,\
+0xffec2140,	0xffec2144,\
+0xffec2150,	0xffec2174,\
+0xffec2180,	0xffec2184,\
+0xffec2300,	0xffec2300,\
+0xffec2310,	0xffec2320,\
+0xffec2330,	0xffec235c,\
+0xffec2400,	0xffec2404,\
+0xffec2410,	0xffec245c,\
+0xffec2470,	0xffec2484,\
+0xffec2490,	0xffec24b0,\
+0xffec2a00,	0xffec2a00,\
+0xffec2a10,	0xffec2a34,\
+0xffec2a40,	0xffec2a84,\
+0xffec2a90,	0xffec2aac,\
+0xffec2ac0,	0xffec2ac4,\
+0xffec2ad0,	0xffec2adc,\
+0xffec2b00,	0xffec2b08,\
+0xffec2b10,	0xffec2b14,\
+0xffec2b20,	0xffec2b54,\
+0xffec2b68,	0xffec2b98,\
+0xffec2f00,	0xffec2f00,\
+}
+
+#define tx_line_merge_21_c_0_dump_field \
+{\
+0xffec5000,	0xffec5010,\
+0xffec5020,	0xffec5024,\
+0xffec5030,	0xffec5034,\
+0xffec5040,	0xffec5044,\
+0xffec504c,	0xffec505c,\
+0xffec5070,	0xffec5074,\
+0xffec508c,	0xffec508c,\
+0xffec5100,	0xffec5124,\
+0xffec5140,	0xffec5144,\
+0xffec5150,	0xffec5174,\
+0xffec5180,	0xffec5184,\
+0xffec5300,	0xffec5300,\
+0xffec5310,	0xffec5320,\
+0xffec5330,	0xffec535c,\
+0xffec5400,	0xffec5404,\
+0xffec5410,	0xffec545c,\
+0xffec5470,	0xffec5484,\
+0xffec5490,	0xffec54b0,\
+0xffec5a00,	0xffec5a00,\
+0xffec5a10,	0xffec5a34,\
+0xffec5a40,	0xffec5a84,\
+0xffec5a90,	0xffec5aac,\
+0xffec5ac0,	0xffec5ac4,\
+0xffec5ad0,	0xffec5adc,\
+0xffec5b00,	0xffec5b08,\
+0xffec5b10,	0xffec5b14,\
+0xffec5b20,	0xffec5b54,\
+0xffec5b68,	0xffec5b98,\
+0xffec5f00,	0xffec5f00,\
+}
+
+#define tx_line_merge_21_d_0_dump_field \
+{\
+0xffec6000,	0xffec6010,\
+0xffec6020,	0xffec6024,\
+0xffec6030,	0xffec6034,\
+0xffec6040,	0xffec6044,\
+0xffec604c,	0xffec605c,\
+0xffec6070,	0xffec6074,\
+0xffec608c,	0xffec608c,\
+0xffec6100,	0xffec6124,\
+0xffec6140,	0xffec6144,\
+0xffec6150,	0xffec6174,\
+0xffec6180,	0xffec6184,\
+0xffec6300,	0xffec6300,\
+0xffec6310,	0xffec6320,\
+0xffec6330,	0xffec635c,\
+0xffec6400,	0xffec6404,\
+0xffec6410,	0xffec645c,\
+0xffec6470,	0xffec6484,\
+0xffec6490,	0xffec64b0,\
+0xffec6a00,	0xffec6a00,\
+0xffec6a10,	0xffec6a34,\
+0xffec6a40,	0xffec6a84,\
+0xffec6a90,	0xffec6aac,\
+0xffec6ac0,	0xffec6ac4,\
+0xffec6ad0,	0xffec6adc,\
+0xffec6b00,	0xffec6b08,\
+0xffec6b10,	0xffec6b14,\
+0xffec6b20,	0xffec6b54,\
+0xffec6b68,	0xffec6b98,\
+0xffec6f00,	0xffec6f00,\
+}
+
+#define mipi_csi2_tx_0_dump_field \
+{\
+0xFFED0000,	0xFFED0008,\
+0xFFED0044,	0xFFED0044,\
+0xFFED0058,	0xFFED0068,\
+0xFFED0090,	0xFFED00AC,\
+0xFFED00BC,	0xFFED00C8,\
+0xFFED00D4,	0xFFED00EC,\
+0xFFED0100,	0xFFED0138,\
+0xFFED0300,	0xFFED0358,\
+0xFFED038C,	0xFFED038C,\
+0xFFED0360,	0xFFED03B4,\
+0xFFED03BC,	0xFFED03D0,\
+0xFFED0FF0,	0xFFED0FF0,\
+}
+
+#define mipi_csi2_tx_1_dump_field \
+{\
+0xFFED5000,	0xFFED5008,\
+0xFFED5044,	0xFFED5044,\
+0xFFED5058,	0xFFED5068,\
+0xFFED5090,	0xFFED50AC,\
+0xFFED50BC,	0xFFED50C8,\
+0xFFED50D4,	0xFFED50EC,\
+0xFFED5100,	0xFFED5138,\
+0xFFED5300,	0xFFED5358,\
+0xFFED538C,	0xFFED538C,\
+0xFFED5360,	0xFFED53B4,\
+0xFFED53BC,	0xFFED53D0,\
+0xFFED5FF0,	0xFFED5FF0,\
+}
+
+#define gen_reg_depth_top_dump_field \
+{\
+0xfffa0000,	0xfffa0004,\
+0xfffa0050,	0xfffa0050,\
+0xfffa0100,	0xfffa0104,\
+0xfffa0128,	0xfffa0128,\
+0xfffa0200,	0xfffa0234,\
+0xfffa0f00,	0xfffa0f00,\
+}
+
+#define gen_reg_dpc_top_dump_field \
+{\
+0xfff00000,	0xfff00004,\
+0xfff00010,	0xfff00010,\
+0xfff00100,	0xfff00104,\
+0xfff00128,	0xfff00128,\
+0xfff00f00,	0xfff00f00,\
+}
+
+#define gen_reg_hdr_top_dump_field \
+{\
+0xfff50000,	0xfff50004,\
+0xfff50100,	0xfff50104,\
+0xfff50128,	0xfff50128,\
+0xfff50f00,	0xfff50f00,\
+}
+
+#define gen_reg_irp_top_dump_field \
+{\
+0xffec3000,	0xffec3004,\
+0xffec3010,	0xffec3018,\
+0xffec3100,	0xffec3104,\
+0xffec3128,	0xffec312c,\
+0xffec3f00,	0xffec3f00,\
+}
+
+#define gen_reg_standby_top_dump_field \
+{\
+0xffec4000,	0xffec4004,\
+0xffec4010,	0xffec4020,\
+0xffec4030,	0xffec4044,\
+0xffec4100,	0xffec4104,\
+0xffec4128,	0xffec4128,\
+0xffec4f00,	0xffec4f00,\
+}
+
+#define gen_reg_tx_top_dump_field \
+{\
+0xffec0000,	0xffec0008,\
+0xffec0010,	0xffec0018,\
+0xffec0310,	0xffec0318,\
+0xffec0f00,	0xffec0f00,\
+}
+
+#define id_det_a_0_dump_field \
+{\
+0xfff01000,	0xfff01038,\
+0xfff01050,	0xfff0110c,\
+0xfff01150,	0xfff01158,\
+0xfff0117c,	0xfff011c8,\
+0xfff011f4,	0xfff01208,\
+0xfff012a0,	0xfff012b0,\
+0xfff012dc,	0xfff012e4,\
+}
+
+#define id_det_a_1_dump_field \
+{\
+0xfff02000,	0xfff02038,\
+0xfff02050,	0xfff0210c,\
+0xfff02150,	0xfff02158,\
+0xfff0217c,	0xfff021c8,\
+0xfff021f4,	0xfff02208,\
+0xfff022a0,	0xfff022b0,\
+0xfff022dc,	0xfff022e4,\
+}
+
+#define bayer_binning_a_0_dump_field \
+{\
+0xfff54000,	0xfff54008,\
+0xfff5401c,	0xfff54068,\
+0xfff54070,	0xfff54094,\
+}
+
+#define bayer_binning_a_1_dump_field \
+{\
+0xfff55000,	0xfff55008,\
+0xfff5501c,	0xfff55068,\
+0xfff55070,	0xfff55094,\
+}
+
+#define bayer_scl_a_0_dump_field \
+{\
+0xfffa7000,	0xfffa70d0,\
+0xfffa7100,	0xfffa7108,\
+0xfffa7110,	0xfffa7118,\
+0xfffa7200,	0xfffa7200,\
+}
+
+#define bayer_scl_a_1_dump_field \
+{\
+0xfffa8000,	0xfffa80d0,\
+0xfffa8100,	0xfffa8108,\
+0xfffa8110,	0xfffa8118,\
+0xfffa8200,	0xfffa8200,\
+}
+
+#define rlb_a_0_dump_field \
+{\
+0xfff05000,	0xfff0500c,\
+0xfff05018,	0xfff0501c,\
+0xfff05028,	0xfff0502c,\
+0xfff05058,	0xfff05098,\
+0xfff050b0,	0xfff050b0,\
+0xfff050b8,	0xfff050c8,\
+0xfff050d4,	0xfff050e0,\
+0xfff050f0,	0xfff050f0,\
+0xfff05100,	0xfff05108,\
+0xfff05110,	0xfff05110,\
+0xfff05120,	0xfff05138,\
+}
+
+#define rlb_b_0_dump_field \
+{\
+0xfff06000,	0xfff0600c,\
+0xfff06018,	0xfff0601c,\
+0xfff06028,	0xfff0602c,\
+0xfff06058,	0xfff06098,\
+0xfff060b0,	0xfff060b0,\
+0xfff060b8,	0xfff060c8,\
+0xfff060d4,	0xfff060e0,\
+0xfff060f0,	0xfff060f0,\
+0xfff06100,	0xfff06108,\
+0xfff06110,	0xfff06110,\
+0xfff06120,	0xfff06138,\
+}
+
+
+#define mipi_csi2_rx_0_dump_field \
+{\
+0xfff92000,	0xfff92004,\
+0xfff9200c,	0xfff9208c,\
+0xfff92100,	0xfff92148,\
+0xfff9215c,	0xfff9217c,\
+0xfff92188,	0xfff9218c,\
+0xfff92198,	0xfff921dc,\
+0xfff921f8,	0xfff922d4,\
+}
+
+#define mipi_csi2_rx_1_dump_field \
+{\
+0xfff95000,	0xfff95004,\
+0xfff9500c,	0xfff9508c,\
+0xfff95100,	0xfff95148,\
+0xfff9515c,	0xfff9517c,\
+0xfff95188,	0xfff9518c,\
+0xfff95198,	0xfff951dc,\
+0xfff951f8,	0xfff952d4,\
+}
+
+#define dg_ca_a_0_dump_field \
+{\
+0xfff8b000,	0xfff8b074,\
+}
+
+#define dg_mcc_a_0_dump_field \
+{\
+0xfffa8000, 0xfffa8024,\
+0xfffa80b0, 0xfffa8170,\
+}
+
+#define dp_top_a_0_dump_field \
+{\
+0xfff88000, 0xfff88090,\
+0xfff88100, 0xfff88104,\
+0xfff88200, 0xfff88240,\
+0xfff88280, 0xfff88280,\
+0xfff88300, 0xfff88300,\
+}
+
+#define lvhwirp_top_a_0_dump_field \
+{\
+0xfff30000, 0xfff30018,\
+0xfff30100, 0xfff30110,\
+0xfff30200, 0xfff30238,\
+0xfff30400, 0xfff30418,\
+0xfff31000, 0xfff311ec,\
+0xfff31300, 0xfff31310,\
+0xfff32000, 0xfff32ffc,\
+0xfff33000, 0xfff33004,\
+0xfff33100, 0xfff33188,\
+0xfff33200, 0xfff34204,\
+0xfff34300, 0xfff35ddc,\
+0xfff36000, 0xfff37000,\
+}
+
+#define lvhwirp_top_b_0_dump_field \
+{\
+0xfff20000, 0xfff20018,\
+0xfff20100, 0xfff20110,\
+0xfff20200, 0xfff20238,\
+0xfff20400, 0xfff20418,\
+0xfff21000, 0xfff211ec,\
+0xfff21300, 0xfff21310,\
+0xfff22000, 0xfff22ffc,\
+0xfff23000, 0xfff23004,\
+0xfff23100, 0xfff23188,\
+0xfff23200, 0xfff24204,\
+0xfff24300, 0xfff25ddc,\
+0xfff26000, 0xfff27000,\
+}
+
+#define lvlumanr_a_0_dump_field \
+{\
+0xfffa1000, 0xfffa1018,\
+0xfffa1040, 0xfffa1098,\
+0xfffa10A4, 0xfffa10C8,\
+}
+
+#define lvlumanr_a_1_dump_field \
+{\
+0xfffa2000, 0xfffa2018,\
+0xfffa2040, 0xfffa2098,\
+0xfffa20A4, 0xfffa20C8,\
+}
+
+#define lvsharp_a_0_dump_field \
+{\
+0xfffa5000, 0xfffa5028,\
+0xfffa5034, 0xfffa5034,\
+0xfffa5044, 0xfffa5060,\
+0xfffa5070, 0xfffa5070,\
+0xfffa50fc, 0xfffa51b0,\
+0xfffa5208, 0xfffa521c,\
+0xfffa5250, 0xfffa5264,\
+0xfffa5270, 0xfffa5270,\
+0xfffa5300, 0xfffa5308,\
+}
+
+#define lvsharp_a_1_dump_field \
+{\
+0xfffa6000, 0xfffa6028,\
+0xfffa6034, 0xfffa6034,\
+0xfffa6044, 0xfffa6060,\
+0xfffa6070, 0xfffa6070,\
+0xfffa60fc, 0xfffa61b0,\
+0xfffa6208, 0xfffa621c,\
+0xfffa6250, 0xfffa6264,\
+0xfffa6270, 0xfffa6270,\
+0xfffa6300, 0xfffa6308,\
+}
+
+#define rectify_a_0_dump_field \
+{\
+0xFFF8C000, 0xFFF8C008,\
+0xFFF8C010, 0xFFF8C010,\
+0xFFF8C024, 0xFFF8C024,\
+0xFFF8C040, 0xFFF8C040,\
+0xFFF8C050, 0xFFF8C050,\
+0xFFF8C060, 0xFFF8C060,\
+0xFFF8C080, 0xFFF8C084,\
+0xFFF8C100, 0xFFF8C108,\
+0xFFF8C110, 0xFFF8C110,\
+0xFFF8C17C, 0xFFF8C1A8,\
+0xFFF8C380, 0xFFF8C3A0,\
+0xFFF8C400, 0xFFF8C408,\
+0xFFF8C480, 0xFFF8C480,\
+0xFFF8C50C, 0xFFF8C518,\
+0xFFF8C540, 0xFFF8C540,\
+0xFFF8C550, 0xFFF8C550,\
+0xFFF8C5F0, 0xFFF8C5F0,\
+0xFFF8C900, 0xFFF8C908,\
+0xFFF8C910, 0xFFF8C910,\
+0xFFF8C97C, 0xFFF8C9A8,\
+0xFFF8CB80, 0xFFF8CBA0,\
+0xFFF8CC00, 0xFFF8CC00,\
+0xFFF8CC08, 0xFFF8CC08,\
+0xFFF8CC80, 0xFFF8CC80,\
+0xFFF8CD0C, 0xFFF8CD18,\
+0xFFF8CD40, 0xFFF8CD40,\
+0xFFF8CD50, 0xFFF8CD50,\
+0xFFF8CDF0, 0xFFF8CDF0,\
+0xFFF8CE04, 0xFFF8CE38,\
+0xFFF8CE40, 0xFFF8CE48,\
+0xFFF8CF00, 0xFFF8CFFC,\
+}
+
+#define rectify_b_0_dump_field \
+{\
+0xFFF8D000, 0xFFF8D008,\
+0xFFF8D010, 0xFFF8D010,\
+0xFFF8D024, 0xFFF8D024,\
+0xFFF8D040, 0xFFF8D040,\
+0xFFF8D050, 0xFFF8D050,\
+0xFFF8D060, 0xFFF8D060,\
+0xFFF8D080, 0xFFF8D084,\
+0xFFF8D100, 0xFFF8D108,\
+0xFFF8D110, 0xFFF8D110,\
+0xFFF8D17C, 0xFFF8D1A8,\
+0xFFF8D380, 0xFFF8D3A0,\
+0xFFF8D400, 0xFFF8D408,\
+0xFFF8D480, 0xFFF8D480,\
+0xFFF8D50C, 0xFFF8D518,\
+0xFFF8D540, 0xFFF8D540,\
+0xFFF8D550, 0xFFF8D550,\
+0xFFF8D5F0, 0xFFF8D5F0,\
+0xFFF8D900, 0xFFF8D908,\
+0xFFF8D910, 0xFFF8D910,\
+0xFFF8D97C, 0xFFF8D9A8,\
+0xFFF8DB80, 0xFFF8DBA0,\
+0xFFF8DC00, 0xFFF8DC00,\
+0xFFF8DC08, 0xFFF8DC08,\
+0xFFF8DC80, 0xFFF8DC80,\
+0xFFF8DD0C, 0xFFF8DD18,\
+0xFFF8DD40, 0xFFF8DD40,\
+0xFFF8DD50, 0xFFF8DD50,\
+0xFFF8DDF0, 0xFFF8DDF0,\
+0xFFF8DE04, 0xFFF8DE38,\
+0xFFF8DE40, 0xFFF8DE48,\
+0xFFF8DF00, 0xFFF8DFFC,\
+}
+/******Public Function Prototype******/
+extern errcode mini_isp_chip_base_dump_bypass_mode_register(void);
+
+extern errcode mini_isp_chip_base_dump_normal_mode_register(void);
+
+extern errcode mini_isp_chip_base_dump_irp_and_depth_based_register(void);
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl.h b/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl.h
new file mode 100644
index 0000000..6f63b30
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl.h
@@ -0,0 +1,326 @@
+/*
+ * File: miniisp_ctrl.h
+ * Description: The structure and API definition mini ISP Ctrl
+ * It is a header file that define structure and API for mini ISP Ctrl
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+
+#ifndef _MINIISP_CTRL_H_
+#define _MINIISP_CTRL_H_
+
+/**
+ *@addtogroup MiniISPCtrl
+ *@{
+ */
+
+/******Include File******/
+
+#include "mtype.h"
+#include "isp_camera_cmd.h"
+#include "error.h"
+#include "moduleid_pj.h"
+
+/******Global define******/
+#define DEPTH_NONE                  0x0  /*No depth*/
+#define DEPTH_BIT_RES_180           0x1  /*180p*/
+#define DEPTH_BIT_RES_360           0x2  /*360p*/
+#define DEPTH_BIT_RES_720           0x3  /*720p*/
+#define DEPTH_BIT_RES_480           0x4  /*480p*/
+
+#define DEPTH_BIT_DG_ONLY           0x00
+#define DEPTH_BIT_DP_SPARSE_1       0x10
+#define DEPTH_BIT_DP_SPARSE_2       0x20
+#define DEPTH_BIT_DP_SPARSE_3       0x30
+#define DEPTH_BIT_DP_DENSE          0x40
+#define DEPTH_BIT_MASK_TYPE         0x70
+#define DEPTH_BIT_RESV              0x80
+
+/******Public Function Prototype******/
+extern struct altek_statefsm *get_mini_isp_fsm(void);
+
+/**
+ *\brief Mini ISP open
+ *\param boot_code_file_name		[In], Boot code filename
+ *\param basic_code_file_name	   [In], Basic code filename
+ *\param advanced_code_file_name	[In], Advanced code filename
+ *\param scenario_table_file_name	 [In], Sc table filename
+ *\param hdr_qmerge_file_name	 [In], hdr qmerge filename
+ *\param irp0_qmerge_file_name	 [In], irp0 qmerge filename
+ *\param irp1_qmerge_file_name	 [In], irp1 qmerge filename
+  *\param pp_map_file_name	 [In], PP map filename
+ *\return Error code
+ *\image html BootSeq.jpg
+ */
+extern errcode mini_isp_drv_open(char *boot_code_file_name,
+				char *basic_code_file_name,
+				char *advanced_code_file_name,
+				char *scenario_table_file_name,
+				char *hdr_qmerge_file_name,
+				char *irp0_qmerge_file_name,
+				char *irp1_qmerge_file_name,
+				char *pp_map_file_name
+				);
+
+/**
+ *\brief Mini ISP write boot code
+ *\param n/a
+ *\return Error code
+ */
+extern errcode mini_isp_drv_write_boot_code(void);
+
+/**
+ *\brief Mini ISP write basic code
+ *\param n/a
+ *\return Error code
+ */
+extern errcode mini_isp_drv_write_basic_code(void);
+
+/**
+ *\brief Mini ISP Write Calibration Data 0x210B
+ *\param info_id [In],		0   :  otp data
+ *				1   :  packet data
+ *				2   :  scenario table
+ *				3   :  hdr
+ *				4   :  irp0
+ *				5   :  irp1
+ *				6   :  PP map
+ *				7   :  blending table
+ *\param buf_addr [In], otp/packet data buffer start address
+ *\param buf_len [In], otp/packet data buffer len
+ *\return Error code
+ */
+extern errcode mini_isp_drv_write_calibration_data(u8 info_id,
+					u8 *buf_addr, u32 buf_len);
+
+
+/**
+ *\brief Set Sensor Mode	0x300A
+ *\param sensor_on_off [In],sensor on/off
+ *\param scenario_id[In], Scenario ID
+ *\param mipi_tx_skew_enable[In],  mipi tx skew on(1)/off(0)
+ *\param ae_weighting_table_index[In]
+ *\param merge_mode_enable[In]
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_sensor_mode(u8 sensor_on_off,
+					u8 scenario_id,
+					u8 mipi_tx_skew_enable,
+					u8 ae_weighting_table_index,
+					u8 merge_mode_enable);
+
+/**
+ *\brief Set Output Format	0x300D
+ *\param depth_map_setting [In]
+ *\param depth_process_type[In] value 0x6 as reserve
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_output_format(u8 depth_map_setting, u8 depth_process_type);
+
+/**
+ *\brief Set CP Mode	0x300E
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_cp_mode(void);
+
+/**
+ *\brief Leave CP Mode
+ *\using set sensor mode opcode :0x300A
+ *\param sensor_on_off [In],sensor on/off
+ *\param scenario_id[In], Scenario ID
+ *\param mipi_tx_skew_enable[In],  mipi tx skew on(1)/off(0)
+ *\param ae_weighting_table_index[In]
+ *\param merge_mode_enable[In]
+ *\return Error code
+ */
+extern errcode mini_isp_drv_leave_cp_mode(u8 sensor_on_off, u8 scenario_id,
+		u8 mipi_tx_skew_enable, u8 ae_weighting_table_index, u8 merge_mode_enable);
+
+/**
+ *\brief Set AE statistics		0x300F
+ *\param gr_channel_weight [In],
+ *\param gb_channel_weight [In],
+ *\param r_channel_weight [In],
+ *\param b_channel_weight [In],
+ *\param shift_bits [In],
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_ae_statistics(
+	struct isp_cmd_ae_statistics *ae_statistics);
+
+/**
+ *\brief Preview stream on/off		0x3010
+ *\param tx0_stream_on_off [In], Tx0 stream on/off
+ *\param tx1_stream_on_off [In], Tx1 stream on/off
+ *\return Error code
+ */
+errcode mini_isp_drv_preview_stream_on_off(u8 tx0_stream_on_off,
+				u8 tx1_stream_on_off);
+
+/**
+ *\brief Dual PD Y Calcualtion Weighting		0x3011
+ *\param isp_cmd_dual_pd_y_calculation_weightings [In],
+   dual PD Y calculation weightings
+ *\return Error code
+ */
+errcode mini_isp_drv_dual_pd_y_calculation_weighting(
+	struct isp_cmd_dual_pd_y_calculation_weightings *calculation_weighting);
+
+/**
+ *\brief LED power control		0x3012
+ *\param projector_control_param,
+ *\return Error code
+ */
+errcode mini_isp_drv_led_power_control(
+	struct isp_cmd_led_power_control *projector_control_param);
+
+/**
+ *\brief Active AE		0x3013
+ *\param active_ae [In],
+ *\return Error code
+ */
+extern errcode mini_isp_drv_active_ae(
+	struct isp_cmd_active_ae *active_ae_param);
+
+/**
+ *\brief  ISP AE control mode on off		0x3014
+ *\param isp_ae_control_mode_on_off [In], 0:off 1:on
+ *\return Error code
+ */
+extern errcode mini_isp_drv_isp_ae_control_mode_on_off(
+	u8 isp_ae_control_mode_on_off);
+
+/**
+ *\brief  Set Frame Rate Limite		0x3015
+ *\param set_frame_rate_param [In],
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_frame_rate_limits(
+	struct isp_cmd_frame_rate_limits *set_frame_rate_param);
+
+extern errcode mini_isp_drv_get_sensor_mode(void);
+
+extern errcode mini_isp_drv_get_last_exec_cmd(void);
+
+extern errcode mini_isp_drv_get_err_code_cmd(void);
+
+extern errcode mini_isp_drv_get_err_code_cmd_in_irq(void);
+
+extern u16 mini_isp_drv_read_spi_status(void);
+
+
+/**
+ *\brief Set ISP register	0x0100
+ *\param reg_start_addr [In], Reg start addr
+ *\param reg_value [In], Reg value
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_isp_register(u32 reg_start_addr,
+					u32 reg_value);
+
+
+/**
+ *\brief Get ISP register
+ *\param reg_start_addr [In], Reg start addr
+ *\param reg_count  [In], Reg count
+ *\return Error code
+ */
+extern errcode mini_isp_drv_get_isp_register(u32 reg_start_addr,
+					u32 reg_count);
+
+/**
+ *\brief Get Chip test Report	0x010A
+ *\return Error code
+ */
+extern errcode mini_isp_drv_get_chip_test_report(void);
+
+/**
+ *\brief Set Depth 3A Information	0x10B9
+ *\param depth_3a_info [In], Depth 3A parameter
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_depth_3a_info(
+	struct isp_cmd_depth_3a_info *depth_3a_info);
+
+/**
+ *\brief Set Depth auto interleave mode	0x10BC
+ *\param depth_auto_interleave_param [In], ISP Depth auto interleave parameter
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_depth_auto_interleave_mode(
+	struct isp_cmd_depth_auto_interleave_param
+	*depth_auto_interleave_param);
+
+/**
+ *\brief Set Projector Interleave Mode with Depth Type	0x10BD
+ *\param mini_isp_drv_projector_interleave_mode_depth_type [In],
+ *\      0: depth active, 1: depth passive
+ *\return Error code
+ */
+extern errcode mini_isp_drv_projector_interleave_mode_depth_type(
+	u8 projector_interleave_mode_with_depth_type);
+
+/**
+ *\brief Set Depth Polish LEVEL	0x10BE
+ *\param depth_polish_level [In], 0~100
+ *\return Error code
+ */
+extern errcode mini_isp_drv_set_depth_polish_level(
+	u8 depth_polish_level);
+/**
+ *\brief Reading Common Log
+ *\param stop [In], Stop to log flag
+ *\return Error code
+ */
+extern errcode mini_isp_drv_read_com_log(bool stop);
+
+/**
+ *\brief Read memory
+ *\param start_addr [In]starting address
+ *\param read_size [In]TotalReadSize
+ *\return Error code
+ */
+extern errcode mini_isp_drv_read_memory(u32 start_addr, u32 read_size);
+
+extern errcode mini_isp_drv_set_com_log_level(u32 log_level);
+
+/**
+ *\brief  Master boot miniISP
+ *\param  e [In], MINI_ISP_EVENT
+ *\return Errorcode
+ */
+extern int mini_isp_drv_wait_for_event(u16 e);
+
+extern errcode mini_isp_drv_setting(u16 mini_isp_mode);
+
+extern errcode mini_isp_drv_set_bypass_mode(u16 bypass_mode);
+
+extern errcode mini_isp_drv_set_max_exposure(u32 max_exposure);
+
+extern errcode mini_isp_drv_set_target_mean(u16 target_mean);
+
+extern void mini_isp_drv_send_use_i2c(u8 mini_isp_i2c_use);
+
+extern void mini_isp_drv_altek_i2c_mode_change(void);
+
+extern errcode mini_isp_drv_load_fw(void);
+
+extern void mini_isp_reset(void);
+
+
+/** \brief  Master boot miniISP
+ *\param  None
+ *\return None
+ */
+extern int mini_isp_drv_boot_mini_isp(void);
+
+/******End of File******/
+
+/**
+ *@}
+ */
+
+#endif /* _MINIISP_CTRL_H_*/
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl_intf.h b/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl_intf.h
new file mode 100644
index 0000000..e35dea7
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp_ctrl_intf.h
@@ -0,0 +1,13 @@
+
+extern int handle_ControlFlowCmd_II(u16 miniisp_op_code, u8 *param);
+extern long handle_ControlFlowCmd(unsigned int cmd, unsigned long arg);
+// ALTEK_AL6100_CHI >>>
+enum miniisp_firmware {
+	IQ_CODE,
+	DEPTH_CODE,
+	OTHER_MAX
+};
+extern long handle_ControlFlowCmd_CHI(unsigned int cmd, unsigned long arg);
+extern void mini_isp_other_drv_open(char *file_name, u8 type);
+extern void mini_isp_other_drv_read(struct file *filp, u8 type);
+// ALTEK_AL6100_CHI <<<
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp_customer_define.h b/drivers/media/platform/msm/camera/al6100/include/miniisp_customer_define.h
new file mode 100644
index 0000000..ab6f670
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp_customer_define.h
@@ -0,0 +1,61 @@
+/*
+ * File: miniisp_customer_define.h
+ * Description: miniISP customer define
+ */
+#include <linux/spi/spi.h>
+/******Public Define******/
+
+/*SPI MODE*/
+#define SPI_MODE (SPI_MODE_3) /*SPI_MODE_3 | SPI_CS_HIGH*/
+/*boot file location*/
+#define BOOT_FILE_LOCATION "/data/firmware2/miniBoot.bin"//"/system/vendor/firmware/miniBoot.bin"
+/*basic code location*/
+#define BASIC_FILE_LOCATION "/data/firmware2/TBM_SK1.bin"//"/system/vendor/firmware/TBM_SK1.bin"
+/*advanced code location*/
+#define ADVANCED_FILE_LOCATION NULL
+/*scenario table location*/
+#define SCENARIO_TABLE_FILE_LOCATION "/data/firmware2/SCTable.asb"//  "/system/vendor/firmware/SCTable.asb"
+
+/*hdr qmerge data location*/
+#define HDR_QMERGE_DATA_FILE_LOCATION "/data/firmware2/HDR.bin" //  "/system/vendor/firmware/HDR.bin"
+/*irp0 qmerge data location*/
+#define IRP0_QMERGE_DATA_FILE_LOCATION "/data/firmware2/IRP0.bin" //  "/system/vendor/firmware/IRP0.bin"
+/*irp1 qmerge data location*/
+#define IRP1_QMERGE_DATA_FILE_LOCATION "/data/firmware2/IRP1.bin" //  "/system/vendor/firmware/IRP1.bin"
+/*pp map location*/
+#define PP_MAP_FILE_LOCATION NULL/*"/system/etc/firmware/PPmap.bin"*/
+// ALTEK_AL6100_CHI >>>
+/*iq calibaration data location*/
+#define IQCALIBRATIONDATA_FILE_LOCATION "/data/firmware2/IQCalibrationData_Decrypt.bin" /*"/system/etc/firmware/PPmap.bin"*/
+/*depth pack data location*/
+#define DEPTHPACKDATA_FILE_LOCATION "/data/firmware2/DepthPackData_Decrypt.bin" /*"/system/etc/firmware/PPmap.bin"*/
+// ALTEK_AL6100_CHI <<<
+/*miniISP dump info save location*/
+/*Add location folder where you let Altek debug info saving in your device*/
+#define MINIISP_INFO_DUMPLOCATION "/data/miniISP_dump_reg"
+
+/*miniISP bypass setting file location*/
+/*Add location folder where you let Altek debug info saving in your device*/
+#define MINIISP_BYPASS_SETTING_FILE_PATH "/data/firmware2/"//"/system/vendor/firmware/"
+
+/*define for gpio*/
+/*vcc1 : if no use, set NULL*/
+#define VCC1_GPIO "vcc1-gpios" /*"vcc1-gpios"*/
+
+/*vcc2 : if no use, set NULL*/
+#define VCC2_GPIO NULL/*"vcc2-gpios"*/
+
+/*vcc3 : if no use, set NULL*/
+#define VCC3_GPIO NULL/*"vcc3-gpios"*/
+
+/*reset*/
+#define RESET_GPIO "reset-gpios"  //"reset-gpios"
+
+/*irq*/
+#define IRQ_GPIO "irq-gpios"
+
+/*isp_clk : if no use, set NULL*/
+#define ISP_CLK NULL /*"al6100_clk"*/
+
+/******Public Function Prototype******/
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/miniisp_debug_if.h b/drivers/media/platform/msm/camera/al6100/include/miniisp_debug_if.h
new file mode 100644
index 0000000..d601a8a
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/miniisp_debug_if.h
@@ -0,0 +1,52 @@
+#ifndef _ISPDBG_IOCTL_H
+#define _ISPDBG_IOCTL_H
+
+#include <asm-generic/ioctl.h>         //_IOW(), _IOR()
+#include <linux/types.h>
+#include <miniISP/miniISP_ioctl.h>
+
+struct ioctl_regRW_cmd {
+    u32 RegAddr;
+    u32 RegVal;
+};
+
+struct ioctl_regBulkRW_cmd {
+    u32 StartAddr;
+    u32 EndAddr;
+};
+
+struct ioctl_memRW_cmd {
+    u32 MemAddr;
+    u32 len;
+};
+
+#define IOC_REGCMD_MAGIC 'R'
+#define IOC_MEMCMD_MAGIC 'M'
+#define IOC_BULKCMD_MAGIC 'B'
+#define IOC_INFOCMD_MAGIC 'I'
+#define IOC_PREPARECMD_MAGIC 'P'
+
+/*------------------ _IOX(TYPE 8bits, nr 8bits, size 14bits) */
+#if 1
+#define IOCTL_REGREAD _IOR(IOC_REGCMD_MAGIC, 1, struct ioctl_regRW_cmd)
+#define IOCTL_REGWRITE _IOW(IOC_REGCMD_MAGIC, 2, struct ioctl_regRW_cmd)
+#define IOCTL_REGBULKREAD _IOR(IOC_BULKCMD_MAGIC, 3, struct ioctl_regBulkRW_cmd)
+#define IOCTL_REGBULKWRITE _IOR(IOC_BULKCMD_MAGIC, 4, struct ioctl_regBulkRW_cmd)
+#define IOCTL_MEMREAD _IOR(IOC_MEMCMD_MAGIC, 5, struct ioctl_memRW_cmd)
+#define IOCTL_MEMWRITE _IOW(IOC_MEMCMD_MAGIC, 6, struct ioctl_memRW_cmd)
+#define IOCTL_MUNMAP_DONE _IOW(IOC_MEMCMD_MAGIC, 7, struct ioctl_memRW_cmd)
+#define IOCTL_MEMGET _IOW(IOC_MEMCMD_MAGIC, 8, struct ioctl_memRW_cmd)
+#define IOCTL_IRP_DEPTH_INFO _IOR(IOC_INFOCMD_MAGIC, 9, struct irp_and_depth_information)
+#define IOCTL_REFRESH_MODULE _IOR(IOC_PREPARECMD_MAGIC, 10, u8)
+#endif
+
+#if 0
+#define IOCTL_REGREAD _IOR(IOC_REGCMD_MAGIC, 1, struct ioctl_regRW_cmd)
+#define IOCTL_REGWRITE _IOW(IOC_REGCMD_MAGIC, 2, struct ioctl_regRW_cmd)
+#define IOCTL_MEMREAD _IOR(IOC_MEMCMD_MAGIC, 3, struct ioctl_memRW_cmd)
+#define IOCTL_MEMWRITE _IOW(IOC_MEMCMD_MAGIC, 4, struct ioctl_memRW_cmd)
+#define IOCTL_GETMEM _IOW(IOC_MEMCMD_MAGIC, 5, struct ioctl_memRW_cmd)
+#define IOCTL_MUNMAP_DONE _IOW(IOC_MEMCMD_MAGIC, 6, struct ioctl_memRW_cmd)
+#endif
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/include/moduleid.h b/drivers/media/platform/msm/camera/al6100/include/moduleid.h
new file mode 100644
index 0000000..d5d7cd8
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/moduleid.h
@@ -0,0 +1,51 @@
+/*
+ * File: moduleid.h
+ * Description: Define module id
+ */
+/**
+ *@file moduleid.h
+ *@author Gene Hung
+ *@version 2005/08/22; Gene; Add Doxygen remark
+ *@defgroup ModuleID Module ID definition
+ *@brief TBirdOS 2.0 and later module ID definition.
+ *code number definition:
+ *Bits 31~20: Module id
+ *Bits 19~12: Reserved
+ *Bits 11~0: Code defined in each module
+ */
+
+#ifndef _MODULEID_H_
+#define _MODULEID_H_
+
+/**
+ *@ingroup ModuleID
+ *@{
+ */
+
+/**
+ *@def MODULEID_SHIFTBITS
+ *@brief Module ID MARCO definition
+ */
+#define MODULEID_SHIFTBITS 20
+/**
+ *@def MODULEID_ModuleID
+ *@brief Get ID number from a CODE
+ */
+#define MODULEID_ModuleID(code) (code >> MODULEID_SHIFTBITS)
+/**
+ *@def MODULEID_ModuleBase
+ *@brief Get CODE BASE from a module ID
+ */
+#define MODULEID_ModuleBase(id) (id << MODULEID_SHIFTBITS)
+
+/* Project-dependent module starts from this ID*/
+#define MODULEID_PROJECT 0x400
+
+
+/* Let Project use MODULEID_PROJECT to extend. */
+/*Don't define module ID 0x401 0x402... here.*/
+
+/**
+ *@}
+ */
+#endif /*_MODULEID_H_*/
diff --git a/drivers/media/platform/msm/camera/al6100/include/moduleid_pj.h b/drivers/media/platform/msm/camera/al6100/include/moduleid_pj.h
new file mode 100644
index 0000000..7998107
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/moduleid_pj.h
@@ -0,0 +1,19 @@
+/*
+ * File: Moduleid_PJ.h
+ * Description: Define module id  in project
+ */
+#ifndef _MODULEID_PJ_H_
+#define _MODULEID_PJ_H_
+
+#include "moduleid.h"
+
+/* Project-dependent module starts from MODULEID_PROJECT (0x400)*/
+#define MODULEID_PJ_MINIISP_STATE	 (MODULEID_PROJECT + 0x2C)
+#define MODULEID_PJ_ISPCTRLIF_SLAVE	 (MODULEID_PROJECT + 0x2D)
+#define MODULEID_PJ_ISPCTRLIF_MASTER	(MODULEID_PROJECT + 0x2E)
+#define MODULEID_PJ_MINIISP			 (MODULEID_PROJECT + 0x2F)
+#endif
+
+
+
+
diff --git a/drivers/media/platform/msm/camera/al6100/include/mtype.h b/drivers/media/platform/msm/camera/al6100/include/mtype.h
new file mode 100644
index 0000000..bd43629
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/include/mtype.h
@@ -0,0 +1,19 @@
+/*
+ * File: mtype.h
+ * Description: Global type definition
+ *   Please don't add new definition arbitrarily
+ *   Only system-member is allowed to modify this file
+ */
+
+#ifndef _MTYPE_H_
+#define _MTYPE_H_
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+
+typedef u32 errcode;
+
+/* Other definition*/
+/*#define _Uncached volatile __attribute__ ((section(".ucdata")))*/
+
+#endif
diff --git a/drivers/media/platform/msm/camera/al6100/ispctrl_if_master.c b/drivers/media/platform/msm/camera/al6100/ispctrl_if_master.c
new file mode 100644
index 0000000..c350dca
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/ispctrl_if_master.c
@@ -0,0 +1,855 @@
+/*
+ * File: ispctrl_if_master.c
+ * Description: ISP Ctrl IF Master
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/******Include File******/
+/* Linux headers*/
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+
+#include "include/miniisp.h"
+#include "include/ispctrl_if_master.h"
+#include "include/isp_camera_cmd.h"
+#include "include/error/ispctrl_if_master_err.h"
+#include "include/ispctrl_if_master_local.h"
+#include "include/miniisp_ctrl.h"
+#include "include/miniisp_chip_base_define.h"
+
+
+/*extern struct misp_data *misp_drv_data;*/
+
+/******Private Constant Definition******/
+#define MASTERTX_BLOCK_SIZE SPI_TX_BULK_SIZE
+#define MINI_ISP_LOG_TAG "[_mini_ispctrl_if_master]"
+
+
+/******Private Type Definition******/
+struct file *g_filp[FIRMWARE_MAX];
+struct spi_device *spictrl;
+/******Private Function Prototype******/
+
+
+static errcode execute_system_manage_cmd(void *devdata, u16 opcode,
+					u8 *param);
+static errcode execute_basic_setting_cmd(void *devdata, u16 opcode,
+					u8 *param);
+static errcode execute_bulk_data_cmd(void *devdata, u16 opcode,
+				u8 *param);
+static errcode execute_camera_profile_cmd(void *devdata, u16 opcode,
+					u8 *param);
+static errcode execute_operation_cmd(void *devdata, u16 opcode,
+					u8 *param);
+
+static ssize_t ispctrl_if_mast_show(struct device *dev,
+				   struct device_attribute *attr, char *buf);
+static ssize_t ispctrl_if_mast_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+
+static u16 isp_mast_calculate_check_sum(u8 *input_buffer_addr,
+					u16 input_buffer_size, bool b2sCom);
+
+/******Private Global Variable******/
+static DEVICE_ATTR(ispctrl_config, S_IRUGO | S_IWUSR, ispctrl_if_mast_show,
+		ispctrl_if_mast_store);
+
+
+/******Private Global Variable******/
+
+
+
+
+/******Public Function******/
+
+/*
+ *\brief ISP Ctrl IF Master init
+ *\param none
+ *\return Error code
+ */
+static int __init ispctrl_if_mast_init(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+
+	misp_info("%s - start", __func__);
+
+	/*Reset parameters*/
+	isp_mast_camera_profile_para_init();
+
+	/*spi_log_task = kthread_run(isp_mast_log_task, NULL,
+	 *			"isp_master_log_thread");
+	 *if (IS_ERR(spi_log_task)) {
+	 *	err = PTR_ERR(spi_log_task);
+	 *	misp_err("%s - thread created err: %d", __func__, err);
+	 *	goto ispctrl_if_mast_init_end;
+	 *}
+	 */
+	misp_info("%s - success.", __func__);
+
+/*ispctrl_if_mast_init_end:*/
+
+	return err;
+}
+
+static void __exit ispctrl_if_mast_exit(void)
+{
+	/*if (spi_log_task)
+	 *	kthread_stop(spi_log_task);
+	 */
+	misp_info("%s - success.", __func__);
+}
+
+
+/*
+ *\brief Execute SPI master command
+ *\param opcode [In], Op code
+ *\param param [In], CMD param buffer
+ *\return Error code
+ */
+errcode ispctrl_if_mast_execute_cmd(u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct misp_global_variable *devdata_global_variable;
+	void *devdata;
+
+	misp_info("%s - start0.enter ispctrl_if_mast_execute_cmd opcode: %#04x >>>",
+		__func__, opcode);
+
+	devdata_global_variable = get_mini_isp_global_variable();
+	devdata = (void *)get_mini_isp_intf(MINIISP_I2C_TOP);
+
+	if (!devdata)
+		return -ENODEV;
+
+	misp_info("%s - start1.enter ispctrl_if_mast_execute_cmd opcode: %#04x",
+		__func__, opcode);
+
+	mutex_lock(&devdata_global_variable->busy_lock);
+
+	/* System Management 0x0000~0x0FFF*/
+	if (opcode <= 0x0FFF)
+		err = execute_system_manage_cmd(devdata, opcode, param);
+	/* Basic Setting 0x1000~0x1FFF*/
+	else if (opcode <= 0x1FFF)
+		err = execute_basic_setting_cmd(devdata, opcode, param);
+	/* Bulk Data 0x2000~0x2FFF*/
+	else if (opcode <= 0x2FFF)
+		err = execute_bulk_data_cmd(devdata, opcode, param);
+	/* Camera Profile 0x3000~0x3FFF*/
+	else if (opcode <= 0x3FFF)
+		err = execute_camera_profile_cmd(devdata, opcode, param);
+	/*Operation 0x4000~0x4FFF*/
+	else if (opcode <= 0x4FFF)
+		err = execute_operation_cmd(devdata, opcode, param);
+
+	mdelay(2);
+
+	mutex_unlock(&devdata_global_variable->busy_lock);
+
+	misp_info("%s - leave. ispctrl_if_mast_execute_cmd opcode: %#04x <<<",
+		__func__, opcode);
+
+	return err;
+}
+EXPORT_SYMBOL(ispctrl_if_mast_execute_cmd);
+
+/*
+ *\brief Send command to slave
+ *\param devdata [In], misp_data
+ *\param opcode [In], Op code
+ *\param param [In], CMD param buffer
+ *\param len [In], CMD param size
+ *\return Error code
+ */
+errcode ispctrl_mast_send_cmd_to_slave(void *devdata,
+					u16 opcode, u8 *param, u32 len)
+{
+	u16 *send_len, *send_opcode, total_len;
+	errcode err = ERR_SUCCESS;
+	u16 chksum;
+	u8 *tx_buf;
+	struct misp_global_variable *devdata_global_variable;
+	misp_info("%s - enter", __func__);
+
+	devdata_global_variable = get_mini_isp_global_variable();
+	tx_buf = ((struct misp_data *)devdata)->tx_buf;
+
+	memset(tx_buf, 0, TX_BUF_SIZE);
+
+	send_len = (u16 *)&tx_buf[0];
+	send_opcode = (u16 *)&tx_buf[ISPCMD_LENFLDBYTES];
+
+	/*[2-byte len field] + [2-byte opcode field] + (params len)*/
+	total_len = ISPCMD_CMDSIZE + len;
+	/* totoal - 2-byte length field*/
+	*send_len = total_len - ISPCMD_LENFLDBYTES;
+
+	*send_opcode = opcode;
+	if (len > 0)
+		memcpy(&tx_buf[ISPCMD_CMDSIZE], param, len);
+
+	/*calculate checksum*/
+	chksum = isp_mast_calculate_check_sum(tx_buf, total_len, true);
+	memcpy(&tx_buf[total_len], &chksum, ISPCMD_CKSUMBYTES);
+
+	/*add bytes for checksum*/
+	total_len += ISPCMD_CKSUMBYTES;
+
+	/**
+	 * tx_buf:
+	 * |--len_field(2)--|
+	 *		 |--opcode(2)--|--param(len)--|
+	 *					       |--cksum(2)--|
+	 * len_field size: ISPCMD_LENFLDBYTES (2 bytes)
+	 * opcode size: ISPCMD_OPCODEBYTES (2 bytes)
+	 * param size: (len bytes)
+	 * ISP_CMD_HDR_SIZE = ISPCMD_LENFLDBYTES + ISPCMD_OPCODEBYTES (4 bytes)
+	 *
+	 * total_len: (len_field_size + opcode_size + param_size + cksum_size)
+	 * len(param_len) = (opcode_size + param_size), excluding cksum
+	 */
+
+	/* Send command to slave*/
+	err = ((struct misp_data *)devdata)->intf_fn->send(devdata, total_len);
+
+	misp_info("%s - leave", __func__);
+
+	return err;
+}
+
+/*
+ *\brief Receive response from slave
+ *\param devdata [In], misp_data
+ *\param param [Out], Respons e buffer
+ *\param len [Out], Response size
+ *\return Error code
+ */
+errcode ispctrl_mast_recv_response_from_slave(void *devdata,
+				u8 *param, u32 len, bool wait_int)
+{
+	errcode err = ERR_SUCCESS;
+	u32 total_len;
+	u16  org_chk_sum;
+	u8 *rx_buf;
+	struct misp_global_variable *devdata_global_variable;
+
+	devdata_global_variable = get_mini_isp_global_variable();
+	rx_buf = ((struct misp_data *)devdata)->rx_buf;
+
+	memset(rx_buf, 0, RX_BUF_SIZE);
+	total_len = len + ISPCMD_CMDSIZEWDUMMY + ISPCMD_CKSUMBYTES;
+
+	/*Receive command from slave*/
+	err = ((struct misp_data *)devdata)->intf_fn->recv(devdata,total_len, wait_int);
+	if (err != ERR_SUCCESS)
+		goto ispctrl_mast_recv_response_from_slave_end;
+
+
+	/*checksum*/
+	memcpy(&org_chk_sum, &rx_buf[(total_len - ISPCMD_CKSUMBYTES)],
+		ISPCMD_CKSUMBYTES);
+	if (org_chk_sum != isp_mast_calculate_check_sum(rx_buf,
+				(total_len - ISPCMD_CKSUMBYTES), true)) {
+		misp_err("%s - checksum error", __func__);
+		err = ERR_MASTERCMDCKSM_INVALID;
+		goto ispctrl_mast_recv_response_from_slave_end;
+	}
+
+
+	/* Copy param data*/
+	memcpy(param, &rx_buf[ISPCMD_CMDSIZEWDUMMY], len);
+
+ispctrl_mast_recv_response_from_slave_end:
+
+	return err;
+
+}
+
+/*
+ *\brief Receive Memory data from slave
+ *\param devdata [In], misp_data
+ *\param response_buf [Out], Response buffer
+ *\param response_size [Out], Response size
+ *\param wait_int [In], waiting INT flag
+ *\return Error code
+ */
+errcode ispctrl_if_mast_recv_memory_data_from_slave(
+						void *devdata,
+						u8 *response_buf,
+						u32 *response_size,
+						bool wait_int)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 expect_size;
+	u32 block_size = ((struct misp_data *)devdata)->bulk_cmd_blocksize;
+	u32 altek_event_state;
+	u16 i;
+
+	expect_size = *response_size;
+
+	misp_info("%s - Start.", __func__);
+
+	if (wait_int) {
+		err = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+		if (err) {
+			misp_err("%s - irq error: status=%d",
+				__func__, err);
+			goto ispctrl_if_mast_recv_memory_data_from_slave_end;
+		}
+	} else {
+		for (i = 0; i < 200; i++) {
+			err = mini_isp_get_altek_status(devdata,
+						&altek_event_state);
+			if (altek_event_state & COMMAND_COMPLETE) {
+				altek_event_state = (altek_event_state &
+					~((~0) << 1));
+				break;
+			}
+			mdelay(5);
+		}
+		if (i >= 200) {
+			misp_err("%s time out.", __func__);
+			err = ERR_MASTER_EVENT_TIMEOUT;
+			goto ispctrl_if_mast_recv_memory_data_from_slave_end;
+		}
+
+	}
+
+	err = mini_isp_get_bulk((struct misp_data *)devdata,
+			response_buf, expect_size, block_size);
+
+ispctrl_if_mast_recv_memory_data_from_slave_end:
+
+	return err;
+}
+/*
+ * \brief  Master send bulk (large data) to slave
+ *   \param  devdata [In], misp_data
+ *   \param  buffer [In], Data buffer to be sent, address 8-byte alignment
+ *   \param  filp [In], file pointer, used to read the file and send the data
+ *   \param  total_size [In], file size
+ *   \param  block_size [In], transfer buffer block size
+ *   \param  is_raw [In], true: mini boot code  false: other files
+ *   \return Error code
+ */
+errcode ispctrl_if_mast_send_bulk(void *devdata, u8 *buffer,
+	struct file *filp, u32 total_size, u32 block_size, bool is_raw)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+
+	if ((!filp) && (buffer == NULL))
+		return -ENOENT;
+
+	misp_info("ispctrl_if_master_send_bulk Start ============");
+	/* Transfer basic code*/
+	err = ((struct misp_data *)devdata)->intf_fn->send_bulk(devdata,
+			filp, total_size, block_size, is_raw, buffer);
+
+	if (err != ERR_SUCCESS)
+		misp_err("ispctrl_if_master_send_bulk failed!!");
+	misp_info("ispctrl_if_master_send_bulk End ============");
+
+	/*close the file*/
+	if (filp && (buffer == NULL))
+		filp_close(filp, NULL);
+
+	return err;
+
+}
+
+
+/* open boot / basic / advanced / sc table file*/
+errcode ispctrl_if_mast_request_firmware(u8 *filepath, u8 firmwaretype)
+{
+	errcode err = ERR_SUCCESS;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	misp_info("%s filepath : %s", __func__, filepath);
+
+	g_filp[firmwaretype] = filp_open(filepath, O_RDONLY, 0644);
+	set_fs(oldfs);
+
+	if (IS_ERR(g_filp[firmwaretype])) {
+		err = PTR_ERR(g_filp[firmwaretype]);
+		misp_err("%s open file failed. err: %x", __func__, err);
+	} else {
+		misp_info("%s open file success!", __func__);
+	}
+	return err;
+}
+
+/* currently not use
+u16 ispctrl_if_mast_read_spi_status(void)
+{
+	return mini_isp_get_status();
+}
+*/
+
+/*
+ *\brief Receive ISP register response from slave
+ *\param devdata [In], misp_data
+ *\param response_buf [Out], Response buffer
+ *\param response_size [Out], Response size
+ *\param total_count [In], Total reg count
+ *\return Error code
+ */
+errcode ispctrl_if_mast_recv_isp_register_response_from_slave(
+		void *devdata, u8 *response_buf,
+		u32 *response_size, u32 total_count)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 total_len;
+	u16 org_chk_sum;
+
+	/* Last packet flag*/
+	bool last_packet = false;
+	/* Get Reg count*/
+	u8 reg_count = 0;
+	/* Total count*/
+	u32 use_total_count = total_count;
+	/* Total return size*/
+	u32 total_ret_size = 0;
+	/* Max count*/
+	u8 max_reg_count = 12;
+	/* Checksum*/
+	u16 check_sum = 0;
+	bool wait_int = true;
+	u8 *rx_buf;
+	struct misp_global_variable *devdata_global_variable;
+
+	devdata_global_variable = get_mini_isp_global_variable();
+	rx_buf = ((struct misp_data *)devdata)->rx_buf;
+
+	/* Update expect size*/
+	total_len = ISPCMD_CMDSIZEWDUMMY + ISP_REGISTER_PARA_SIZE;
+
+	/* Multi SPI Tx transfer*/
+	/*if One SPI Rx recv*/
+	while (last_packet == false) {
+		/* One SPI Rx recv*/
+		if (use_total_count <= max_reg_count) {
+			/* Set reg count*/
+			reg_count = use_total_count;
+			/* Set last packet*/
+			last_packet = true;
+		} else {
+			/*Multi SPI Rx recv*/
+			reg_count = max_reg_count;
+		}
+		/* Update expect size*/
+		total_len += reg_count*ISP_REGISTER_VALUE;
+
+		/* Add bytes for checksum*/
+		if (last_packet == true)
+			total_len += ISPCMD_CKSUMBYTES;
+
+
+		/* Receive command from slave*/
+		err = ((struct misp_data *)devdata)->intf_fn->recv(
+							devdata, total_len, wait_int);
+		if (err != ERR_SUCCESS)
+			break;
+
+		/* Last packet*/
+		if (last_packet == true) {
+			/* Get checksum*/
+			memcpy(&org_chk_sum,
+			    &rx_buf[(total_len - ISPCMD_CKSUMBYTES)],
+			    ISPCMD_CKSUMBYTES);
+
+			/* Count checksum*/
+			check_sum += isp_mast_calculate_check_sum(
+				&rx_buf[total_ret_size],
+				total_len - ISPCMD_CKSUMBYTES, false);
+			/* Do 2's complement*/
+			check_sum = 65536 - check_sum;
+
+			/* Checksum error*/
+			if (org_chk_sum != check_sum)	{
+				/* Set error code*/
+				err = ERR_MASTERCMDCKSM_INVALID;
+				break;
+			}
+		} else {
+			/* Normal packet*/
+			/* checksum is valid or not*/
+			check_sum += isp_mast_calculate_check_sum(
+				&rx_buf[total_ret_size], total_len,
+				false);
+		}
+
+		/* Update total count*/
+		use_total_count -= reg_count;
+		/* Update total ret size*/
+		total_ret_size += total_len;
+
+		/* Reset expect size*/
+		total_len = 0;
+		/* Update max reg count*/
+		max_reg_count = 16;
+
+	}
+
+
+	#ifdef OUTPUT_ISP_REGISTER
+	/*write out the buffer to .arw file here*/
+	#endif
+
+
+	return err;
+
+}
+
+/******Private Function******/
+
+
+/**
+ *\brief Execute system manage command
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+static errcode execute_system_manage_cmd(void *devdata, u16 opcode,
+						u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+
+	/* Get status of Last Executed Command*/
+	if (opcode == ISPCMD_SYSTEM_GET_STATUSOFLASTEXECUTEDCOMMAND)
+		err = mast_sys_manage_cmd_get_status_of_last_exec_command(
+						devdata, opcode, param);
+	else if (opcode == ISPCMD_SYSTEM_GET_ERRORCODE)
+		err = mast_sys_manage_cmd_get_error_code_command(devdata,
+							opcode, param);
+	/* Set ISP register*/
+	else if (opcode == ISPCMD_SYSTEM_SET_ISPREGISTER)
+		err = mast_sys_manage_cmd_set_isp_register(devdata,
+							opcode,	param);
+	/* Get ISP register*/
+	else if (opcode == ISPCMD_SYSTEM_GET_ISPREGISTER)
+		err = mast_sys_manage_cmd_get_isp_register(devdata,
+							opcode,	param);
+	/* Set common log level*/
+	else if (opcode == ISPCMD_SYSTEM_SET_COMLOGLEVEL)
+		err = mast_sys_manage_cmd_set_comomn_log_level(devdata,
+							opcode,	param);
+	/*Get chip test report*/
+	else if (opcode == ISPCMD_SYSTEM_GET_CHIPTESTREPORT)
+		err = mast_sys_manage_cmd_get_chip_test_report(devdata,
+							opcode, param);
+	return err;
+
+}
+
+/**
+ *\brief Execute basic setting command
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+static errcode execute_basic_setting_cmd(void *devdata, u16 opcode,
+					u8 *param)
+{
+	/*Error Code*/
+	errcode err = ERR_SUCCESS;
+
+
+	/* Set Depth 3A info*/
+	if (opcode == ISPCMD_BASIC_SET_DEPTH_3A_INFO)
+		err = mast_basic_setting_cmd_set_depth_3a_info(devdata,
+								opcode, param);
+	/* Set Depth Auto interleave mode*/
+	else if (opcode == ISPCMD_BASIC_SET_DEPTH_AUTO_INTERLEAVE_MODE)
+		err = mast_basic_setting_cmd_set_depth_auto_interleave_mode(
+			devdata, opcode, param);
+	/* Set Depth Auto interleave mode*/
+	else if (opcode == ISPCMD_BASIC_SET_INTERLEAVE_MODE_DEPTH_TYPE)
+		err = mast_basic_setting_cmd_set_interleave_mode_depth_type(
+			devdata, opcode, param);
+	/* Set Depth polish level*/
+	else if (opcode == ISPCMD_BASIC_SET_DEPTH_POLISH_LEVEL)
+		err = mast_basic_setting_cmd_set_depth_polish_level(
+			devdata, opcode, param);
+	return err;
+
+}
+
+/**
+ *\brief Execute bulk data command
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+static errcode execute_bulk_data_cmd(void *devdata,
+				u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 *block_size;
+	char filename[ISPCMD_FILENAME_SIZE];
+	struct misp_global_variable *dev_global_variable;
+	dev_global_variable = get_mini_isp_global_variable();
+
+	memcpy(filename, param, ISPCMD_FILENAME_SIZE);
+
+
+	misp_info("execute_bulk_data_cmd - start ============");
+
+	/*set the size*/
+	block_size = (u32 *)&param[8];
+
+	if (opcode == ISPCMD_BULK_WRITE_BOOTCODE) {
+		/* Write Boot Code*/
+		misp_info("%s : write BOOT_CODE", __func__);
+
+		dev_global_variable->before_booting = 1;
+		*block_size = MASTERTX_BLOCK_SIZE;
+
+#ifndef AL6100_SPI_NOR
+		err = mast_bulk_data_cmd_write_boot_code(devdata, param,
+				g_filp[BOOT_CODE]);
+#endif
+
+		dev_global_variable->before_booting = 0;
+	} else if (opcode == ISPCMD_BULK_WRITE_BASICCODE) {
+		/* Write Basic Code*/
+		misp_info("%s : write BASIC_CODE", __func__);
+
+#ifndef AL6100_SPI_NOR
+		err = mast_bulk_data_cmd_write_basic_code(devdata, param,
+				g_filp[BASIC_CODE]);
+#endif
+
+	} else if (opcode == ISPCMD_BULK_WRITE_CALIBRATION_DATA) {
+		/*Write Calibration Data*/
+		if (param[8] == 0) {
+			misp_info("%s : write IQ_CALIBRATION_DATA", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, NULL);
+		} else if (param[8] == 1) {
+			misp_info("%s : write DEPTH_CALIBRATION_DATA", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, NULL);
+		} else if (param[8] == 2) {
+			misp_info("%s : write SCENARIO_CODE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, g_filp[SCENARIO_CODE]);
+		} else if (param[8] == 3) {
+			misp_info("%s : write HDR_CODE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, g_filp[HDR_CODE]);
+		} else if (param[8] == 4) {
+			misp_info("%s : write IRP0_CODE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, g_filp[IRP0_CODE]);
+		} else if (param[8] == 5) {
+			misp_info("%s : write IRP1_CODE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, g_filp[IRP1_CODE]);
+		} else if (param[8] == 6) {
+			misp_info("%s : write PPMAP_CODE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+					devdata, param, g_filp[PPMAP_CODE]);
+		} else if (param[8] == 7) {
+			misp_info("%s : write BLENDING_TABLE", __func__);
+			err = mast_bulk_data_cmd_write_calibration_data(
+							devdata, param, NULL);
+	}
+    /* Read Calibration Data*/
+	else if (opcode == ISPCMD_BULK_READ_MEMORY)
+		err = mast_bulk_data_cmd_read_memory_data(devdata, param);
+	} else if (opcode == ISPCMD_BULK_READ_COMLOG) {
+		/* Read Common Log Data*/
+		err = bulk_data_cmd_read_common_log(devdata, param);
+	}
+
+	misp_info("execute_bulk_data_cmd - end Errcode: %d ============", (int)err);
+
+	return err;
+
+}
+
+/**
+ *\brief Execute camera profile command
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+static errcode execute_camera_profile_cmd(void *devdata, u16 opcode,
+					u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+
+	/* Set Sensor Mode*/
+	if (opcode == ISPCMD_CAMERA_SET_SENSORMODE)
+		err = mast_camera_profile_cmd_set_sensor_mode(devdata,
+							opcode, param);
+	/* Get Sensor Mode*/
+	else if (opcode == ISPCMD_CAMERA_GET_SENSORMODE)
+		err = mast_camera_profile_cmd_get_sensor_mode(devdata,
+							opcode, param);
+	/*Set Output format*/
+	else if (opcode == ISPCMD_CAMERA_SET_OUTPUTFORMAT)
+		err = mast_camera_profile_cmd_set_output_format(devdata,
+							opcode, param);
+	/*Set CP Mode*/
+	else if (opcode == ISPCMD_CAMERA_SET_CP_MODE)
+		err = mast_camera_profile_cmd_set_cp_mode(devdata,
+							opcode, param);
+	/* Preview stream on*/
+	else if (opcode == ISPCMD_CAMERA_PREVIEWSTREAMONOFF)
+		err = mast_camera_profile_cmd_preview_stream_on_off(
+						devdata, opcode, param);
+	/* Set AE statistic*/
+	else if (opcode == ISPCMD_CAMERA_SET_AE_STATISTICS)
+		err = mast_basic_setting_cmd_set_ae_statistics(
+						devdata, opcode, param);
+	/* Dual PD Y calculation weightings*/
+	else if (opcode == ISPCMD_CAMERA_DUALPDYCALCULATIONWEIGHT)
+		err = mast_camera_profile_cmd_dual_pd_y_cauculation_weightings(
+						devdata, opcode, param);
+	/* LED power control*/
+	else if (opcode == ISPCMD_LED_POWERCONTROL)
+		err = mast_camera_profile_cmd_led_power_control(
+						devdata, opcode, param);
+	/* Active AE*/
+	else if (opcode == ISPCMD_CAMERA_ACTIVE_AE)
+		err = mast_camera_profile_cmd_active_ae(
+						devdata, opcode, param);
+	/* ISP AE Control*/
+	else if (opcode == ISPCMD_ISP_AECONTROLONOFF)
+		err = mast_camera_profile_cmd_isp_ae_control_on_off(
+						devdata, opcode, param);
+	/* Set Frame Rate Limits*/
+	else if (opcode == ISPCMD_CAMERA_SET_FRAMERATELIMITS)
+		err = mast_camera_profile_cmd_set_frame_rate_limits(
+						devdata, opcode, param);
+	/* Set Period Drop Frame*/
+	else if (opcode == ISPCMD_CAMERA_SET_PERIODDROPFRAME)
+		err = mast_camera_profile_cmd_set_period_drop_frame(
+						devdata, opcode, param);
+	/* Set Max exposure*/
+	else if (opcode == ISPCMD_CAMERA_SET_MAX_EXPOSURE)
+		err = mast_camera_profile_cmd_set_max_exposure(
+						devdata, opcode, param);
+	/* Set AE Target Mean*/
+	else if (opcode == ISPCMD_CAMERA_SET_AE_TARGET_MEAN)
+		err = mast_camera_profile_cmd_set_target_mean(
+						devdata, opcode, param);
+	else
+		misp_err("%s : unknown opcode: %#04x", __func__, opcode);
+	return err;
+
+}
+
+/**
+ *\brief Execute operation command
+ *\param devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+static errcode execute_operation_cmd(void *devdata,
+				u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+
+	/* mini_isp_drv_open*/
+	if (opcode == ISPCMD_MINIISPOPEN)
+		err = mast_operation_cmd_miniisp_open(devdata,
+						opcode, param);
+
+	return err;
+
+}
+
+static u16 isp_mast_calculate_check_sum(u8 *input_buffer_addr,
+					u16 input_buffer_size, bool b2sCom)
+{
+	u16 i;
+	u32 sum = 0;
+	u16 sumvalue;
+
+	for (i = 0; i < input_buffer_size; i++) {
+		if (0 == (i%2))
+			sum += input_buffer_addr[i];
+		else
+			sum += (input_buffer_addr[i] << 8);
+	}
+
+	/* Do 2's complement*/
+	if (b2sCom == true)
+		sumvalue = (u16) (65536 - (sum & 0x0000FFFF));
+	/* Update total sum*/
+	else
+		sumvalue = sum;
+
+	return sumvalue;
+}
+
+
+
+static ssize_t ispctrl_if_mast_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int status = 0;
+
+	if (attr == &dev_attr_ispctrl_config) {
+		/* status = snprintf(buf, PAGE_SIZE,"Rx_buffer[0]:%d,
+		 *         Rx_buffer[1]:%d, Rx_buffer[2]:%d Rx_buffer[3]:%d",
+		 *
+		 * g_aucRxCMDBuf[0],g_aucRxCMDBuf[1],g_aucRxCMDBuf[2],
+		 *          g_aucRxCMDBuf[3]);
+		 */
+	} else {
+		status = -EINVAL;
+	}
+	return status;
+}
+
+static ssize_t ispctrl_if_mast_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	u8 t_buf[62];
+	u16 *opcode;
+	u8 *param;
+
+	if (count > 0 && count <= 62) {
+		memcpy(t_buf, buf, count);
+		opcode = (u16 *)&t_buf[0];
+		param = &t_buf[2];
+		ispctrl_if_mast_execute_cmd(*opcode, param);
+	}
+
+	return count;
+}
+
+module_init(ispctrl_if_mast_init);
+module_exit(ispctrl_if_mast_exit);
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+/******End Of File******/
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_chip_base_define.c b/drivers/media/platform/msm/camera/al6100/miniisp_chip_base_define.c
new file mode 100644
index 0000000..b6f298e
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_chip_base_define.c
@@ -0,0 +1,615 @@
+/*
+ * File: miniisp_chip_base_define.c.c
+ * Description: Mini ISP ChipBase Define Code
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/10/18; Louis Wang; Initial version
+ */
+ /******Include File******/
+#include "linux/init.h"
+#include "linux/module.h"
+
+#include "include/miniisp.h"
+#include "include/error.h"
+#include "include/miniisp_chip_base_define.h"
+
+
+#define MINI_ISP_LOG_TAG	"[miniisp_chip_base_define]"
+
+/******Private Variable******/
+static u32 clk_gen_array[] = clk_gen_dump_field;
+static u32 mipi_tx_phy_if_0_array[] = mipi_tx_phy_if_0_dump_field;
+static u32 mipi_tx_phy_if_1_array[] = mipi_tx_phy_if_1_dump_field;
+static u32 gen_reg_array[] = gen_reg_dump_field;
+static u32 mipi_slvds_rx_phy_if_0_array[] = mipi_slvds_rx_phy_if_0_dump_field;
+static u32 mipi_slvds_rx_phy_if_1_array[] = mipi_slvds_rx_phy_if_1_dump_field;
+static u32 ppi_bridge_a_0_array[] = ppi_bridge_a_0_dump_field;
+static u32 ppi_bridge_a_1_array[] = ppi_bridge_a_1_dump_field;
+static u32 tx_top_out_mux_a_0_array[] = tx_top_out_mux_a_0_dump_field;
+static u32 tx_top_out_mux_a_1_array[] = tx_top_out_mux_a_1_dump_field;
+static u32 tx_line_merge_21_a_0_array[] = tx_line_merge_21_a_0_dump_field;
+static u32 tx_line_merge_21_b_0_array[] = tx_line_merge_21_b_0_dump_field;
+static u32 tx_line_merge_21_c_0_array[] = tx_line_merge_21_c_0_dump_field;
+static u32 tx_line_merge_21_d_0_array[] = tx_line_merge_21_d_0_dump_field;
+static u32 mipi_csi2_tx_0_array[] = mipi_csi2_tx_0_dump_field;
+static u32 mipi_csi2_tx_1_array[] = mipi_csi2_tx_1_dump_field;
+static u32 gen_reg_depth_top_array[] = gen_reg_depth_top_dump_field;
+static u32 gen_reg_dpc_top_array[] = gen_reg_dpc_top_dump_field;
+static u32 gen_reg_hdr_top_array[] = gen_reg_hdr_top_dump_field;
+static u32 gen_reg_irp_top_array[] = gen_reg_irp_top_dump_field;
+static u32 gen_reg_standby_top_array[] = gen_reg_standby_top_dump_field;
+static u32 gen_reg_tx_top_array[] = gen_reg_tx_top_dump_field;
+static u32 id_det_a_0_array[] = id_det_a_0_dump_field;
+static u32 id_det_a_1_array[] = id_det_a_1_dump_field;
+static u32 bayer_binning_a_0_array[] = bayer_binning_a_0_dump_field;
+static u32 bayer_binning_a_1_array[] = bayer_binning_a_1_dump_field;
+static u32 bayer_scl_a_0_array[] = bayer_scl_a_0_dump_field;
+static u32 bayer_scl_a_1_array[] = bayer_scl_a_1_dump_field;
+static u32 rlb_a_0_array[] = rlb_a_0_dump_field;
+static u32 rlb_b_0_array[] = rlb_b_0_dump_field;
+static u32 mipi_csi2_rx_0_array[] = mipi_csi2_rx_0_dump_field;
+static u32 mipi_csi2_rx_1_array[] = mipi_csi2_rx_1_dump_field;
+static u32 dg_ca_a_0_array[] = dg_ca_a_0_dump_field;
+static u32 dg_mcc_a_0_array[] = dg_mcc_a_0_dump_field;
+static u32 dp_top_a_0_array[] = dp_top_a_0_dump_field;
+static u32 lvhwirp_top_a_0_array[] = lvhwirp_top_a_0_dump_field;
+static u32 lvhwirp_top_b_0_array[] = lvhwirp_top_b_0_dump_field;
+static u32 lvlumanr_a_0_array[] = lvlumanr_a_0_dump_field;
+static u32 lvlumanr_a_1_array[] = lvlumanr_a_1_dump_field;
+static u32 lvsharp_a_0_array[] = lvsharp_a_0_dump_field;
+static u32 lvsharp_a_1_array[] = lvsharp_a_1_dump_field;
+static u32 rectify_a_0_array[] = rectify_a_0_dump_field;
+static u32 rectify_b_0_array[] = rectify_b_0_dump_field;
+
+/******Private Function******/
+
+static void mini_isp_chip_base_define_module_reg_dump(char *module_name)
+{
+	int i = 0;
+
+	/*clk_gen*/
+	if (strcmp(module_name, "clk_gen") == 0)
+		for (i = 0; i < sizeof(clk_gen_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				clk_gen_array[i],
+				clk_gen_array[i+1],
+				module_name);
+	/*mipi_tx_phy_if_0*/
+	else if (strcmp(module_name, "mipi_tx_phy_if_0") == 0)
+		for (i = 0; i < sizeof(mipi_tx_phy_if_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_tx_phy_if_0_array[i],
+				mipi_tx_phy_if_0_array[i+1],
+				module_name);
+	/*mipi_tx_phy_if_1*/
+	else if (strcmp(module_name, "mipi_tx_phy_if_1") == 0)
+		for (i = 0; i < sizeof(mipi_tx_phy_if_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_tx_phy_if_1_array[i],
+				mipi_tx_phy_if_1_array[i+1],
+				module_name);
+	/*gen_reg*/
+	else if (strcmp(module_name, "gen_reg") == 0)
+		for (i = 0; i < sizeof(gen_reg_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_array[i],
+				gen_reg_array[i+1],
+				module_name);
+	/*mipi_slvds_rx_phy_if_0*/
+	else if (strcmp(module_name, "mipi_slvds_rx_phy_if_0") == 0)
+		for (i = 0;
+			i < sizeof(mipi_slvds_rx_phy_if_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_slvds_rx_phy_if_0_array[i],
+				mipi_slvds_rx_phy_if_0_array[i+1],
+				module_name);
+	/*mipi_slvds_rx_phy_if_1*/
+	else if (strcmp(module_name, "mipi_slvds_rx_phy_if_1") == 0)
+		for (i = 0;
+			i < sizeof(mipi_slvds_rx_phy_if_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_slvds_rx_phy_if_1_array[i],
+				mipi_slvds_rx_phy_if_1_array[i+1],
+				module_name);
+	/*ppi_bridge_a_0*/
+	else if (strcmp(module_name, "ppi_bridge_a_0") == 0)
+		for (i = 0; i < sizeof(ppi_bridge_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				ppi_bridge_a_0_array[i],
+				ppi_bridge_a_0_array[i+1],
+				module_name);
+	/*ppi_bridge_a_1*/
+	else if (strcmp(module_name, "ppi_bridge_a_1") == 0)
+		for (i = 0; i < sizeof(ppi_bridge_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				ppi_bridge_a_1_array[i],
+				ppi_bridge_a_1_array[i+1],
+				module_name);
+	/*tx_top_out_mux_a_0*/
+	else if (strcmp(module_name, "tx_top_out_mux_a_0") == 0)
+		for (i = 0; i < sizeof(tx_top_out_mux_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_top_out_mux_a_0_array[i],
+				tx_top_out_mux_a_0_array[i+1],
+				module_name);
+	/*tx_top_out_mux_a_1*/
+	else if (strcmp(module_name, "tx_top_out_mux_a_1") == 0)
+		for (i = 0; i < sizeof(tx_top_out_mux_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_top_out_mux_a_1_array[i],
+				tx_top_out_mux_a_1_array[i+1],
+				module_name);
+	/*tx_line_merge_21_a_0*/
+	else if (strcmp(module_name, "tx_line_merge_21_a_0") == 0)
+		for (i = 0;
+			i < sizeof(tx_line_merge_21_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_line_merge_21_a_0_array[i],
+				tx_line_merge_21_a_0_array[i+1],
+				module_name);
+	/*tx_line_merge_21_b_0*/
+	else if (strcmp(module_name, "tx_line_merge_21_b_0") == 0)
+		for (i = 0;
+			i < sizeof(tx_line_merge_21_b_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_line_merge_21_b_0_array[i],
+				tx_line_merge_21_b_0_array[i+1],
+				module_name);
+	/*tx_line_merge_21_c_0*/
+	else if (strcmp(module_name, "tx_line_merge_21_c_0") == 0)
+		for (i = 0;
+			i < sizeof(tx_line_merge_21_c_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_line_merge_21_c_0_array[i],
+				tx_line_merge_21_c_0_array[i+1],
+				module_name);
+	/*tx_line_merge_21_d_0*/
+	else if (strcmp(module_name, "tx_line_merge_21_d_0") == 0)
+		for (i = 0;
+			i < sizeof(tx_line_merge_21_d_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				tx_line_merge_21_d_0_array[i],
+				tx_line_merge_21_d_0_array[i+1],
+				module_name);
+	/*mipi_csi2_tx_0*/
+	else if (strcmp(module_name, "mipi_csi2_tx_0") == 0)
+		for (i = 0; i < sizeof(mipi_csi2_tx_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_csi2_tx_0_array[i],
+				mipi_csi2_tx_0_array[i+1],
+				module_name);
+	/*mipi_csi2_tx_1*/
+	else if (strcmp(module_name, "mipi_csi2_tx_1") == 0)
+		for (i = 0; i < sizeof(mipi_csi2_tx_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_csi2_tx_1_array[i],
+				mipi_csi2_tx_1_array[i+1],
+				module_name);
+	/*gen_reg_depth_top*/
+	else if (strcmp(module_name, "gen_reg_depth_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_depth_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_depth_top_array[i],
+				gen_reg_depth_top_array[i+1],
+				module_name);
+	/*gen_reg_dpc_top*/
+	else if (strcmp(module_name, "gen_reg_dpc_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_dpc_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_dpc_top_array[i],
+				gen_reg_dpc_top_array[i+1],
+				module_name);
+	/*gen_reg_hdr_top*/
+	else if (strcmp(module_name, "gen_reg_hdr_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_hdr_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_hdr_top_array[i],
+				gen_reg_hdr_top_array[i+1],
+				module_name);
+	/*gen_reg_irp_top*/
+	else if (strcmp(module_name, "gen_reg_irp_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_irp_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_irp_top_array[i],
+				gen_reg_irp_top_array[i+1],
+				module_name);
+	/*gen_reg_standby_top*/
+	else if (strcmp(module_name, "gen_reg_standby_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_standby_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_standby_top_array[i],
+				gen_reg_standby_top_array[i+1],
+				module_name);
+	/*gen_reg_tx_top*/
+	else if (strcmp(module_name, "gen_reg_tx_top") == 0)
+		for (i = 0; i < sizeof(gen_reg_tx_top_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				gen_reg_tx_top_array[i],
+				gen_reg_tx_top_array[i+1],
+				module_name);
+	/*id_det_a_0*/
+	else if (strcmp(module_name, "id_det_a_0") == 0)
+		for (i = 0; i < sizeof(id_det_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				id_det_a_0_array[i],
+				id_det_a_0_array[i+1],
+				module_name);
+	/*id_det_a_1*/
+	else if (strcmp(module_name, "id_det_a_1") == 0)
+		for (i = 0; i < sizeof(id_det_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				id_det_a_1_array[i],
+				id_det_a_1_array[i+1],
+				module_name);
+	/*bayer_binning_a_0*/
+	else if (strcmp(module_name, "bayer_binning_a_0") == 0)
+		for (i = 0; i < sizeof(bayer_binning_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				bayer_binning_a_0_array[i],
+				bayer_binning_a_0_array[i+1],
+				module_name);
+	/*bayer_binning_a_1*/
+	else if (strcmp(module_name, "bayer_binning_a_1") == 0)
+		for (i = 0; i < sizeof(bayer_binning_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				bayer_binning_a_1_array[i],
+				bayer_binning_a_1_array[i+1],
+				module_name);
+	/*bayer_scl_a_0*/
+	else if (strcmp(module_name, "bayer_scl_a_0") == 0)
+		for (i = 0; i < sizeof(bayer_scl_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				bayer_scl_a_0_array[i],
+				bayer_scl_a_0_array[i+1],
+				module_name);
+	/*bayer_scl_a_1*/
+	else if (strcmp(module_name, "bayer_scl_a_1") == 0)
+		for (i = 0; i < sizeof(bayer_scl_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				bayer_scl_a_1_array[i],
+				bayer_scl_a_1_array[i+1],
+				module_name);
+	/*rlb_a_0*/
+	else if (strcmp(module_name, "rlb_a_0") == 0)
+		for (i = 0; i < sizeof(rlb_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				rlb_a_0_array[i],
+				rlb_a_0_array[i+1],
+				module_name);
+	/*rlb_b_0*/
+	else if (strcmp(module_name, "rlb_b_0") == 0)
+		for (i = 0; i < sizeof(rlb_b_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				rlb_b_0_array[i],
+				rlb_b_0_array[i+1],
+				module_name);
+	/*mipi_csi2_rx_0*/
+	else if (strcmp(module_name, "mipi_csi2_rx_0") == 0)
+		for (i = 0; i < sizeof(mipi_csi2_rx_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_csi2_rx_0_array[i],
+				mipi_csi2_rx_0_array[i+1],
+				module_name);
+	/*mipi_csi2_rx_1*/
+	else if (strcmp(module_name, "mipi_csi2_rx_1") == 0)
+		for (i = 0; i < sizeof(mipi_csi2_rx_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				mipi_csi2_rx_1_array[i],
+				mipi_csi2_rx_1_array[i+1],
+				module_name);
+	/*dg_ca_a_0*/
+	else if (strcmp(module_name, "dg_ca_a_0") == 0)
+		for (i = 0; i < sizeof(dg_ca_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				dg_ca_a_0_array[i],
+				dg_ca_a_0_array[i+1],
+				module_name);
+	/*dg_mcc_a_0*/
+	else if (strcmp(module_name, "dg_mcc_a_0") == 0)
+		for (i = 0; i < sizeof(dg_mcc_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				dg_mcc_a_0_array[i],
+				dg_mcc_a_0_array[i+1],
+				module_name);
+	/*dp_top_a_0*/
+	else if (strcmp(module_name, "dp_top_a_0") == 0)
+		for (i = 0; i < sizeof(dp_top_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				dp_top_a_0_array[i],
+				dp_top_a_0_array[i+1],
+				module_name);
+	/*lvhwirp_top_a_0*/
+	else if (strcmp(module_name, "lvhwirp_top_a_0") == 0)
+		for (i = 0; i < sizeof(lvhwirp_top_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvhwirp_top_a_0_array[i],
+				lvhwirp_top_a_0_array[i+1],
+				module_name);
+	/*lvhwirp_top_b_0*/
+	else if (strcmp(module_name, "lvhwirp_top_b_0") == 0)
+		for (i = 0; i < sizeof(lvhwirp_top_b_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvhwirp_top_b_0_array[i],
+				lvhwirp_top_b_0_array[i+1],
+				module_name);
+	/*lvlumanr_a_0*/
+	else if (strcmp(module_name, "lvlumanr_a_0") == 0)
+		for (i = 0; i < sizeof(lvlumanr_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvlumanr_a_0_array[i],
+				lvlumanr_a_0_array[i+1],
+				module_name);
+	/*lvlumanr_a_1*/
+	else if (strcmp(module_name, "lvlumanr_a_1") == 0)
+		for (i = 0; i < sizeof(lvlumanr_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvlumanr_a_1_array[i],
+				lvlumanr_a_1_array[i+1],
+				module_name);
+	/*lvsharp_a_0*/
+	else if (strcmp(module_name, "lvsharp_a_0") == 0)
+		for (i = 0; i < sizeof(lvsharp_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvsharp_a_0_array[i],
+				lvsharp_a_0_array[i+1],
+				module_name);
+	/*lvsharp_a_1*/
+	else if (strcmp(module_name, "lvsharp_a_1") == 0)
+		for (i = 0; i < sizeof(lvsharp_a_1_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				lvsharp_a_1_array[i],
+				lvsharp_a_1_array[i+1],
+				module_name);
+	/*rectify_a_0*/
+	else if (strcmp(module_name, "rectify_a_0") == 0)
+		for (i = 0; i < sizeof(rectify_a_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				rectify_a_0_array[i],
+				rectify_a_0_array[i+1],
+				module_name);
+	/*rectify_b_0*/
+	else if (strcmp(module_name, "rectify_b_0") == 0)
+		for (i = 0; i < sizeof(rectify_b_0_array)/(sizeof(u32));
+			i = i + 2)
+			mini_isp_register_read_then_write_file(
+				rectify_b_0_array[i],
+				rectify_b_0_array[i+1],
+				module_name);
+	else
+		misp_err("%s %s dump field not exit, please add",
+			__func__, module_name);
+}
+
+
+/******Public Function******/
+
+/**
+ *\brief dump bypass mode reg
+ *\descript should use SPI e mode or I2C slave
+ *\return Error code
+ */
+errcode mini_isp_chip_base_dump_bypass_mode_register(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	/*clk_gen*/
+	misp_info("%s clk_gen", __func__);
+	mini_isp_chip_base_define_module_reg_dump("clk_gen");
+	/*mipi_tx_phy_if_0*/
+	misp_info("%s mipi_tx_phy_if_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_tx_phy_if_0");
+	/*mipi_tx_phy_if_1*/
+	misp_info("%s mipi_tx_phy_if_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_tx_phy_if_1");
+	/*gen_reg*/
+	misp_info("%s gen_reg", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg");
+	/*mipi_slvds_rx_phy_if_0*/
+	misp_info("%s mipi_slvds_rx_phy_if_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_slvds_rx_phy_if_0");
+	/*mipi_slvds_rx_phy_if_1*/
+	misp_info("%s mipi_slvds_rx_phy_if_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_slvds_rx_phy_if_1");
+	/*ppi_bridge_a_0*/
+	misp_info("%s ppi_bridge_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("ppi_bridge_a_0");
+	/*ppi_bridge_a_1*/
+	misp_info("%s ppi_bridge_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("ppi_bridge_a_1");
+	return err;
+}
+
+
+/**
+ *\brief dump normal mode reg
+ *\descript should use SPI e mode or I2C slave
+ *\return Error code
+ */
+errcode mini_isp_chip_base_dump_normal_mode_register(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	/*clk_gen*/
+	misp_info("%s clk_gen", __func__);
+	mini_isp_chip_base_define_module_reg_dump("clk_gen");
+	/*tx_top_out_mux_a_0*/
+	misp_info("%s tx_top_out_mux_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_top_out_mux_a_0");
+	/*tx_top_out_mux_a_1*/
+	misp_info("%s tx_top_out_mux_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_top_out_mux_a_1");
+	/*tx_line_merge_21_a_0*/
+	misp_info("%s tx_line_merge_21_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_line_merge_21_a_0");
+	/*tx_line_merge_21_b_0*/
+	misp_info("%s tx_line_merge_21_b_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_line_merge_21_b_0");
+	/*tx_line_merge_21_c_0*/
+	misp_info("%s tx_line_merge_21_c_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_line_merge_21_c_0");
+	/*tx_line_merge_21_d_0*/
+	misp_info("%s tx_line_merge_21_d_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("tx_line_merge_21_d_0");
+	/*mipi_csi2_tx_0*/
+	misp_info("%s mipi_csi2_tx_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_csi2_tx_0");
+	/*mipi_tx_phy_if_0*/
+	misp_info("%s mipi_tx_phy_if_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_tx_phy_if_0");
+	/*mipi_csi2_tx_1*/
+	misp_info("%s mipi_csi2_tx_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_csi2_tx_1");
+	/*mipi_tx_phy_if_1*/
+	misp_info("%s mipi_tx_phy_if_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_tx_phy_if_1");
+	/*gen_reg_depth_top*/
+	misp_info("%s gen_reg_depth_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_depth_top");
+	/*gen_reg_dpc_top*/
+	misp_info("%s gen_reg_dpc_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_dpc_top");
+	/*gen_reg_hdr_top*/
+	misp_info("%s gen_reg_hdr_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_hdr_top");
+	/*gen_reg_irp_top*/
+	misp_info("%s gen_reg_irp_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_irp_top");
+	/*gen_reg_standby_top*/
+	misp_info("%s gen_reg_standby_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_standby_top");
+	/*gen_reg_tx_top*/
+	misp_info("%s gen_reg_tx_top", __func__);
+	mini_isp_chip_base_define_module_reg_dump("gen_reg_tx_top");
+	/*id_det_a_0*/
+	misp_info("%s id_det_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("id_det_a_0");
+	/*id_det_a_1*/
+	misp_info("%s id_det_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("id_det_a_1");
+	/*bayer_binning_a_0*/
+	misp_info("%s bayer_binning_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("bayer_binning_a_0");
+	/*bayer_binning_a_1*/
+	misp_info("%s bayer_binning_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("bayer_binning_a_1");
+	/*bayer_scl_a_0*/
+	misp_info("%s bayer_scl_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("bayer_scl_a_0");
+	/*bayer_scl_a_1*/
+	misp_info("%s bayer_scl_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("bayer_scl_a_1");
+	/*rlb_a_0*/
+	misp_info("%s rlb_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("rlb_a_0");
+	/*rlb_b_0*/
+	misp_info("%s rlb_b_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("rlb_b_0");
+	/*mipi_slvds_rx_phy_if_0*/
+	misp_info("%s mipi_slvds_rx_phy_if_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_slvds_rx_phy_if_0");
+	/*mipi_csi2_rx_0*/
+	misp_info("%s mipi_csi2_rx_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_csi2_rx_0");
+	/*mipi_slvds_rx_phy_if_1*/
+	misp_info("%s mipi_slvds_rx_phy_if_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_slvds_rx_phy_if_1");
+	/*mipi_csi2_rx_1*/
+	misp_info("%s mipi_csi2_rx_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("mipi_csi2_rx_1");
+	/*ppi_bridge_a_0*/
+	misp_info("%s ppi_bridge_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("ppi_bridge_a_0");
+	/*ppi_bridge_a_1*/
+	misp_info("%s ppi_bridge_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("ppi_bridge_a_1");
+
+	return err;
+}
+
+/**
+ *\brief dump irp and depth based reg
+ *\descript should use SPI e mode or I2C slave
+ *\return Error code
+ */
+errcode mini_isp_chip_base_dump_irp_and_depth_based_register(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	/*dg_ca_a_0*/
+	misp_info("%s dg_ca_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("dg_ca_a_0");
+	/*dg_mcc_a_0*/
+	misp_info("%s dg_mcc_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("dg_mcc_a_0");
+	/*dp_top_a_0*/
+	misp_info("%s dp_top_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("dp_top_a_0");
+	/*lvhwirp_top_a_0*/
+	misp_info("%s lvhwirp_top_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvhwirp_top_a_0");
+	/*lvhwirp_top_b_0*/
+	misp_info("%s lvhwirp_top_b_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvhwirp_top_b_0");
+	/*lvlumanr_a_0*/
+	misp_info("%s lvlumanr_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvlumanr_a_0");
+	/*lvlumanr_a_1*/
+	misp_info("%s lvlumanr_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvlumanr_a_1");
+	/*lvsharp_a_0*/
+	misp_info("%s lvsharp_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvsharp_a_0");
+	/*lvsharp_a_1*/
+	misp_info("%s lvsharp_a_1", __func__);
+	mini_isp_chip_base_define_module_reg_dump("lvsharp_a_1");
+	/*rectify_a_0*/
+	misp_info("%s rectify_a_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("rectify_a_0");
+	/*rectify_b_0*/
+	misp_info("%s rectify_b_0", __func__);
+	mini_isp_chip_base_define_module_reg_dump("rectify_b_0");
+	return err;
+}
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_ctrl.c b/drivers/media/platform/msm/camera/al6100/miniisp_ctrl.c
new file mode 100644
index 0000000..8b7c99e
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_ctrl.c
@@ -0,0 +1,1367 @@
+/*
+ * File: miniisp_ctrl.c
+ * Description: Mini ISP Ctrl sample codes
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/******Include File******/
+#include <linux/delay.h>
+
+#include "include/miniisp_customer_define.h"
+#include "include/ispctrl_if_master.h"
+#include "include/miniisp_ctrl.h"
+#include "include/altek_statefsm.h"
+#include "include/error/altek_state_err.h"
+#include "include/miniisp_chip_base_define.h"
+/******Private Constant Definition******/
+#define MINI_ISP_LOG_TAG	"[miniisp_ctrl]"
+
+/******Private Function Prototype******/
+
+static int load_code_task(void *data);
+static u16 calibration_check_sum(u8 *input_buffer_addr, u16 input_buffer_size);
+
+/******Private Type Declaration******/
+
+
+/******Private Global Variable******/
+
+static struct memmory_dump_hdr_info mem_dum_hdr_cfg = {0};
+static struct common_log_hdr_info  com_log_hdr_cfg = {0};
+static bool stop_to_log;
+
+/*Command parameter buffer*/
+static u8 cmd_param_buf[T_SPI_CMD_LENGTH];
+static u8 rcv_cmd_param_buf[T_SPI_CMD_LENGTH];
+
+
+static bool load_code_ready;
+
+/******Public Global Variable******/
+
+
+/******Public Function******/
+
+/*************************************************************************/
+/*operation cmd*/
+
+/**
+ *\brief Mini ISP open 0x4000
+ *\param boot_code_file_name [In], Boot code filename
+ *\param basic_code_file_name [In], Basic code filename
+ *\param advanced_code_file_name [In], Advanced code filename
+ *\param scenario_table_file_name [In], SC table filename
+ *\param hdr_qmerge_data_file_name [In], HDR Qmerge data filename
+ *\param irp0_qmerge_data_file_name [In], IRP0 Qmerge data filename
+ *\param irp1_qmerge_data_file_name [In], IRP1 Qmerge data filename
+ *\param pp_map_file_name [In], pp map filename
+ *\return Error code
+ */
+errcode mini_isp_drv_open(char *boot_code_file_name,
+				char *basic_code_file_name,
+				char *advanced_code_file_name,
+				char *scenario_table_file_name,
+				char *hdr_qmerge_data_file_name,
+				char *irp0_qmerge_data_file_name,
+				char *irp1_qmerge_data_file_name,
+				char *pp_map_file_name)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_MINIISPOPEN; /*0x4000*/
+	u64 bootPath, basicPath, advPath, scenarioPath;
+	u64 hdrPath, irp0Path, irp1Path, ppmapPath;
+
+	bootPath  = (u64)boot_code_file_name;
+	basicPath = (u64)basic_code_file_name;
+	advPath   = (u64)advanced_code_file_name;
+	scenarioPath  = (u64)scenario_table_file_name;
+	hdrPath  = (u64)hdr_qmerge_data_file_name;
+	irp0Path  = (u64)irp0_qmerge_data_file_name;
+	irp1Path  = (u64)irp1_qmerge_data_file_name;
+	ppmapPath  = (u64)pp_map_file_name;
+
+	/* Command parameter buffer*/
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	misp_info("%s - start", __func__);
+	/* Parameter 0 boot code filename*/
+	memcpy(&cmd_param_buf[0], &bootPath, 8);
+	/* Parameter 1 basic code filename*/
+	memcpy(&cmd_param_buf[8], &basicPath, 8);
+	/* Parameter 2 advanced code filename*/
+	memcpy(&cmd_param_buf[16], &advPath, 8);
+	/* Parameter 3 calibration filename(sc atable)*/
+	memcpy(&cmd_param_buf[24], &scenarioPath, 8);
+	/* Parameter 4 hdr qmerge data filename*/
+	memcpy(&cmd_param_buf[32], &hdrPath, 8);
+	/* Parameter 5 irp0 qmerge data filename*/
+	memcpy(&cmd_param_buf[40], &irp0Path, 8);
+	/* Parameter 6 irp1 qmerge data filename*/
+	memcpy(&cmd_param_buf[48], &irp1Path, 8);
+	/* Parameter 7 PP map filename*/
+	memcpy(&cmd_param_buf[56], &ppmapPath, 8);
+
+
+	/* mini ISP open*/
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	if (err != ERR_SUCCESS)
+		misp_err("%s open file failed. err: 0x%x", __func__, err);
+
+	misp_info("%s - open files success", __func__);
+
+	return err;
+
+}
+
+/*************************************************************************/
+/*bulk cmd*/
+
+/**
+ *\brief Mini ISP write boot code 0x2008
+ *\return Error code
+ */
+errcode mini_isp_drv_write_boot_code(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u16 opcode = ISPCMD_BULK_WRITE_BOOTCODE; /*0x2008*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+	misp_info("%s write boot code state: %d", __func__, err);
+
+	return err;
+}
+
+/**
+ *\brief Mini ISP write basic code 0x2002
+ *\return Error code
+ */
+errcode mini_isp_drv_write_basic_code(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u16 opcode = ISPCMD_BULK_WRITE_BASICCODE; /*0x2002*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	misp_info("%s write basic code state: %d", __func__, err);
+
+	if (err == ERR_SUCCESS)
+		dev_global_variable->now_state = 3;
+	return err;
+}
+
+
+/**
+ *\brief MiniISP Write Calibration Data   0x210B
+ *\param info_id [In],		0   :  otp data
+ *				1   :  packet data
+ *				2   :  scenario table
+ *				3   :  qmerge hdr
+ *				4   :  qmerge irp0
+ *				5   :  qmerge irp1
+ *				6   :  PP map
+ *				7   :  blending table
+ *\param buf_addr [In], otp/packet data buffer start address
+ *\param buf_len [In], otp/packet data buffer len
+ *\return Error code
+ */
+errcode mini_isp_drv_write_calibration_data(u8 info_id, u8 *buf_addr,
+					u32 buf_len)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u16 opcode = ISPCMD_BULK_WRITE_CALIBRATION_DATA; /*0x210B*/
+	u16 chk_sum;
+	u32 block_size = 384*1024;
+	u8 *allocated_memmory = 0;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/*
+	 *misp_info("%s info_id %d  buf_addr %p buf_len %d",
+	 *	__func__, info_id, buf_addr, buf_len);
+	 */
+	/* Parameter 0 Info ID*/
+	cmd_param_buf[8] = info_id;
+	if ((info_id >= 2) && (info_id < 7)) {
+		err = ispctrl_if_mast_execute_cmd(opcode,
+						cmd_param_buf);
+	} else {
+		/*  Request memory*/
+		allocated_memmory = kzalloc(buf_len+T_SPI_CMD_LENGTH,
+					GFP_KERNEL);
+		if (!allocated_memmory) {
+			err = ~ERR_SUCCESS;
+			goto allocate_memory_fail;
+		}
+		memcpy(allocated_memmory + T_SPI_CMD_LENGTH, buf_addr,
+			buf_len);
+		memcpy(allocated_memmory, &buf_len, sizeof(u32));
+		memcpy(allocated_memmory + 4, &block_size, sizeof(u32));
+		memcpy(allocated_memmory + 8, &info_id, sizeof(u8));
+		chk_sum = calibration_check_sum(
+			allocated_memmory + T_SPI_CMD_LENGTH,
+			buf_len);
+		memcpy(allocated_memmory+9, &chk_sum, sizeof(u16));
+		/*
+		 *misp_info("%s Cal_param[0][1][2][3]:%02x %02x %02x %02x",
+		 *		__func__, allocated_memmory[0],
+		 *		allocated_memmory[1],
+		 *		allocated_memmory[2],
+		 *		allocated_memmory[3]);
+		 *misp_info("%s Cal_param[4][5][6][7]:%02x %02x %02x %02x",
+		 *		__func__, allocated_memmory[4],
+		 *		allocated_memmory[5],
+		 *		allocated_memmory[6],
+		 *		allocated_memmory[7]);
+		 *misp_info("%s Cal_param[8][9][10]:%02x %02x %02x",
+		 *		__func__, allocated_memmory[8],
+		 *		allocated_memmory[9],
+		 *		allocated_memmory[10]);
+		 */
+		err = ispctrl_if_mast_execute_cmd(opcode,
+					allocated_memmory);
+		kfree(allocated_memmory);
+	}
+	misp_info("%s write calibration data state: %d", __func__, err);
+
+
+	goto miniisp_drv_write_calibration_data_end;
+allocate_memory_fail:
+	misp_err("%s Allocate memory failed.", __func__);
+	kfree(allocated_memmory);
+miniisp_drv_write_calibration_data_end:
+
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_write_calibration_data);
+
+/**
+ *\brief Read memory
+ *\param start_addr [In]starting address
+ *\param read_size [In]TotalReadSize
+ *\return Error code
+ */
+errcode mini_isp_drv_read_memory(u32 start_addr, u32 read_size)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_BULK_READ_MEMORY;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	mem_dum_hdr_cfg.start_addr = start_addr;/*0x0;//0x9DC00;*/
+	mem_dum_hdr_cfg.total_size = read_size;/*T_MEMSIZE;*/
+	mem_dum_hdr_cfg.block_size = SPI_TX_BULK_SIZE;
+	mem_dum_hdr_cfg.dump_mode = T_MEMDUMP_CPURUN;
+
+	/*Copy it to transmission header*/
+	memcpy(&cmd_param_buf[0], &mem_dum_hdr_cfg.start_addr,
+		sizeof(struct memmory_dump_hdr_info));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_read_memory);
+
+
+/**
+ *\brief Reading Common Log
+ *\param stop [In], Stop to log flag
+ *\return Error code
+ */
+errcode mini_isp_drv_read_com_log(bool stop)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_BULK_READ_COMLOG;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/* Wait semaphore*/
+	/*SEMAPHORE_LW_Wait( ISPCTRLIFMASTER_SEMAPHORE_LOGDUMP,*/
+	/*	SEMAPHORE_WAITFOREVER );*/
+
+	/* Force to stop log*/
+	/*To inform isp to set log level as 0 for stoping log reight away*/
+	if (stop)
+		mini_isp_drv_set_com_log_level(0);
+
+	if (!stop_to_log) {
+		com_log_hdr_cfg.total_size = LEVEL_LOG_BUFFER_SIZE;
+		com_log_hdr_cfg.block_size = SPI_TX_BULK_SIZE;
+
+		/*Copy it to transmission header*/
+		memcpy(&cmd_param_buf[0], &com_log_hdr_cfg.total_size,
+				sizeof(struct common_log_hdr_info));
+
+		err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+		/* Force to stop log*/
+		if (stop)
+			stop_to_log = true;
+	}
+
+	/* Post semaphore*/
+	/*SEMAPHORE_LW_Post( ISPCTRLIFMASTER_SEMAPHORE_LOGDUMP );*/
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_read_com_log);
+
+/*************************************************************************/
+/*camera profile cmd*/
+
+/**
+ *\brief Set Sensor Mode	0x300A
+ *\param sensor_on_off [In],sensor on/off
+ *\param scenario_id[In], Scenario ID
+ *\param mipi_tx_skew_enable[In],  mipi tx skew on(1)/off(0)
+ *\param ae_weighting_table_index[In]
+ *\return Error code
+ */
+errcode mini_isp_drv_set_sensor_mode(u8 sensor_on_off, u8 scenario_id,
+		u8 mipi_tx_skew_enable, u8 ae_weighting_table_index,
+		u8 merge_mode_enable)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct altek_statefsm *fsm;
+	struct transferdata *param;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	fsm = get_mini_isp_fsm();
+
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+
+	param->opcode = ISPCMD_CAMERA_SET_SENSORMODE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	/* Parameter 0 sensor on/off*/
+	cmd_param_buf[0] = sensor_on_off;
+	/* Parameter 1 Scenario ID*/
+	cmd_param_buf[1] = scenario_id;
+	/* Parameter 2 mipi tx skew on/off*/
+	cmd_param_buf[2] = mipi_tx_skew_enable;
+	/* Parameter 3 ae weighting table index*/
+	cmd_param_buf[3] = ae_weighting_table_index;
+	/* Parameter 4 merge_mode_enable*/
+	cmd_param_buf[4] = merge_mode_enable;
+	/* Parameter 5 reserve*/
+	cmd_param_buf[5] = 0;
+	/* Parameter 6 reserve*/
+	cmd_param_buf[6] = 0;
+	param->data = cmd_param_buf;
+
+	if (sensor_on_off == 0) {
+		err = altek_statefsmispdrv_stop(fsm, param);
+		if (err != 0) {
+			misp_err("%s err, error code = %x",
+				 __func__, err);
+			kfree(param);
+			return err;
+		}
+		dev_global_variable->now_state = 3;
+	} else {
+		err = altek_statefsmispdrv_scenario_chg(fsm, param);
+		if (err != 0) {
+			misp_err("%s err, error code = %x",
+				 __func__, err);
+			kfree(param);
+			return err;
+		}
+		dev_global_variable->now_state = 4;
+	}
+	kfree(param);
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_set_sensor_mode);
+
+/*0x300B*/
+errcode mini_isp_drv_get_sensor_mode(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_GET_SENSORMODE; /*0x300B*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	err = ispctrl_if_mast_execute_cmd(opcode, rcv_cmd_param_buf);
+
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_get_sensor_mode);
+
+/**
+ *\brief Set Output format		0x300D
+ *\param [In]depth_map_setting = resolution | opereation_mode
+ *\resolution
+ *\ 0: Disable depth function (Depth engine is disable)
+ *\ 1: 180p
+ *\ 2: 360p
+ *\ 3: 720p
+ *\ 4: 480p
+ *\opereation_mode,
+ *\ 0x00: DEPTH_BIT_DG_ONLY
+ *\ 0x10: DEPTH_BIT_DP
+ *\ 0x40: DEPTH_BIT_HIGH_DISTORTION_RATE
+ *\
+ *\param [In]depth_process_type: value 0x6 as reserve
+ *\return Error code
+ */
+errcode mini_isp_drv_set_output_format(u8 depth_map_setting,
+	u8 depth_process_type)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_SET_OUTPUTFORMAT; /*0x300D*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/* Parameter 0*/
+	cmd_param_buf[0] = depth_map_setting;
+	/* Parameter 1*/
+	cmd_param_buf[1] = depth_process_type;
+	/* Parameter 2 reserve*/
+	cmd_param_buf[2] = 0;
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_set_output_format);
+
+/**
+ *\brief Set CP mode		0x300E
+ *\return Error code
+ */
+errcode mini_isp_drv_set_cp_mode(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct transferdata *param;
+	struct altek_statefsm *fsm;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	fsm = get_mini_isp_fsm();
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+	param->opcode = ISPCMD_CAMERA_SET_CP_MODE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	param->data = cmd_param_buf;
+
+	err = altek_statefsmispdrv_enter_cp(fsm, param);
+	kfree(param);
+	if (err != 0) {
+		misp_err("%s err, error code = %x",
+				 __func__, err);
+		return err;
+	}
+	dev_global_variable->now_state = 5;
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_set_cp_mode);
+
+/**
+ *\brief Set AE statistics		0x300F
+ *\param ae_statistics [In], ae statistics
+ *\return Error code
+ */
+errcode mini_isp_drv_set_ae_statistics(
+	struct isp_cmd_ae_statistics *ae_statistics)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct transferdata *param;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+	param->opcode = ISPCMD_CAMERA_SET_AE_STATISTICS;
+	param->data = (void *)ae_statistics;
+
+	err = altek_statefsmispdrv_set_qp(fsm, param);
+	kfree(param);
+	if (err != 0)
+		misp_err("%s err, error code = %x", __func__, err);
+
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_set_ae_statistics);
+
+/**
+ *\brief Preview stream on/off		0x3010
+ *\param tx0_stream_on_off [In], Tx0 stream on/off
+ *\param tx1_stream_on_off [In], Tx1 stream on/off
+ *\return Error code
+ */
+errcode mini_isp_drv_preview_stream_on_off(u8 tx0_stream_on_off,
+				u8 tx1_stream_on_off)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct transferdata *param;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+	param->opcode = ISPCMD_CAMERA_PREVIEWSTREAMONOFF;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	/* Parameter 0 Tx0 stream on/off*/
+	cmd_param_buf[0] = tx0_stream_on_off;
+	/* Parameter 1 Tx1 stream on/off*/
+	cmd_param_buf[1] = tx1_stream_on_off;
+	param->data = cmd_param_buf;
+	err = altek_statefsmispdrv_strm_on_off(fsm, param);
+	kfree(param);
+	if (err != 0)
+		misp_err("%s err, error code = %x", __func__, err);
+
+	return err;
+
+
+}
+EXPORT_SYMBOL(mini_isp_drv_preview_stream_on_off);
+
+/**
+ *\brief Dual PD Y Calcualtion Weighting		0x3011
+ *\param isp_cmd_dual_pd_y_calculation_weightings [In],
+   dual PD Y calculation weightings
+ *\return Error code
+ */
+errcode mini_isp_drv_dual_pd_y_calculation_weighting(
+	struct isp_cmd_dual_pd_y_calculation_weightings *calculation_weighting)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_DUALPDYCALCULATIONWEIGHT; /*0x3010*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if (dev_global_variable->now_state != 4)
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, calculation_weighting,
+		sizeof(struct isp_cmd_dual_pd_y_calculation_weightings));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_dual_pd_y_calculation_weighting);
+
+
+/**
+ *\brief LED power control		0x3012
+ *\param projector_control_param [In],
+ *\return Error code
+ */
+errcode mini_isp_drv_led_power_control(
+	struct isp_cmd_led_power_control *projector_control_param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_LED_POWERCONTROL; /*0x3012*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, projector_control_param,
+		sizeof(struct isp_cmd_led_power_control));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_led_power_control);
+
+/**
+ *\brief Active AE		0x3013
+ *\param active_ae_param [In],
+ *\return Error code
+ */
+errcode mini_isp_drv_active_ae(
+	struct isp_cmd_active_ae *active_ae_param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_ACTIVE_AE; /*0x3013*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, active_ae_param,
+		sizeof(struct isp_cmd_active_ae));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_active_ae);
+
+
+/**
+ *\brief  ISP AE control mode on off		0x3014
+ *\param isp_ae_control_mode_on_off [In], 0:off 1:on
+ *\return Error code
+ */
+errcode mini_isp_drv_isp_ae_control_mode_on_off(u8 isp_ae_control_mode_on_off)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_ISP_AECONTROLONOFF; /*0x3014*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	/* Parameter 0 isp_ae_control_mode_on_off*/
+	cmd_param_buf[0] = isp_ae_control_mode_on_off;
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_isp_ae_control_mode_on_off);
+
+/**
+ *\brief  Set Frame Rate Limite		0x3015
+ *\param set_frame_rate_param [In],
+ *\return Error code
+ */
+errcode mini_isp_drv_set_frame_rate_limits(
+	struct isp_cmd_frame_rate_limits *set_frame_rate_param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_SET_FRAMERATELIMITS; /*0x3015*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, set_frame_rate_param,
+		sizeof(struct isp_cmd_frame_rate_limits));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_frame_rate_limits);
+
+/**
+ *\brief  Set period drop frame		0x3016
+ *\param set_period_drop_fram_param [In],
+ *\return Error code
+ */
+errcode mini_isp_drv_set_period_drop_frame(
+	struct isp_cmd_period_drop_frame *set_period_drop_fram_param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_SET_PERIODDROPFRAME; /*0x3016*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, set_period_drop_fram_param,
+		sizeof(struct isp_cmd_period_drop_frame));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_period_drop_frame);
+
+/**
+ *\brief Leave CP Mode
+ *\using set sensor mode opcode :0x300A
+ *\param sensor_on_off [In],sensor on/off
+ *\param scenario_id[In], Scenario ID
+ *\param mipi_tx_skew_enable[In],  mipi tx skew on(1)/off(0)
+ *\param ae_weighting_table_index[In]
+ *\return Error code
+ */
+errcode mini_isp_drv_leave_cp_mode(u8 sensor_on_off, u8 scenario_id,
+		u8 mipi_tx_skew_enable, u8 ae_weighting_table_index,
+		u8 merge_mode_enable)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct misp_global_variable *dev_global_variable;
+	struct transferdata *param;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	dev_global_variable = get_mini_isp_global_variable();
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+	param->opcode = ISPCMD_CAMERA_SET_SENSORMODE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	/* Parameter 0 sensor on/off*/
+	cmd_param_buf[0] = sensor_on_off;
+	/* Parameter 1 Scenario ID*/
+	cmd_param_buf[1] = scenario_id;
+		/* Parameter 2 mipi tx skew on/off*/
+	cmd_param_buf[2] = mipi_tx_skew_enable;
+	/* Parameter 3 ae_weighting_table_index*/
+	cmd_param_buf[3] = ae_weighting_table_index;
+	/* Parameter 4 merge_mode_enable*/
+	cmd_param_buf[4] = merge_mode_enable;
+	/* Parameter 5 reserve*/
+	cmd_param_buf[5] = 0;
+	/* Parameter 6 reserve*/
+	cmd_param_buf[6] = 0;
+	param->data = cmd_param_buf;
+
+	if (sensor_on_off) {
+		err = altek_statefsmispdrv_leave_cp(fsm, param);
+		if (err != 0) {
+			misp_err("mini_isp_drv_leave_cp_mode err, errcode = %x",
+				err);
+			kfree(param);
+			return err;
+		}
+		dev_global_variable->now_state = 4;
+	} else {
+		err = altek_statefsmispdrv_leave_cp_standy(fsm, param);
+		if (err != 0) {
+			misp_err("mini_isp_drv_leave_cp_mode err, errcode = %x",
+				err);
+			kfree(param);
+			return err;
+		}
+		dev_global_variable->now_state = 3;
+	}
+
+	kfree(param);
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_leave_cp_mode);
+
+/*************************************************************************/
+/*system cmd*/
+
+/**
+ *\brief Set ISP register	0x0100
+ *\param a_udStartAddr [In], Reg start addr
+ *\param reg_value [In], Reg value
+ *\return Error code
+ */
+errcode mini_isp_drv_set_isp_register(u32 reg_start_addr, u32 reg_value)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_SET_ISPREGISTER; /*0x0100*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/* Reg start addr*/
+	memcpy(&cmd_param_buf[0], &reg_start_addr, 4);
+	/* Reg count*/
+	memcpy(&cmd_param_buf[4], &reg_value, 4);
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_isp_register);
+
+
+/**
+ *\brief Set ISP register	0x0101
+ *\param a_udStartAddr [In], Reg start addr
+ *\param reg_count [In], Reg count
+ *\return Error code
+ */
+errcode mini_isp_drv_get_isp_register(u32 reg_start_addr, u32 reg_count)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_GET_ISPREGISTER; /*0x0101*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/* Reg start addr*/
+	memcpy(&cmd_param_buf[0], &reg_start_addr, 4);
+	/* Reg count*/
+	memcpy(&cmd_param_buf[4], &reg_count, 4);
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_get_isp_register);
+
+
+errcode mini_isp_drv_set_com_log_level(u32 log_level)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_SET_COMLOGLEVEL;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	memcpy(cmd_param_buf, &log_level, sizeof(u32));
+
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_com_log_level);
+
+/*0x0015*/
+errcode mini_isp_drv_get_last_exec_cmd(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_GET_STATUSOFLASTEXECUTEDCOMMAND; /*0x0015*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	err = ispctrl_if_mast_execute_cmd(opcode, rcv_cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_get_last_exec_cmd);
+
+/*0x0016*/
+errcode mini_isp_drv_get_err_code_cmd(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_GET_ERRORCODE; /*0x0016*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if ((dev_global_variable->now_state != 3) &&
+		(dev_global_variable->now_state != 4))
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	err = ispctrl_if_mast_execute_cmd(opcode, rcv_cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_get_err_code_cmd);
+
+/*0x0016*/
+errcode mini_isp_drv_get_err_code_cmd_in_irq(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	void *devdata = (void *)get_mini_isp_intf(MINIISP_I2C_TOP);
+	u8 param[64];
+	/* Parameter size*/
+	/*get last ten error code and error status*/
+	u32 para_size = (sizeof(errcode))*10;
+
+	misp_err("%s - enter + + + + +", __func__);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, ISPCMD_SYSTEM_GET_ERRORCODE, param, 0);
+	if (err != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_error_code_command_end;
+
+	/* Get data from slave*/
+	err = ispctrl_mast_recv_response_from_slave(devdata, param,
+							para_size, false);
+	if (err != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_error_code_command_end;
+
+	misp_err("%s last error code %#02x %#02x %#02x %#02x", __func__,
+							*(param), *(param+1), *(param+2), *(param+3));
+mast_sys_manage_cmd_get_error_code_command_end:
+
+	misp_err("%s - leave - - - - -", __func__);
+
+	return err;
+}
+
+EXPORT_SYMBOL(mini_isp_drv_get_err_code_cmd_in_irq);
+
+
+/**
+ *\brief Get Chip test Report	0x010A
+ *\return Error code
+ */
+errcode mini_isp_drv_get_chip_test_report(void)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_SYSTEM_GET_CHIPTESTREPORT; /*0x010A*/
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if (dev_global_variable->now_state != 4)
+		return ERR_MINIISP_STATE_ERROR_SEQUENCE;
+	err = ispctrl_if_mast_execute_cmd(opcode, rcv_cmd_param_buf);
+
+	misp_info("%s chip test report: %x %x %x %x", __func__,
+		rcv_cmd_param_buf[0], rcv_cmd_param_buf[1],
+		rcv_cmd_param_buf[2], rcv_cmd_param_buf[3]);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_get_chip_test_report);
+
+/*************************************************************************/
+/*basic cmd*/
+
+/**
+ *\brief Set Depth 3A Information	0x10B9
+ *\param depth_3a_info [In], ISP Depth 3A parameter
+ *\return Error code
+ */
+errcode mini_isp_drv_set_depth_3a_info(
+			struct isp_cmd_depth_3a_info *depth_3a_info)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	struct transferdata *param;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	param = kzalloc(sizeof(struct transferdata), GFP_KERNEL);
+	param->opcode = ISPCMD_BASIC_SET_DEPTH_3A_INFO;
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	/* Copy ISP Depth 3A Info*/
+	memcpy(cmd_param_buf, depth_3a_info,
+		sizeof(struct isp_cmd_depth_3a_info));
+	param->data = cmd_param_buf;
+	err = altek_statefsmispdrv_set_qp(fsm, param);
+	kfree(param);
+	if (err != 0)
+		misp_err("%s err, error code = %x", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_depth_3a_info);
+
+
+/**
+ *\brief Set Depth auto interleave mode	0x10BC
+ *\param depth_auto_interleave_param [In], ISP Depth auto interleave parameter
+ *\return Error code
+ */
+errcode mini_isp_drv_set_depth_auto_interleave_mode(
+	struct isp_cmd_depth_auto_interleave_param *depth_auto_interleave_param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_BASIC_SET_DEPTH_AUTO_INTERLEAVE_MODE; /*0x10BC*/
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+	memcpy(cmd_param_buf, depth_auto_interleave_param,
+		sizeof(struct isp_cmd_depth_auto_interleave_param));
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_depth_auto_interleave_mode);
+
+/**
+ *\brief Set Projector Interleave Mode with Depth Type	0x10BD
+ *\param projector_interleave_mode_with_depth_type [In],
+ *\      0: depth active, 1: depth passive
+ *\return Error code
+ */
+errcode mini_isp_drv_projector_interleave_mode_depth_type(
+	u8 projector_interleave_mode_with_depth_type)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_BASIC_SET_INTERLEAVE_MODE_DEPTH_TYPE; /*0x10BD*/
+
+	cmd_param_buf[0] = projector_interleave_mode_with_depth_type;
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_projector_interleave_mode_depth_type);
+
+/**
+ *\brief Set Depth Polish LEVEL	0x10BE
+ *\param depth_polish_level [In], 0~100
+ *\return Error code
+ */
+errcode mini_isp_drv_set_depth_polish_level(u8 depth_polish_level)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_BASIC_SET_DEPTH_POLISH_LEVEL; /*0x10BE*/
+
+	cmd_param_buf[0] = depth_polish_level;
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_depth_polish_level);
+
+/*************************************************************************/
+
+/*currently not use
+u16 mini_isp_drv_read_spi_status(void)
+{
+	return ispctrl_if_mast_read_spi_status();
+}
+EXPORT_SYMBOL(mini_isp_drv_read_spi_status);
+*/
+
+/**
+ *\brief Write boot code and basic code
+ *\param None
+ *\return None
+ */
+int mini_isp_drv_boot_mini_isp(void)
+{
+	errcode err = ERR_SUCCESS;
+
+
+	/* Write boot code*/
+	err = mini_isp_drv_write_boot_code();
+	if (err != ERR_SUCCESS)
+		goto mini_isp_drv_boot_mini_isp_end;
+
+	udelay(500);
+
+	/* Write basic code*/
+	err = mini_isp_drv_write_basic_code();
+
+mini_isp_drv_boot_mini_isp_end:
+
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_boot_mini_isp);
+
+/**
+ *\brief Open boot and FW file then write boot code and FW code
+ *\param None
+ *\return Error code
+ */
+errcode mini_isp_drv_load_fw(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	misp_info("mini_isp_drv_setting(0) mini_isp_drv_load_fw start");
+	/* Clear load code ready flag;*/
+	load_code_ready = false;
+	/*spi isr task*/
+	/*g_ptload_code_task = kthread_run(load_code_task, NULL, */
+	/*		"miniISP_loadcode_thread");*/
+
+	load_code_task(NULL);
+
+	misp_info("mini_isp_drv_setting(0) mini_isp_drv_load_fw X");
+	return err;
+
+}
+EXPORT_SYMBOL(mini_isp_drv_load_fw);
+
+/**
+ *\brief  Wait miniISP event
+ *\param  e [In], MINI_ISP_EVENT
+ *\return Errorcode
+ */
+int mini_isp_drv_wait_for_event(u16 e)
+{
+	return mini_isp_wait_for_event(e);
+}
+EXPORT_SYMBOL(mini_isp_drv_wait_for_event);
+
+
+/**
+ *\brief Set mode to miniISP
+ *\param  mini_isp_mode [In], Select ISP MODE,
+ *0:(isp already in state A)normal case load FW directly,
+ *1 :(isp state inital in state E)set state E to state A
+ *2 :(isp already in state A)set state A to state E for debug ,
+ *3 :leave HW bypass
+ *4 :Get Chip ID
+ *else : None Support
+ *\return Errorcode
+ */
+errcode mini_isp_drv_setting(u16 mini_isp_mode)
+{
+	errcode err = ERR_SUCCESS;
+	struct misp_global_variable *dev_global_variable;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	dev_global_variable = get_mini_isp_global_variable();
+
+	if (mini_isp_mode == MINI_ISP_MODE_NORMAL) {
+		err = altek_statefsmispdrv_coldboot(fsm, 0);
+		if (err != 0)
+			goto mini_isp_drv_setting_err;
+	} else if (mini_isp_mode == MINI_ISP_MODE_E2A) {
+		/*isp, inital in E,*/
+		mini_isp_e_to_a();
+	} else if (mini_isp_mode == MINI_ISP_MODE_A2E) {
+		mini_isp_a_to_e();
+	} else if (mini_isp_mode == MINI_ISP_MODE_LEAVE_BYPASS) {
+		err = altek_statefsmispdrv_leave_hwpt(fsm, 0);
+		if (err != 0)
+			goto mini_isp_drv_setting_err;
+	} else if (mini_isp_mode == MINI_ISP_MODE_GET_CHIP_ID) {
+		u8 buff_id[4];
+		mini_isp_get_chip_id(CHIP_ID_ADDR, buff_id);
+	} else if (mini_isp_mode == MINI_ISP_MODE_CHIP_INIT) {
+		/*set some reg value to let it know should chang to A*/
+		// For SPI_Nor, do not call this
+		mini_isp_chip_init();
+	} else {
+		misp_err("%s err, none support setting", __func__);
+	}
+	return err;
+mini_isp_drv_setting_err:
+	misp_err("%s err, mini_isp_mode = %d, error code = %x", __func__,
+			mini_isp_mode, err);
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_setting);
+
+/**
+ *\brief Set miniISP using i2c sned signals
+ *\param  mini_isp_i2c_use [In], use i2c send or not,
+ *0:use spi
+ *1:use i2c
+ */
+void mini_isp_drv_send_use_i2c(u8 mini_isp_i2c_use)
+{
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	//dev_global_variable->i2c_enable = mini_isp_i2c_use;
+}
+EXPORT_SYMBOL(mini_isp_drv_send_use_i2c);
+
+void mini_isp_drv_altek_i2c_mode_change(void)
+{
+	mini_isp_register_write(0xffea0100, 0x3201);
+	mini_isp_register_write(0xffea0104, 0x3201);
+}
+EXPORT_SYMBOL(mini_isp_drv_altek_i2c_mode_change);
+
+/**
+ *\brief set bypass mode
+ *\param  bypass_mode [In], Select bypass MODE,
+ *\return Errorcode
+ */
+errcode mini_isp_drv_set_bypass_mode(u16 bypass_mode)
+{
+	errcode err = ERR_SUCCESS;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+
+	if (!fsm) {
+		misp_err("%s ERROR fsm == NULL", __func__);
+		return err;
+	}
+	err = altek_statefsmispdrv_enter_hwpt(fsm, &bypass_mode);
+	if (err != 0)
+		goto mini_isp_drv_setting_err;
+
+	return err;
+mini_isp_drv_setting_err:
+	misp_err("%s err, bypass_mode = %d, error code = %x", __func__,
+			bypass_mode, err);
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_bypass_mode);
+
+/**
+ *\brief set Max exposure
+ *\param  paramlength [In], Select bypass MODE,
+ *\return Errorcode
+ */
+errcode mini_isp_drv_set_max_exposure(u32 max_exposure)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_SET_MAX_EXPOSURE;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	memcpy(cmd_param_buf, &max_exposure, sizeof(u32));
+
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_max_exposure);
+
+/**
+ *\brief set target mean
+ *\param  paramlength [In], Select bypass MODE,
+ *\return Errorcode
+ */
+errcode mini_isp_drv_set_target_mean(u16 target_mean)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Op code*/
+	u16 opcode = ISPCMD_CAMERA_SET_AE_TARGET_MEAN;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	memset(cmd_param_buf, 0, T_SPI_CMD_LENGTH);
+
+	memcpy(cmd_param_buf, &target_mean, sizeof(u16));
+
+
+	err = ispctrl_if_mast_execute_cmd(opcode, cmd_param_buf);
+
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_drv_set_target_mean);
+
+/******Private Function******/
+
+static int load_code_task(void *data)
+{
+	/* Error code*/
+	errcode err = ERR_SUCCESS;
+
+	misp_info("misp_load_fw start");
+
+	/* Reset mini-isp low for at least 200us, release to high for 20ms*/
+	/*mini_isp_reset();*/
+
+	/* Open boot file and FW file*/
+	err = mini_isp_drv_open(BOOT_FILE_LOCATION,
+				BASIC_FILE_LOCATION,
+				ADVANCED_FILE_LOCATION,
+				SCENARIO_TABLE_FILE_LOCATION,
+				HDR_QMERGE_DATA_FILE_LOCATION,
+				IRP0_QMERGE_DATA_FILE_LOCATION,
+				IRP1_QMERGE_DATA_FILE_LOCATION,
+				PP_MAP_FILE_LOCATION);
+	if (err != ERR_SUCCESS)
+		goto load_code_task_end;
+
+
+
+	/* Write boot code and basic code*/
+	err = mini_isp_drv_boot_mini_isp();
+	if (err != ERR_SUCCESS)
+		goto load_code_task_end;
+
+	/* Set load code ready flag*/
+	load_code_ready = true;
+
+load_code_task_end:
+
+	return (int)err;
+}
+
+
+static u16 calibration_check_sum(u8 *input_buffer_addr, u16 input_buffer_size)
+{
+	u16 i;
+	u32 sum = 0;
+	u16 sumvalue;
+
+	/* calculating unit is 2 bytes*/
+	for (i = 0; i < input_buffer_size; i++) {
+		if (0 == (i % 2))
+			sum += input_buffer_addr[i];
+		else
+			sum += (input_buffer_addr[i] << 8);
+	}
+
+	/* Do 2's complement*/
+	sumvalue = (u16)(65536 - (sum & 0x0000FFFF));  /*get 2's complement*/
+
+	return sumvalue;
+}
+
+
+
+
+
+
+/******End Of File******/
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_ctrl_intf.c b/drivers/media/platform/msm/camera/al6100/miniisp_ctrl_intf.c
new file mode 100644
index 0000000..d151bd9
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_ctrl_intf.c
@@ -0,0 +1,421 @@
+/*
+ * File: miniisp_ctrl_intf.c
+ * Description: mini ISP control cmd interface. use for handling the control cmds instead of debug cmds
+ *
+ * (C)Copyright altek Corporation 2018
+ *
+ *  2018/08/28; PhenixChen; Initial version
+ */
+
+/******Include File******/
+//#include <miniISP/miniISP_ioctl.h>
+#include <miniISP/miniISP_ioctl32.h>
+#include <asm-generic/uaccess.h> // copy_*_user()
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h" // mini_isp_drv_setting()
+#include "include/isp_camera_cmd.h" // MINI_ISP_MODE_E2A, MINI_ISP_MODE_NORMAL
+#include "include/ispctrl_if_master.h" // ispctrl_if_mast_execute_cmd()
+#include "include/miniisp_customer_define.h"
+#include "include/miniisp_ctrl_intf.h"
+
+/******Private Constant Definition******/
+#define MINI_ISP_LOG_TAG	"[miniisp_ctrl_intf]"
+
+/******Private Function Prototype******/
+
+/******Public Function Prototype******/
+
+/******Private Global Variable******/
+enum miniisp_mode_state {
+	ISP_POWERED_OFF = 0,
+	ISP_POWERED_ON,
+	ISP_PURE_BYPASS,
+	ISP_CP_MODE,
+};
+
+static int g_isMiniISP_Powered = ISP_POWERED_OFF;
+static int g_isMiniISP_FWLoaded;
+
+// ALTEK_AL6100_CHI >>>
+static int g_isMiniISP_RunAll = 0;
+struct file *internal_file[OTHER_MAX];
+// ALTEK_AL6100_CHI >>>
+
+
+int handle_ControlFlowCmd_II(u16 miniisp_op_code, u8 *param)
+{
+	int retval = 0;
+	misp_info("%s - enter", __func__);
+
+	switch (miniisp_op_code) {
+	case ISPCMD_LOAD_FW:
+		//misp_info("%s - opcode[%u], size[%u], [%u] [%u] [%u] [%u]", __func__, config.opcode, config.size, param[0], param[1], param[2], param[3]);
+
+		misp_info("%s - ISPCMD_LOAD_FW", __func__);
+		//open boot and FW file then write boot code and FW code
+
+		if (g_isMiniISP_Powered == ISP_POWERED_OFF) { //For AL6100 state machine, open state can't be opened again.
+			mini_isp_poweron();
+			g_isMiniISP_Powered = ISP_POWERED_ON;
+		}
+		if (g_isMiniISP_FWLoaded == 0) { // FW  can only be loaded just once if AL6100 didn't be reset.
+			mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID);
+
+#ifndef AL6100_SPI_NOR
+			mini_isp_drv_setting(MINI_ISP_MODE_CHIP_INIT); //if boot form SPI NOR, do not call this
+#endif
+			mini_isp_drv_setting(MINI_ISP_MODE_E2A);
+			mini_isp_drv_setting(MINI_ISP_MODE_NORMAL);
+			g_isMiniISP_FWLoaded = 1;
+		}
+		break;
+	case ISPCMD_PURE_BYPASS:
+		misp_info("%s - ISPCMD_PURE_BYPASS", __func__);
+
+		if (g_isMiniISP_Powered != ISP_POWERED_OFF) {
+			misp_info("%s - miniisp is not in poweroff state", __func__);
+			break;
+		}
+
+		g_isMiniISP_Powered = ISP_PURE_BYPASS;
+		mini_isp_poweron();
+		mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID);
+		mini_isp_drv_set_bypass_mode(1);
+
+		break;
+	case ISPCMD_POWER_OFF:
+		misp_info("%s - ISPCMD_POWER_OFF", __func__);
+
+		if(g_isMiniISP_Powered == ISP_POWERED_ON || g_isMiniISP_Powered == ISP_PURE_BYPASS){
+			mini_isp_poweroff();
+			g_isMiniISP_Powered = ISP_POWERED_OFF;
+		} else {
+			misp_info("%s - miniisp is not in poweron state", __func__);
+		}
+
+		break;
+	default:
+		retval = ispctrl_if_mast_execute_cmd(miniisp_op_code, param);
+		break;
+	}
+	misp_info("%s - leave", __func__);
+	return retval;
+}
+
+//TODO: Need to solve the kernel panic >>>
+
+long handle_ControlFlowCmd(unsigned int cmd, unsigned long arg)
+{
+	long retval = 0;
+	//struct miniISP_cmd_config32 config = {};
+
+	void    *mbuf = NULL;
+	void	*parg = (void *)arg;
+	unsigned int n = _IOC_SIZE(cmd);
+	//u8 param[4];
+
+	misp_info("%s - enter", __func__);
+
+	if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+	misp_info("%s - VERIFY_READ OK!", __func__);
+
+	if (!access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+	misp_info("%s - VERIFY_WRITE OK!", __func__);
+
+	mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+	if (NULL == mbuf)
+		return -ENOMEM;
+
+	parg = mbuf;
+
+	if (copy_from_user(parg, (void __user *)arg, n)) {
+	    retval = -EFAULT;
+	    goto done;
+	 }
+
+	misp_info("%s - n = %u, [%x] [%x] [%x]", __func__, n, *((u8 *)mbuf), *(((u8 *)mbuf) + 1), *(((u8 *)mbuf) + 2));
+
+/*
+	misp_info("%s - before copy from user opcode[%u], size[%u]", __func__, config.opcode, config.size);
+	if (copy_from_user(&config, (void __user *)arg, sizeof(struct miniISP_cmd_config32))) {
+		misp_info("%s - arg copy_from_user fail", __func__);
+		retval = -EFAULT;
+		goto done;
+	}
+	memcpy(&config2, &config,sizeof(struct miniISP_cmd_config32));
+*/
+/*
+	if (copy_from_user(param, (void __user *)(unsigned long)(config.param), config.size)) {
+		misp_info("%s - param copy_from_user fail", __func__);
+		retval = -EFAULT;
+		goto done;
+	}
+*/
+	switch (cmd) {
+	case IOCTL_ISP_LOAD_FW32:
+		//misp_info("%s - opcode[%u], size[%u], [%u] [%u] [%u] [%u]", __func__, config.opcode, config.size, param[0], param[1], param[2], param[3]);
+
+		misp_info("%s - IOCTL_ISP_LOAD_FW", __func__);
+		//open boot and FW file then write boot code and FW code
+
+		if (g_isMiniISP_Powered == ISP_POWERED_OFF) { //For AL6100 state machine, open state can't be opened again.
+			mini_isp_poweron();
+			g_isMiniISP_Powered = ISP_POWERED_ON;
+		}
+		if (g_isMiniISP_FWLoaded == 0) { // FW  can only be loaded just once if AL6100 didn't be reset.
+			mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID);
+
+#ifndef AL6100_SPI_NOR
+			mini_isp_drv_setting(MINI_ISP_MODE_CHIP_INIT); //if boot form SPI NOR, do not call this
+#endif
+			mini_isp_drv_setting(MINI_ISP_MODE_E2A);
+			mini_isp_drv_setting(MINI_ISP_MODE_NORMAL);
+			g_isMiniISP_FWLoaded = 1;
+		}
+		break;
+	case IOCTL_ISP_PURE_BYPASS32:
+		misp_info("%s - IOCTL_ISP_PURE_BYPASS", __func__);
+
+		if (g_isMiniISP_Powered != ISP_POWERED_OFF) {
+			misp_info("%s - miniisp is not in poweroff state", __func__);
+			break;
+		}
+
+		g_isMiniISP_Powered = ISP_PURE_BYPASS;
+		mini_isp_poweron();
+		mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID);
+		mini_isp_drv_set_bypass_mode(1);
+
+		break;
+	case IOCTL_ISP_POWER_OFF32:
+		misp_info("%s - IOCTL_ISP_POWER_OFF32", __func__);
+
+		if(g_isMiniISP_Powered == ISP_POWERED_ON || g_isMiniISP_Powered == ISP_PURE_BYPASS){ //Powered on
+			mini_isp_poweroff();
+			g_isMiniISP_Powered = ISP_POWERED_OFF; //Powered off
+		} else {
+			misp_info("%s - miniisp is not in poweron state", __func__);
+		}
+
+		break;
+	default:
+		misp_info("%s - UNKNOWN CMD[%x], while IOCTL_ISP_LOAD_FW = [%lx], pointer size[%lx]", __func__, cmd, IOCTL_ISP_LOAD_FW, sizeof(void *));
+		retval = -ENOTTY;
+		break;
+	}
+
+done:
+	misp_info("%s - leave", __func__);
+	return retval;
+}
+//TODO: Need to solve the kernel panic <<<
+
+// ALTEK_AL6100_CHI >>>
+void mini_isp_other_drv_open(char *file_name, u8 type) {
+
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	misp_info("%s filepath : %s", __func__, file_name);
+
+	internal_file[type] = filp_open(file_name, O_RDONLY, 0644);
+	set_fs(oldfs);
+
+	if (IS_ERR(internal_file[type])) {
+		err = PTR_ERR(internal_file[type]);
+		misp_err("%s open file failed. err: %x", __func__, err);
+	} else {
+		misp_info("%s open file success!", __func__);
+	}
+}
+
+void mini_isp_other_drv_read(struct file *filp, u8 type) {
+	static u8 *calibration_data_buf_addr;
+	errcode err = ERR_SUCCESS;
+	u32 filesize;
+	off_t currpos;
+	mm_segment_t oldfs;
+	loff_t offset;
+
+	if (filp == NULL) {
+		misp_err("%s - file didn't exist.", __func__);
+		err = ~ERR_SUCCESS;
+		goto read_calibration_data_end;
+	}
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	/*get the file size*/
+	currpos = vfs_llseek(filp, 0L, SEEK_END);
+	if (currpos == -1) {
+		set_fs(oldfs);
+		misp_err("%s  llseek end failed", __func__);
+		err = ~ERR_SUCCESS;
+		goto read_calibration_data_end;
+	}
+
+	filesize = (u32)currpos;
+	/*misp_info("%s  filesize : %u", __func__, filesize);*/
+
+	currpos = vfs_llseek(filp, 0L, SEEK_SET);
+	if (currpos == -1) {
+		set_fs(oldfs);
+		misp_err("%s  llseek set failed", __func__);
+		err = ~ERR_SUCCESS;
+		goto read_calibration_data_end;
+	}
+
+	/*Request memory*/
+	calibration_data_buf_addr = kzalloc(filesize, GFP_KERNEL);
+	if (!calibration_data_buf_addr) {
+		err = ~ERR_SUCCESS;
+		kfree(calibration_data_buf_addr);
+		goto read_calibration_data_end;
+	}
+
+	/*read the header info (first 16 bytes in the data)*/
+	offset = filp->f_pos;
+	err = vfs_read(filp, calibration_data_buf_addr, filesize,
+		&offset);
+	set_fs(oldfs);
+	if (err == -1) {
+		misp_err("%s Read file failed.", __func__);
+		/*close the file*/
+		filp_close(filp, NULL);
+		kfree(calibration_data_buf_addr);
+		goto read_calibration_data_end;
+	}
+	filp->f_pos = offset;
+	vfs_llseek(filp, 0L, SEEK_SET);
+
+	// write_calibration_data
+	err = mini_isp_drv_write_calibration_data(type, calibration_data_buf_addr, filesize);
+	if(err == 0)
+		goto done;
+	else
+		goto write_calibration_data_end;
+
+read_calibration_data_end:
+	misp_err("%s read_calibration_data_fail", __func__);
+write_calibration_data_end:
+	misp_err("%s write_calibration_data_fail", __func__);
+done:
+	misp_info("%s read and write calibration_data success!! ", __func__);
+}
+
+
+long handle_ControlFlowCmd_CHI(unsigned int cmd, unsigned long arg) {
+
+	long retval = 0;
+	struct isp_cmd_active_ae active_ae;
+	struct isp_cmd_led_power_control control_param;
+	memset(&active_ae, 0, sizeof(struct isp_cmd_active_ae));
+	memset(&control_param, 0, sizeof(struct isp_cmd_led_power_control));
+
+	misp_info("%s - enter", __func__);
+
+	if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {
+		retval = -EFAULT;
+		goto done;
+    }
+
+	misp_info("%s - VERIFY_READ OK!", __func__);
+
+	if (!access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd))) {
+		retval = -EFAULT;
+		goto done;
+    }
+
+	misp_info("%s - VERIFY_WRITE OK!", __func__);
+	switch (cmd) {
+		case IOCTL_ISP_RUN_TASK_START:
+			misp_info("%s - IOCTL_ISP_RUN_TASK_START", __func__);
+			if(g_isMiniISP_RunAll == 0) {
+				g_isMiniISP_RunAll = 1;
+				// open auto depth mode
+
+				mini_isp_poweron();
+
+				if(0 != mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID)){
+					misp_err("get chip id failed \n");
+				}
+				if(0 != mini_isp_drv_setting(MINI_ISP_MODE_CHIP_INIT)){ //if boot form SPI NOR, do not call this
+					misp_err("chip init failed \n");
+				}
+				if(0 != mini_isp_drv_setting(MINI_ISP_MODE_E2A)){
+					misp_err("change MINI_ISP_MODE_E2A failed failed \n");
+				}
+				if(0 != mini_isp_drv_setting(MINI_ISP_MODE_NORMAL)){
+					misp_err("misp_load_fw failed \n");
+				}
+
+
+				mini_isp_other_drv_open(IQCALIBRATIONDATA_FILE_LOCATION, IQ_CODE);
+				mini_isp_other_drv_read(internal_file[IQ_CODE], IQ_CODE);
+
+				mini_isp_other_drv_open(DEPTHPACKDATA_FILE_LOCATION, DEPTH_CODE);
+				mini_isp_other_drv_read(internal_file[DEPTH_CODE], DEPTH_CODE); // Depth calibration data
+
+				mini_isp_drv_write_calibration_data(2, NULL, 0); // Scenario table
+				mini_isp_drv_write_calibration_data(3, NULL, 0); // HDR Qmerge
+				mini_isp_drv_write_calibration_data(4, NULL, 0); // IRP0 Qmerge
+				mini_isp_drv_write_calibration_data(5, NULL, 0); // IRP1 Qmerge
+				// mini_isp_drv_write_calibration_data(7, NULL, 0); // Blending table for ground depth
+				// mini_isp_drv_write_calibration_data(8, NULL, 0); // Depth Qmerge
+
+				// set depth output resolution
+				//mini_isp_drv_set_output_format(18, 6);// set depth output resolution
+                                mini_isp_drv_set_output_format(19, 7);// set depth output resolution
+
+				active_ae.active_ae = 1;
+				active_ae.f_number_x1000 = 2000;
+				mini_isp_drv_active_ae(&active_ae);
+
+				mini_isp_drv_set_sensor_mode(1,4,0,0,0);  // Set sensor mode
+				//projector control
+				control_param.led_on_off = 1;
+				control_param.control_mode = 3;
+				control_param.led_power_level = 255;
+				control_param.control_projector_id = 0;
+				mini_isp_drv_led_power_control(&control_param);
+				mini_isp_drv_preview_stream_on_off(1,1); // open preview
+				mini_isp_drv_isp_ae_control_mode_on_off(1);
+			}
+			break;
+		case IOCTL_ISP_RUN_TASK_STOP:
+			misp_info("%s - IOCTL_ISP_RUN_TASK_STOP", __func__);
+			if(g_isMiniISP_RunAll == 1) {
+				g_isMiniISP_RunAll = 0;
+				// close auto depth mode
+				mini_isp_drv_preview_stream_on_off(0,0); // close preview
+				mini_isp_drv_isp_ae_control_mode_on_off(0);
+				mini_isp_drv_led_power_control(&control_param);
+				mini_isp_drv_set_sensor_mode(0,0,0,0,0);  // Set sensor mode
+				mini_isp_drv_active_ae(&active_ae);
+				mini_isp_drv_set_output_format(0,0); // set depth output resolution:
+                                                      // 0: Disable depth function (Depth engine is disable)
+			}
+		break;
+		default:
+			misp_info("%s - UNKNOWN CMD[%x]", __func__, cmd);
+			retval = -ENOTTY;
+		break;
+	}
+done:
+	misp_info("%s - leave", __func__);
+	return retval;
+}
+// ALTEK_AL6100_CHI >>>
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_customer_define.c b/drivers/media/platform/msm/camera/al6100/miniisp_customer_define.c
new file mode 100644
index 0000000..74315bf
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_customer_define.c
@@ -0,0 +1,317 @@
+/*
+ * File: miniisp_customer_define.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/03/14;LouisWang; Initial version
+ */
+
+/******Include File******/
+/* Linux headers*/
+#include <linux/delay.h>
+#include  <linux/of_gpio.h>
+
+#include "include/miniisp_customer_define.h"
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/altek_statefsm.h"
+
+#define MINI_ISP_LOG_TAG "[miniisp_customer_define]"
+
+extern void mini_isp_poweron(void)
+{
+	errcode ret = 0;
+	void *devdata;
+	struct misp_global_variable *dev_global_variable;
+	struct altek_statefsm *fsm;
+
+	misp_info("%s - enter", __func__);
+	fsm = get_mini_isp_fsm();
+	dev_global_variable = get_mini_isp_global_variable();
+	/*reset mini-isp keep low for at least 200us, release to high for 20ms*/
+	dev_global_variable->before_booting = 1;
+	dev_global_variable->be_set_to_bypass = 0;
+
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	/*state check*/
+	ret = altek_statefsmispdrv_open(fsm, ((void *)devdata));
+	if (ret != 0)
+		misp_err("%s err, %x", __func__, ret);
+
+	dev_global_variable->now_state = 1;
+}
+EXPORT_SYMBOL(mini_isp_poweron);
+
+extern void mini_isp_poweroff(void)
+{
+	void *devdata;
+	struct misp_global_variable *dev_global_variable;
+	int ret = 0;
+	struct altek_statefsm *fsm;
+
+	fsm = get_mini_isp_fsm();
+	misp_err("[miniISP]mini_isp_poweroff");
+	dev_global_variable = get_mini_isp_global_variable();
+    /*
+	if (dev_global_variable->i2c_enable)
+		devdata = (void *)get_mini_isp_i2c_slave_data();
+	else
+		devdata = (void *)get_mini_isp_data();
+    */
+    devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	/*state check*/
+	ret = altek_statefsmispdrv_close(fsm, devdata);
+	if (ret != 0) {
+		misp_err("%s err, %x", __func__, ret);
+		return;
+	}
+
+	dev_global_variable->now_state = 0;
+	misp_info("%s - X", __func__);
+}
+EXPORT_SYMBOL(mini_isp_poweroff);
+
+#if 0 //not used currently
+static int misp_ts_pinctrl_init(struct device *dev, int on)
+{
+	int retval = 0;
+	struct pinctrl *misp_pinctrl;
+	struct pinctrl_state *gpio_state_active;
+	struct pinctrl_state *gpio_state_suspend;
+
+	struct pinctrl_state *pins_state;
+
+	/* Get pinctrl if target uses pinctrl */
+	misp_pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(misp_pinctrl)) {
+		dev_dbg(&spi->dev,
+			"Target does not use pinctrl");
+		retval = PTR_ERR(misp_pinctrl);
+		misp_pinctrl = NULL;
+		goto misp_ts_pinctrl_init_end;
+	}
+
+	gpio_state_active
+		= pinctrl_lookup_state(misp_pinctrl,
+			"pmx_ts_active");
+	if (IS_ERR_OR_NULL(gpio_state_active)) {
+		dev_dbg(dev),
+			"Can not get ts default pinstate");
+		retval = PTR_ERR(gpio_state_active);
+		misp_pinctrl = NULL;
+		goto misp_ts_pinctrl_init_end;
+	}
+
+	gpio_state_suspend
+		= pinctrl_lookup_state(misp_pinctrl,
+			"pmx_ts_suspend");
+	if (IS_ERR_OR_NULL(gpio_state_suspend)) {
+		dev_err(dev,
+			"Can not get ts sleep pinstate");
+		retval = PTR_ERR(gpio_state_suspend);
+		misp_pinctrl = NULL;
+		goto misp_ts_pinctrl_init_end;
+	}
+
+	pins_state = on ? gpio_state_active
+		: gpio_state_suspend;
+	if (!IS_ERR_OR_NULL(pins_state)) {
+		retval = pinctrl_select_state(misp_pinctrl, pins_state);
+		if (retval) {
+			dev_err(dev,
+				"can not set %s pins",
+				on ? "pmx_ts_active" : "pmx_ts_suspend");
+			goto misp_ts_pinctrl_init_end;
+		}
+	} else {
+		dev_err(dev,
+			"not a valid '%s' pinstate",
+				on ? "pmx_ts_active" : "pmx_ts_suspend");
+	}
+
+misp_ts_pinctrl_init_end:
+	return retval;
+}
+#endif
+
+extern int mini_isp_gpio_init(struct device *dev,
+			struct misp_data *drv_data,
+			struct misp_global_variable *drv_global_variable)
+{
+	int ret = 0;
+
+	if (VCC1_GPIO != NULL) {
+		drv_global_variable->vcc1_gpio =
+			of_get_named_gpio(dev->of_node, VCC1_GPIO, 0);
+		misp_info("%s - probe vcc1-gpios = %d", __func__,
+			drv_global_variable->vcc1_gpio);
+
+		ret = devm_gpio_request(dev,
+			drv_global_variable->vcc1_gpio, VCC1_GPIO);
+		if (ret) {
+			misp_err("%s -step 4. request vcc1-gpio error",
+				__func__);
+			goto err_gpio1_config;
+		}
+
+		gpio_direction_output(drv_global_variable->vcc1_gpio, 1);
+		msleep(20);
+		gpio_set_value(drv_global_variable->vcc1_gpio, 1);
+		msleep(20);
+	}
+
+	if (VCC2_GPIO != NULL) {
+		drv_global_variable->vcc2_gpio = of_get_named_gpio(
+			dev->of_node, VCC2_GPIO, 0);
+		misp_info("%s - probe vcc2-gpios = %d", __func__,
+			drv_global_variable->vcc2_gpio);
+
+		ret = devm_gpio_request(dev,
+			drv_global_variable->vcc2_gpio, VCC2_GPIO);
+		if (ret) {
+			misp_err("%s -step 4. request vcc2-gpios error",
+				__func__);
+			goto err_gpio2_config;
+		}
+
+		gpio_direction_output(drv_global_variable->vcc2_gpio, 1);
+		msleep(20);
+		gpio_set_value(drv_global_variable->vcc2_gpio, 1);
+		msleep(20);
+	}
+
+	if (VCC3_GPIO != NULL) {
+		drv_global_variable->vcc3_gpio = of_get_named_gpio(
+			dev->of_node, VCC3_GPIO, 0);
+		misp_err("%s - probe vcc3-gpios = %d", __func__,
+					drv_global_variable->vcc3_gpio);
+
+		ret = devm_gpio_request(dev,
+			drv_global_variable->vcc3_gpio, VCC3_GPIO);
+		if (ret) {
+			misp_err("%s -step 4. request vcc3-gpio error",
+				__func__);
+			goto err_gpio_config;
+		}
+
+		gpio_direction_output(drv_global_variable->vcc3_gpio, 1);
+		gpio_set_value(drv_global_variable->vcc3_gpio, 1);
+		msleep(20);
+
+	}
+	if (ISP_CLK != NULL) {
+		drv_global_variable->isp_clk = devm_clk_get(dev,
+						ISP_CLK);
+		misp_err("clk_ptr = %p", drv_global_variable->isp_clk);
+		ret = clk_set_rate(drv_global_variable->isp_clk, 19200000L);
+		if (ret < 0)
+			misp_err("clk_set_rate failed, not fatal\n");
+
+		misp_err("clk_get_rate %ld\n", clk_get_rate(
+					drv_global_variable->isp_clk));
+		ret = clk_prepare_enable(drv_global_variable->isp_clk);
+		if (ret < 0) {
+			misp_err("clk_prepare_enable failed\n");
+			goto err_clk_config;
+		}
+		msleep(20);
+	}
+
+	if (RESET_GPIO != NULL) {
+		drv_global_variable->reset_gpio =
+			of_get_named_gpio(dev->of_node, RESET_GPIO, 0);
+		misp_info("%s - probe reset_gpio = %d", __func__,
+			drv_global_variable->reset_gpio);
+
+		ret = devm_gpio_request(dev,
+			drv_global_variable->reset_gpio, RESET_GPIO);
+		if (ret) {
+			misp_err("%s -step 4. request reset gpio error",
+				__func__);
+			goto err_reset_config;
+		}
+
+		gpio_direction_output(drv_global_variable->reset_gpio, 0);
+		gpio_set_value(drv_global_variable->reset_gpio, 0);
+		msleep(20);
+
+	}
+
+	if (IRQ_GPIO != NULL) {
+
+		drv_global_variable->irq_gpio = of_get_named_gpio(dev->of_node, IRQ_GPIO, 0);
+
+		//drv_global_variable->irq_gpio = of_get_named_gpio(dev->of_node, IRQ_GPIO, &gpio_flag);
+		misp_info("%s - probe irq_gpio = %d", __func__, drv_global_variable->irq_gpio);
+
+		/*ret = devm_gpio_request(dev,
+			drv_global_variable->irq_gpio, IRQ_GPIO);*/
+		ret = gpio_request(drv_global_variable->irq_gpio, IRQ_GPIO);
+		if (ret) {
+			misp_err("%s -step 4. request irq gpio error",
+				__func__);
+			goto err_irq_config;
+		}
+		gpio_direction_input(drv_global_variable->irq_gpio);
+
+		drv_global_variable->irq_num = gpio_to_irq(drv_global_variable->irq_gpio);
+
+		misp_err("%s - probe spi->irq = %d %d ",
+			__func__, drv_global_variable->irq_num,
+			gpio_to_irq(drv_global_variable->irq_gpio));
+
+		ret = request_threaded_irq(drv_global_variable->irq_num, NULL, mini_isp_irq,
+		IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "mini_isp", drv_data);
+
+		if (ret) {
+			misp_err("%s - step4. probe - request irq error",
+				__func__);
+			goto err_dev_attr;
+		}
+		misp_info("%s - step4 done. irq number:%d", __func__,
+			drv_global_variable->irq_num);
+
+		free_irq(drv_global_variable->irq_num, drv_data);
+	}
+
+	/*step 5:other additional config*/
+
+	misp_info("%s - step5 done", __func__);
+
+	if (RESET_GPIO != NULL) {
+		gpio_direction_output(drv_global_variable->reset_gpio, 1);
+		gpio_set_value(drv_global_variable->reset_gpio, 1);
+		msleep(20);
+	}
+
+	return ret;
+
+err_dev_attr:
+	free_irq(drv_global_variable->irq_num, drv_data);
+err_irq_config:
+	if (IRQ_GPIO != NULL)
+		gpio_free(drv_global_variable->irq_gpio);
+
+err_reset_config:
+	if (RESET_GPIO != NULL)
+		gpio_free(drv_global_variable->reset_gpio);
+
+err_clk_config:
+	if (ISP_CLK != NULL)
+		clk_disable_unprepare(drv_global_variable->isp_clk);
+
+err_gpio_config:
+	if (VCC2_GPIO != NULL)
+		gpio_free(drv_global_variable->vcc2_gpio);
+err_gpio2_config:
+	if (VCC1_GPIO != NULL)
+		gpio_free(drv_global_variable->vcc1_gpio);
+
+err_gpio1_config:
+
+	return ret;
+}
+
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_debug_if.c b/drivers/media/platform/msm/camera/al6100/miniisp_debug_if.c
new file mode 100644
index 0000000..3b3e0a2
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_debug_if.c
@@ -0,0 +1,643 @@
+/*
+ * File: miniisp_debug_if.c
+ * Description: mini ISP debug daemon interface
+ *
+ * (C)Copyright altek Corporation 2018
+ *
+ *  2017/04/20; PhenixChen; Initial version
+ */
+
+/******Include File******/
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl_intf.h"
+#include "include/miniisp_debug_if.h"
+
+#include <asm-generic/uaccess.h> // copy_*_user()
+#include <linux/fs.h>      // chrdev, struct file_operations
+#include <linux/cdev.h>    // cdev_add()/cdev_del()
+#include <linux/mm.h>
+#include <linux/delay.h> //msleep()
+
+/******Private Constant Definition******/
+#define MINI_ISP_LOG_TAG	"[miniisp_debug_if]"
+
+/******Private Function Prototype******/
+static int miniisp_dev_open(struct inode*, struct file*);
+static int miniisp_dev_release(struct inode *inode, struct file *filp);
+static long miniisp_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+static int miniisp_dev_map(struct file *filp, struct vm_area_struct *vma);
+static u32 miniisp_debugif_memory_read(u32 start_addr, u32 len);
+static u32 miniisp_debugif_RegBulk_read(u32 start_addr, u32 end_reg_addr);
+static long miniisp_debugif_get_mem(u32 len);
+static long miniisp_debugif_munmap_done(void);
+static long handle_RegCmd(unsigned int cmd, unsigned long arg);
+static long handle_MemCmd(unsigned int cmd, unsigned long arg);
+static long handle_BulkCmd(unsigned int cmd, unsigned long arg);
+
+/******Public Function Prototype******/
+struct device *miniisp_chdev_create(struct class *mini_isp_class);
+
+/******Private Global Variable******/
+static int miniisp_dev_major;
+static int miniisp_dev_minor;
+static struct cdev *miniisp_dev_cdev = NULL;
+static unsigned long *allocated_memmory_align  = NULL;
+static unsigned long *allocated_memmory = NULL;
+static unsigned long allocated_size;
+static u8 During_Refresh_Module;
+
+struct dbg_drvdata {
+    //u32 val;
+    u32 reg_tbl[4]; //for Test
+    //unsigned char mem[16];
+    rwlock_t lock;
+};
+
+static struct file_operations miniisp_dev_fops = {
+    .owner = THIS_MODULE,
+    .open = miniisp_dev_open,
+    .release = miniisp_dev_release,
+    .mmap =  miniisp_dev_map,
+    //.read = dev_read,
+    //.write = dev_write,
+    .unlocked_ioctl = miniisp_dev_ioctl,
+    .compat_ioctl = miniisp_dev_ioctl,
+};
+
+static long miniisp_debugif_munmap_done(void)
+{
+    unsigned long virt_addr;
+    misp_err("%s:called", __func__);
+    if (allocated_memmory_align) {
+        for (virt_addr = (unsigned long)allocated_memmory_align;
+            virt_addr < (unsigned long)allocated_memmory_align + allocated_size; virt_addr += PAGE_SIZE)
+            ClearPageReserved(virt_to_page(virt_addr));
+        kfree(allocated_memmory);
+        allocated_memmory = NULL;
+        allocated_memmory_align = NULL;
+        allocated_size = 0;
+    }
+    return 0;
+}
+
+static long miniisp_debugif_get_mem(u32 len)
+{
+    long retval = 0;
+    unsigned long virt_addr;
+    unsigned long mask = ~(PAGE_SIZE -1);
+    //allocated_size = len + 11;
+
+    //page-aligned memory size
+    allocated_size = (len + PAGE_SIZE -1) & ~(PAGE_SIZE - 1);
+    misp_err("%s:memory length = %u, page-aligned memory size = %lu",
+        __func__, len, allocated_size);
+
+    // allocate page-aligned memory
+    if(!(allocated_memmory = kzalloc(allocated_size + PAGE_SIZE - 1, GFP_KERNEL))) {
+        misp_err("%s:kzalloc failed", __func__);
+        retval = -ENOMEM;
+        goto done;
+    }
+    /* printf指標的位址通常使用%x，但它的寬度是 32-bit，無法在 64-bit 環境下顯示正確結果，需改用%p */
+    misp_err("%s:allocated_memmory before align = %p", __func__, allocated_memmory);
+    allocated_memmory_align = (unsigned long *) (((unsigned long)allocated_memmory + PAGE_SIZE - 1) & mask);
+    misp_err("%s:allocated_memmory after align = %p", __func__, allocated_memmory_align);
+    misp_err("%s:kzalloc succeed, total allocated_size = %lu", __func__, allocated_size + PAGE_SIZE - 1);
+
+    /* reserve all pages to make them remapable */
+    for (virt_addr = (unsigned long)allocated_memmory_align;
+        virt_addr < (unsigned long)allocated_memmory_align + allocated_size; virt_addr += PAGE_SIZE)
+        SetPageReserved(virt_to_page(virt_addr));
+done:
+    return retval;
+}
+
+
+static int miniisp_dev_map(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long page, pos;
+    unsigned long start = (unsigned long)vma->vm_start;
+    unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
+    misp_err("%s:called", __func__);
+
+    if(size > (unsigned long)allocated_size) {
+        misp_err("%s:ERROR1 mapsz = %lu, allocated_size = %lu", __func__, size, (unsigned long)allocated_size);
+        return - EINVAL;
+    }
+    pos = (unsigned long)allocated_memmory_align;
+    page = virt_to_phys((void *)pos);
+
+    if(remap_pfn_range(vma, start, page >> PAGE_SHIFT, size, PAGE_SHARED)) {
+        misp_err("%s:ERROR2", __func__);
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static u32 miniisp_debugif_RegBulk_read(u32 start_reg_addr, u32 end_reg_addr)
+{
+    struct misp_data *devdata;
+    struct misp_global_variable *dev_global_variable;
+    u32 count;
+    u32 rx_dummy_len;
+    u8 *send_buffer;
+    u8 *recv_buffer;
+    u8 *io_buffer = NULL;
+    u32 io_size;
+    u8 *dump_memory = NULL;
+    u8 *keep_dump_memory = NULL;
+    u32 ouput_size;
+    u8 ctrlbyte;
+
+    /* prepare for mmap >>>*/
+    long retval = 0;
+    u8 *mmap_addr;
+
+    count = ((end_reg_addr - start_reg_addr) / 4) + 1;  //how many registers(4 bytes) do you want to read?
+    ouput_size = (count + 2) * 4; // read 4 bytes register value
+
+    retval = miniisp_debugif_get_mem(ouput_size);
+    if (retval)
+        goto mini_isp_register_read_end;
+    mmap_addr = (u8 *)allocated_memmory_align;
+    /* prepare for mmap <<<*/
+
+    dev_global_variable = get_mini_isp_global_variable();
+    devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+
+    rx_dummy_len = devdata->rx_dummy_len;
+    io_size = EMODE_TXCMD_LEN + rx_dummy_len + 4; // read 4 bytes register value at a time
+
+    io_buffer = kzalloc(io_size, GFP_KERNEL);
+    if (!io_buffer) {
+        misp_err("%s Allocate memory failed.", __func__);
+        retval = -ENOMEM;
+        goto allocate_memory_fail;
+    }
+
+    dump_memory = kzalloc(ouput_size, GFP_KERNEL);
+    if (!dump_memory){
+        misp_err("%s Allocate memory failed.", __func__);
+        retval = -ENOMEM;
+        goto allocate_memory_fail;
+    }
+    keep_dump_memory = dump_memory;
+
+    send_buffer = io_buffer;
+    recv_buffer = io_buffer + EMODE_TXCMD_LEN;
+
+    memcpy(dump_memory, &start_reg_addr, 4);
+    dump_memory = dump_memory + 4;
+    memcpy(dump_memory, &count, 4);
+    dump_memory = dump_memory + 4;
+
+    ctrlbyte = CTRL_BYTE_REGRD;
+    while (start_reg_addr <= end_reg_addr) {
+
+        memset(io_buffer, 0, io_size);
+        memcpy(send_buffer, &ctrlbyte, 1);
+        memcpy(send_buffer + 1, &start_reg_addr, 4);
+
+        retval = devdata->intf_fn->read((void *)devdata,
+                    send_buffer, EMODE_TXCMD_LEN,
+                    recv_buffer, rx_dummy_len + 4);
+
+        if (retval)
+            goto mini_isp_register_read_get_fail;
+
+        if (rx_dummy_len > 0 &&
+            mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+            retval = -EIO;
+            goto mini_isp_register_read_get_fail;
+        }
+
+        memcpy(dump_memory, recv_buffer, 4);
+        start_reg_addr = start_reg_addr + 4;
+        dump_memory = dump_memory + 4;
+    }
+
+#if 0
+    snprintf(filename, 64, "%s/%s.regx",
+        MINIISP_INFO_DUMPLOCATION, module_name);
+    f = filp_open(filename, O_APPEND | O_CREAT | O_RDWR, 0777);
+    /*Get current segment descriptor*/
+    fs = get_fs();
+    /*Set segment descriptor associated*/
+    set_fs(get_ds());
+    /*write the file*/
+    f->f_op->write(f, (char *)keep_dump_memory, ouput_size, &f->f_pos);
+    /*Restore segment descriptor*/
+    set_fs(fs);
+    filp_close(f, NULL);
+
+#endif
+    memcpy(mmap_addr, keep_dump_memory, ouput_size);
+    kfree(io_buffer);
+    kfree(keep_dump_memory);
+    goto mini_isp_register_read_end;
+
+mini_isp_register_read_get_fail:
+    misp_err("%s read failed.", __func__);
+allocate_memory_fail:
+    kfree(io_buffer);
+    kfree(keep_dump_memory);
+    miniisp_debugif_munmap_done();
+mini_isp_register_read_end:
+    return retval;
+}
+
+static u32 miniisp_debugif_memory_read(u32 start_addr, u32 len)
+{
+    struct misp_data *devdata;
+    struct misp_global_variable *dev_global_variable;
+    u8 *send_buffer;
+    u8 *recv_buffer;
+    u8 *io_buffer = NULL;
+    u8 *dump_memory = NULL;
+    u8 *keep_dump_memory = NULL;
+    u32 dump_addr = start_addr;
+    u32 ouput_size;
+    u32 io_size, remain_size, one_size;
+    u32 rx_dummy_len;
+    u8 ctrlbyte;
+    /* prepare for mmap >>>*/
+    long retval = 0;
+    u8 *mmap_addr;
+
+    retval = miniisp_debugif_get_mem(len);
+    if (retval)
+        goto mini_isp_memory_read_end;
+    mmap_addr = (u8 *)allocated_memmory_align;
+    /* prepare for mmap <<<*/
+
+    dev_global_variable = get_mini_isp_global_variable();
+    devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+    rx_dummy_len = devdata->rx_dummy_len;
+    io_size = EMODE_TXCMD_LEN + rx_dummy_len + 60000; // read 60000 bytes at a time;
+
+    io_buffer = kzalloc(io_size, GFP_KERNEL);
+    if (!io_buffer) {
+        misp_err("%s Allocate memory failed.", __func__);
+        retval = -ENOMEM;
+        goto allocate_memory_fail;
+    }
+
+    dump_memory = kzalloc(len, GFP_KERNEL);
+    if (!dump_memory){
+        misp_err("%s Allocate memory failed.", __func__);
+        retval = -ENOMEM;
+        goto allocate_memory_fail;
+    }
+
+    keep_dump_memory = dump_memory;
+    ouput_size = len;
+
+    ctrlbyte = CTRL_BYTE_MEMRD; //memory read
+    for (remain_size = ouput_size; remain_size > 0;
+        remain_size -= one_size) {
+
+        one_size = (remain_size > 60000) ?
+        60000 : remain_size;
+
+        memset(io_buffer, 0, io_size);
+        send_buffer = io_buffer;
+        recv_buffer = io_buffer + EMODE_TXCMD_LEN;
+
+        memcpy(send_buffer, &ctrlbyte, 1);
+        memcpy(send_buffer + 1, &dump_addr, 4);
+
+        retval = devdata->intf_fn->read((void *)devdata,
+                            send_buffer,
+                            EMODE_TXCMD_LEN,
+                            recv_buffer,
+                            one_size + rx_dummy_len);
+        if (retval)
+            goto mini_isp_memory_read_get_fail;
+
+        if (rx_dummy_len > 0 &&
+            mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+            retval = -EIO;
+            goto mini_isp_memory_read_get_fail;
+        }
+
+        memcpy(dump_memory, recv_buffer, one_size);
+        misp_info("%s dump_addr = 0x%x  one_size = %d",
+            __func__, dump_addr, one_size);
+        dump_memory += one_size;
+        dump_addr += one_size;
+    } //for-loop
+
+    misp_err("%s dump_finish", __func__);
+    memcpy(mmap_addr, keep_dump_memory, ouput_size);
+
+    kfree(io_buffer);
+    kfree(keep_dump_memory);
+    goto mini_isp_memory_read_end;
+
+mini_isp_memory_read_get_fail:
+    misp_err("%s read failed.", __func__);
+allocate_memory_fail:
+    kfree(io_buffer);
+    kfree(keep_dump_memory);
+    miniisp_debugif_munmap_done();
+mini_isp_memory_read_end:
+    return retval;
+}
+
+static long handle_PrepareCmd(unsigned int cmd, unsigned long arg)
+{
+    long retval = 0;
+    u8 state; //1:start, 0:done
+    if (copy_from_user(&state, (int __user *)arg, sizeof(state))) {
+        retval = -EFAULT;
+        goto done;
+    }
+    switch (cmd) {
+    case IOCTL_REFRESH_MODULE:
+        if (state == 1) {
+            During_Refresh_Module = 1;
+            mini_isp_a_to_e();
+        } else if (state == 0) {
+            mini_isp_e_to_a();
+            During_Refresh_Module = 0;
+        }
+        break;
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+done:
+    return retval;
+}
+
+static long handle_InfoCmd(unsigned int cmd, unsigned long arg)
+{
+    long retval = 0;
+    struct irp_and_depth_information data;
+    memset(&data, 0, sizeof(data));
+    if (copy_from_user(&data, (int __user *)arg, sizeof(data))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+    mini_isp_a_to_e();
+
+    switch (cmd) {
+    case IOCTL_IRP_DEPTH_INFO:
+        misp_err("%s:IOCTL_IRP_DEPTH_INFO", __func__);
+        retval = mini_isp_utility_get_irp_and_depth_information(&data);
+        if (retval) {
+            misp_err("%s:miniisp driver spi error, retval = %u", __func__, (u32)retval);
+            retval = -EIO ;
+            break;
+        }
+        if (copy_to_user((int __user *)arg, &data, sizeof(data)))
+            retval = -EFAULT;
+        break;
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+
+    mini_isp_e_to_a();
+done:
+    return retval;
+}
+
+static long handle_RegCmd(unsigned int cmd, unsigned long arg)
+{
+    long retval = 0;
+    u32 val = 0xFFFFFFFF;
+    struct ioctl_regRW_cmd data;
+    memset(&data, 0, sizeof(data));
+    if (copy_from_user(&data, (int __user *)arg, sizeof(data))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+    if (!During_Refresh_Module) mini_isp_a_to_e();
+
+    switch (cmd) {
+    case IOCTL_REGREAD:
+        misp_err("%s:IOCTL_REGREAD RegAddr = %#04x", __func__, data.RegAddr);
+        retval = mini_isp_register_read(data.RegAddr, &val);
+        if (val == 0xFFFFFFFF) {
+            if (retval < 0)
+                misp_err("%s:miniisp driver sync_error, retval = %u", __func__, (u32)retval);
+            else
+                misp_err("%s:miniisp driver can't get register.", __func__);
+            retval = -EIO ;
+            break;
+        }
+        data.RegVal = val;
+        if (copy_to_user((int __user *)arg, &data, sizeof(data)))
+            retval = -EFAULT;
+        break;
+    case IOCTL_REGWRITE:
+        // if (!capable(CAP_SYS_ADMIN)) {
+        // 	retval = -EPERM;
+        // 	goto done;
+        // }
+        misp_err("%s:IOCTL_REGWRITE RegAddr = %#04x; val = %#04x",
+             __func__, data.RegAddr, data.RegVal);
+        mini_isp_register_write(data.RegAddr, data.RegVal);
+        break;
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+
+    if (!During_Refresh_Module) mini_isp_e_to_a();
+
+done:
+    return retval;
+}
+
+
+static long handle_MemCmd(unsigned int cmd,unsigned long arg)
+{
+    long retval = 0;
+    struct ioctl_memRW_cmd data;
+    memset(&data, 0, sizeof(data));
+    if (copy_from_user(&data, (int __user *)arg, sizeof(data))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+    if (!During_Refresh_Module) mini_isp_a_to_e();
+
+    switch (cmd) {
+    case IOCTL_MEMREAD:
+        misp_err("%s:IOCTL_MEMREAD MemAddr = %#04x len = %u", __func__, data.MemAddr, data.len);
+        retval = miniisp_debugif_memory_read(data.MemAddr, data.len);
+        break;
+    case IOCTL_MUNMAP_DONE:
+        misp_err("%s:IOCTL_MMAPDONE", __func__);
+        retval = miniisp_debugif_munmap_done();
+        break;
+    case IOCTL_MEMGET:
+        misp_err("%s:IOCTL_MEMGET len = %u", __func__, data.len);
+        retval = miniisp_debugif_get_mem(data.len);
+        break;
+    case IOCTL_MEMWRITE:
+        misp_err("%s:IOCTL_MEMWRITE MemAddr = %#04x len = %u", __func__, data.MemAddr, data.len);
+        mini_isp_memory_write(data.MemAddr, (u8 *)allocated_memmory_align, data.len);
+        break;
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+
+    if (!During_Refresh_Module) mini_isp_e_to_a();
+
+done:
+    return retval;
+}
+
+static long handle_BulkCmd(unsigned int cmd,unsigned long arg)
+{
+    long retval = 0;
+    struct ioctl_regBulkRW_cmd data;
+    memset(&data, 0, sizeof(data));
+    if (copy_from_user(&data, (int __user *)arg, sizeof(data))) {
+        retval = -EFAULT;
+        goto done;
+    }
+
+    if (!During_Refresh_Module) mini_isp_a_to_e();
+
+    switch (cmd) {
+    case IOCTL_REGBULKREAD:
+        misp_err("%s:IOCTL_REGBULKREAD StartAddr = %#04x EndAddr = %#04x", __func__, data.StartAddr, data.EndAddr);
+        retval = miniisp_debugif_RegBulk_read(data.StartAddr, data.EndAddr);
+        misp_err("%s:IOCTL_REGBULKREAD end", __func__);
+        break;
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+    if (!During_Refresh_Module) mini_isp_e_to_a();
+
+done:
+    return retval;
+}
+
+
+static long miniisp_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    //struct dbg_drvdata *dev = filp->private_data;
+    long retval = 0;
+    misp_err("%s: IOCTL cmd:0x%08x", __func__, cmd);
+    /*
+    if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {
+        retval = -EFAULT;
+        goto done;
+    }
+    */
+    switch (_IOC_TYPE(cmd)) {
+    case IOC_REGCMD_MAGIC:
+        retval = handle_RegCmd(cmd, arg);
+        break;
+    case IOC_MEMCMD_MAGIC:
+        retval = handle_MemCmd(cmd, arg);
+        break;
+    case IOC_BULKCMD_MAGIC:
+        retval = handle_BulkCmd(cmd, arg);
+        break;
+    case IOC_INFOCMD_MAGIC:
+        retval = handle_InfoCmd(cmd, arg);
+        break;
+    case IOC_PREPARECMD_MAGIC:
+        retval = handle_PrepareCmd(cmd, arg);
+        break;
+    case IOC_ISP_CTRL_FLOW_MAGIC:
+        retval = handle_ControlFlowCmd(cmd, arg);
+        break;
+    // ALTEK_AL6100_CHI >>>
+    case IOC_ISP_CTRL_FLOW_CHI_MAGIC:
+        retval = handle_ControlFlowCmd_CHI(cmd, arg);
+        break;
+    // ALTEK_AL6100_CHI <<<
+    default:
+        retval = -ENOTTY;
+        break;
+    }
+    return retval;
+}
+
+static int miniisp_dev_open(struct inode *inode, struct file *filp)
+{
+    struct dbg_drvdata *p;
+    misp_err("%s:major %d minor %d (pid %d)", __func__, imajor(inode), iminor(inode), current->pid);
+    inode->i_private = inode;
+
+    p = kmalloc(sizeof(struct dbg_drvdata), GFP_KERNEL);
+    if (p == NULL) {
+        misp_err("%s:No memory", __func__);
+        return -ENOMEM;
+    }
+
+    memset(p, 0, sizeof(*p));
+    //p->val = 0xff;
+    rwlock_init(&p->lock);
+    filp->private_data = p;
+
+    misp_err("%s:inode->i_private = %p, filp->private_data = %p",
+        __func__, inode->i_private, filp->private_data);
+    return 0;
+}
+
+static int miniisp_dev_release(struct inode *inode, struct file *filp)
+{
+    misp_err("%s:major %d, minor %d, pid %d",
+        __func__, imajor(inode), iminor(inode), current->pid);
+    misp_err("%s:inode->i_private = %p, filp->private_data = %p",
+        __func__, inode->i_private, filp->private_data);
+    //ClearPageReserved(virt_to_page(allocated_memmory));
+    //kfree(allocated_memmory_tmp);
+    kfree(filp->private_data);
+    return 0;
+}
+
+struct device *miniisp_chdev_create(struct class *mini_isp_class)
+{
+    dev_t miniisp_dev_nr;  //device number
+    int ret = 0;
+    struct device *mini_isp_dev;
+    //alloc major number
+    if (alloc_chrdev_region(&miniisp_dev_nr, 0, 1, "mini_isp_device") != 0) {
+        misp_err("%s:Allocate major number failed", __func__);
+        mini_isp_dev = device_create(mini_isp_class, NULL, 0, NULL, "mini_isp_device");
+    } else {
+        misp_err("%s:Allocate major number succeed", __func__);
+        mini_isp_dev = device_create(mini_isp_class, NULL, miniisp_dev_nr, NULL, "mini_isp_device");
+
+        miniisp_dev_major = MAJOR(miniisp_dev_nr);
+        miniisp_dev_minor = MINOR(miniisp_dev_nr);
+        misp_err("%s:register chrdev(%d,%d)", __func__, miniisp_dev_major, miniisp_dev_minor);
+
+        miniisp_dev_cdev = cdev_alloc();//kmalloc(sizeof(struct cdev), GFP_KERNEL); //alloc struct cdev
+        if (miniisp_dev_cdev == NULL)
+            misp_err("%s:kmalloc dev_cdev failed", __func__);
+        else
+            misp_err("%s:kmalloc dev_cdev succeed", __func__);
+        //register handler to struct cdev
+        miniisp_dev_cdev->ops = &miniisp_dev_fops;//cdev_init(miniisp_dev_cdev, &miniisp_dev_fops);
+        miniisp_dev_cdev->owner = THIS_MODULE;
+        //register driver (struct cdev with file handler) to kernel
+        ret = cdev_add(miniisp_dev_cdev, MKDEV(miniisp_dev_major, miniisp_dev_minor), 1);
+        if (ret < 0) {
+            misp_err("%s:Add character device failed", __func__);
+            if (miniisp_dev_cdev) {
+                kfree(miniisp_dev_cdev);
+                miniisp_dev_cdev = NULL;
+            }
+            //unregister_chrdev_region(miniisp_dev_nr, 1);
+        } else {
+            misp_err("%s:Add character device succeed", __func__);
+        }
+    }
+    return mini_isp_dev;
+}
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_intf_i2c.c b/drivers/media/platform/msm/camera/al6100/miniisp_intf_i2c.c
new file mode 100644
index 0000000..3debab6
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_intf_i2c.c
@@ -0,0 +1,429 @@
+/****************************************************************************
+* File: miniisp_intf_i2c.c                                                       *
+* Description: Mini ISP i2c sample codes                                    *
+*                                                                           *
+* (C)Copyright altek Corporation 2013                                       *
+*                                                                           *
+* History:                                                                  *
+*   2017/03/30; Max Tseng; Initial version                                  *
+****************************************************************************/
+
+/****************************************************************************
+*                               Include File                                *
+****************************************************************************/
+/* Linux headers*/
+#include <linux/module.h>
+#include <linux/buffer_head.h>
+
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/error/miniisp_err.h"
+
+/****************************************************************************
+*			Private Constant Definition			*
+****************************************************************************/
+#define MINI_ISP_LOG_TAG "[miniisp_intf_i2c]"
+#define MINIISP_SLAVE_ADDR 0x11
+#define MINIISP_TOP_ADDR   0x77
+
+/****************************************************************************
+*                          Private Global Variable                          *
+****************************************************************************/
+static struct misp_data *misp_intf_i2c_slave_data;
+static struct misp_data *misp_intf_i2c_top_data;
+static u8 *i2c_bulkbuffer;
+
+/****************************************************************************
+*                        Private Function Prototype                         *
+****************************************************************************/
+
+/**********************************************************************
+*                         Public Function                             *
+**********************************************************************/
+extern int mini_isp_setup_resource(struct device *dev, struct misp_data *drv_data);
+
+static const struct i2c_device_id mini_isp_intf_i2c_id[] = {
+	{ "altek_i2c_slave", MINIISP_I2C_SLAVE},
+	{ "altek_i2c_top", MINIISP_I2C_TOP},
+	{} /* NULL terminated*/
+};
+MODULE_DEVICE_TABLE(i2c, mini_isp_intf_i2c_id);
+
+/*
+ *get mini isp data
+ *return mini isp i2c data
+ */
+struct misp_data *get_mini_isp_intf_i2c_top_data(void)
+{
+	if (!misp_intf_i2c_top_data) {
+		misp_err("%s - get pdata error", __func__);
+		return NULL;
+	} else {
+		//misp_err("%s - get pdata success", __func__);
+		return misp_intf_i2c_top_data;
+	}
+}
+
+struct misp_data *get_mini_isp_intf_i2c_slave_data(void)
+{
+	if (!misp_intf_i2c_slave_data) {
+		misp_err("%s - get pdata error", __func__);
+		return NULL;
+	} else {
+		//misp_err("%s - get pdata success", __func__);
+		return misp_intf_i2c_slave_data;
+	}
+}
+struct misp_data *get_mini_isp_intf_i2c(int i2c_type)
+{
+	if (i2c_type == MINIISP_I2C_SLAVE) {
+		return get_mini_isp_intf_i2c_slave_data();
+	} else if (i2c_type == MINIISP_I2C_TOP) {
+		return get_mini_isp_intf_i2c_top_data();
+	} else {
+		misp_err("%s - error i2c type %d",__func__,i2c_type);
+		return NULL;
+	}
+}
+
+
+/****************************************************************************
+*                             Private Function                              *
+****************************************************************************/
+/*write command to miniISP through i2c,this function will block.
+ *return 0  successful
+ *others    fail
+*/
+static int mini_isp_intf_i2c_write(void *dev, u8 *tx_buf, u8 *rx_buf, u32 len)
+{
+	int status = 0;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata = %p",__func__,devdata);
+		return -EINVAL;
+	}
+
+	status = i2c_master_send(devdata->cfg.i2c, tx_buf, len);
+
+	if (status < 0) {
+		misp_err("%s - sync error: status=%d", __func__, status);
+	} else {
+		status = 0;
+	}
+
+	return status;
+}
+
+/*read command from device ,this function will block.
+ *return 0  successful
+ *others	fail
+ */
+static int mini_isp_intf_i2c_read(void *dev, u8 *tx_buf, u32 tx_len, u8 *rx_buf, u32 rx_len)
+{
+	int status = 0;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata = %p",__func__,devdata);
+		return -EINVAL;
+	}
+
+	misp_info("%s - i2c_master_send start.", __func__);
+	if (tx_len > 0) {
+		status = i2c_master_send(devdata->cfg.i2c, tx_buf, tx_len);
+		if (status != tx_len)
+			return status;
+	}
+
+	misp_info("%s - i2c_master_recv start.", __func__);
+	/* read data from device through i2c */
+	status = i2c_master_recv(devdata->cfg.i2c, rx_buf, rx_len);
+
+	if (status < 0) {
+		misp_err("%s - sync error: status=%d", __func__, status);
+	} else {
+		status = 0;
+	}
+
+	return status;
+}
+
+/*
+ *write command data to miniISP through i2c
+ *return 0  successful
+ *others    fail
+*/
+static int mini_isp_intf_i2c_send(void *dev, u32 len)
+{
+	int status = 0;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_info("%s - enter", __func__);
+
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata = %p, len= %d", __func__, devdata, len);
+		return -EINVAL;
+	}
+
+	misp_info("%s - i2c_master_send start.", __func__);
+	/* send data to miniISP through i2c */
+	status = mini_isp_intf_i2c_write(devdata, devdata->tx_buf, devdata->rx_buf, len);
+
+	misp_info("%s - devdata->cfg.i2c->addr = %x", __func__, devdata->cfg.i2c->addr);
+	if (status < 0) {
+		misp_err("%s - sync error: status=%d", __func__, status);
+	} else {
+		status = 0;
+	}
+	return status;
+}
+
+/* read miniISP using i2c ,this function will block.
+ *return 0  successful
+ *others    fail
+ */
+static int mini_isp_intf_i2c_recv(void *dev, u32 len, bool waitINT)
+{
+	int status = 0;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_info("%s - enter", __func__);
+
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata=%p,len=%d", __func__,
+							devdata, len);
+		return -EINVAL;
+	}
+
+	if (waitINT)
+		/*wait for the interrupt*/
+		status = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+
+	if (status) {
+		misp_err("%s - irq error: status=%d", __func__, status);
+		return status;
+	}
+
+	/* receive the data through i2c */
+	status = mini_isp_intf_i2c_read(devdata,devdata->tx_buf,0,devdata->rx_buf,len);
+
+	if (status) {
+		misp_err("%s - sync error: status=%d", __func__, status);
+		return status;
+	}
+
+	misp_info("%s - recv buf len=%d:", __func__, len);
+	return status;
+}
+
+/*used to send the firmware*/
+static int mini_isp_intf_i2c_send_bulk(void *devdata, struct file *filp,
+	u32 total_size, u32 block_size, bool is_raw, u8 *i2c_Sendbulkbuffer)
+{
+	int status = 0, count = 0;
+	int remain_size, one_size;
+	int shift = 0;
+
+	misp_info("%s - enter", __func__);
+
+	if (i2c_Sendbulkbuffer != NULL) {
+		misp_info("%s start. Total size: %d. block_size: %d", __func__, total_size, block_size);
+
+		if (total_size > I2C_TX_BULK_SIZE)
+			i2c_bulkbuffer = kzalloc(I2C_TX_BULK_SIZE, GFP_DMA);
+		/* Allocate boot code bulk buffer*/
+		else
+			i2c_bulkbuffer = kzalloc(total_size, GFP_DMA);
+
+		if (!i2c_bulkbuffer) {
+			status = -EINVAL;
+			goto T_EXIT;
+		}
+
+		for (remain_size = total_size; remain_size > 0; remain_size -= one_size) {
+			one_size = (remain_size > block_size) ? block_size : remain_size;
+
+			misp_info("remain size: %d one_size: %d.", remain_size, one_size);
+
+			memcpy(i2c_bulkbuffer, i2c_Sendbulkbuffer + shift, one_size);
+			shift += one_size;
+
+			/*send the data*/
+			status = mini_isp_intf_i2c_write(devdata,
+					i2c_bulkbuffer, NULL, one_size);
+
+			if (status != 0) {
+				misp_err("%s failed! block:%d status:%d", __func__, count, status);
+				break;
+			}
+			misp_info("%s write block %d success", __func__, count);
+			count++;
+		}
+	}
+
+T_EXIT:
+
+	if (i2c_bulkbuffer != NULL) {
+		kfree(i2c_bulkbuffer);
+		i2c_bulkbuffer = NULL;
+	}
+
+	if (status != ERR_SUCCESS)
+		misp_err("%s error: %d", __func__, status);
+	else
+		misp_info("%s success", __func__);
+
+	return status;
+}
+
+struct misp_intf_fn_t intf_i2c_fn = {
+	.send = mini_isp_intf_i2c_send,
+	.recv = mini_isp_intf_i2c_recv,
+	.read = mini_isp_intf_i2c_read,
+	.write = mini_isp_intf_i2c_write,
+	.send_bulk = mini_isp_intf_i2c_send_bulk,
+};
+
+static int mini_isp_intf_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int status = 0;
+	struct misp_data *drv_data = NULL;
+
+	misp_info("%s - start.", __func__);
+
+	/* step 0: Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		misp_err("%s - i2c_check_functionality err.", __func__);
+		return -EIO;
+	}
+	/*step 1: alloc driver data struct*/
+	drv_data = kmalloc(sizeof(struct misp_data), GFP_KERNEL);
+	if (!drv_data) {
+		status = -ENOMEM;
+		goto alloc_misp_data_fail;
+	}
+	misp_info("%s - step1 done.", __func__);
+
+	/*step 2: init driver data*/
+	drv_data->cfg.i2c = client;
+	drv_data->intf_fn = &intf_i2c_fn;
+	drv_data->bulk_cmd_blocksize = I2C_TX_BULK_SIZE;
+	drv_data->rx_dummy_len = I2C_RX_DUMMY_LEN;
+	misp_info("%s - step2 done.", __func__);
+
+	/*step 3: setup recource : gpio, sem*/
+	if (id->driver_data == MINIISP_I2C_SLAVE) {
+		misp_intf_i2c_slave_data = drv_data;
+		i2c_set_clientdata(client, misp_intf_i2c_slave_data);
+		misp_info("%s - misp_intf_i2c_slave_data set done.", __func__);
+	} else if (id->driver_data == MINIISP_I2C_TOP) {
+		misp_intf_i2c_top_data = drv_data;
+		i2c_set_clientdata(client, misp_intf_i2c_top_data);
+		status = mini_isp_setup_resource(&client->dev, drv_data);
+		if (status < 0) {
+			misp_err("%s step3. probe - setup resource error", __func__);
+			goto setup_i2c_error;
+		}
+		misp_info("%s - misp_intf_i2c_top_data set done.", __func__);
+	}
+
+	set_mini_isp_data(drv_data, INTF_I2C_READY);
+	goto done;
+
+setup_i2c_error:
+	kfree(misp_intf_i2c_slave_data);
+	misp_intf_i2c_slave_data = NULL;
+
+alloc_misp_data_fail:
+
+done:
+	return status;
+
+}
+static int mini_isp_intf_i2c_remove(struct i2c_client *client)
+{
+	struct misp_data *misp_intf_i2c = i2c_get_clientdata(client);
+
+	if (!misp_intf_i2c) {
+		misp_err("%s: i2c data is NULL\n", __func__);
+		return 0;
+	}
+
+	kfree(misp_intf_i2c);
+
+	return 0;
+}
+static const struct of_device_id mini_isp_dt_i2c_slave_match[] = {
+		{  .compatible  =  "altek_i2c_slave",},
+		/*Compatible  node  must  match  dts*/
+		{  },
+		};
+
+MODULE_DEVICE_TABLE(of, mini_isp_dt_i2c_slave_match);
+
+static const struct of_device_id mini_isp_dt_i2c_top_match[] = {
+		{  .compatible  =  "altek_i2c_top",},
+		/*Compatible  node  must  match  dts*/
+		{  },
+		};
+
+MODULE_DEVICE_TABLE(of, mini_isp_dt_i2c_top_match);
+
+static struct i2c_driver mini_isp_intf_i2c_slave = {
+	.driver = {
+		.name =         "altek_i2c_slave",
+		.owner =        THIS_MODULE,
+		.of_match_table  = mini_isp_dt_i2c_slave_match,
+	},
+	.probe =        mini_isp_intf_i2c_probe,
+	.remove =       mini_isp_intf_i2c_remove,
+	.id_table =     mini_isp_intf_i2c_id,
+};
+
+static struct i2c_driver mini_isp_intf_i2c_top = {
+	.driver = {
+		.name =         "altek_i2c_top",
+		.owner =        THIS_MODULE,
+		.of_match_table  = mini_isp_dt_i2c_top_match,
+	},
+	.probe =        mini_isp_intf_i2c_probe,
+	.remove =       mini_isp_intf_i2c_remove,
+	.id_table =     mini_isp_intf_i2c_id,
+};
+
+static int __init mini_isp_intf_i2c_init(void)
+{
+	int state;
+
+	misp_info("%s - start", __func__);
+	state = i2c_add_driver(&mini_isp_intf_i2c_slave);
+	if (state) {
+		misp_info("%s - failed. Error:%d", __func__,state);
+		return state;
+	}
+
+	state = i2c_add_driver(&mini_isp_intf_i2c_top);
+	if (state) {
+		misp_info("%s - failed. Error:%d", __func__,state);
+		return state;
+	}
+
+	misp_info("%s - success", __func__);
+	return state;
+}
+
+static void __exit mini_isp_intf_i2c_exit(void)
+{
+	misp_info("%s", __func__);
+
+	i2c_del_driver(&mini_isp_intf_i2c_slave);
+	i2c_del_driver(&mini_isp_intf_i2c_top);
+
+	return;
+}
+
+module_init(mini_isp_intf_i2c_init);
+module_exit(mini_isp_intf_i2c_exit);
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_intf_spi.c b/drivers/media/platform/msm/camera/al6100/miniisp_intf_spi.c
new file mode 100644
index 0000000..783e24c
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_intf_spi.c
@@ -0,0 +1,607 @@
+/*
+ * File: miniisp_spi.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/04/11; LouisWang; Initial version
+ */
+
+/******Include File******/
+/* Linux headers*/
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/buffer_head.h>
+#include <linux/of_gpio.h>
+
+
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/miniisp_customer_define.h"
+#include "include/miniisp_chip_base_define.h"
+#include "include/altek_statefsm.h"
+
+#include "include/error/miniisp_err.h"
+
+#ifdef ALTEK_TEST
+#include "include/altek_test.h"
+#endif
+
+/******Private Constant Definition******/
+#define SPI_BUS_SPEED 32000000/*(50000000)19200000*/
+#define SPI_BUS_SPEED_BOOT 2000000
+#define SPI_BUS_SPEED_LOW 3000000 //For code persistence mode
+#define DEBUG_NODE 0
+
+/*#define DEBUG_ALERT*/
+#define MINI_ISP_LOG_TAG "[miniisp_intf_spi]"
+
+/****************************************************************************
+*                          Private Global Variable                          *
+****************************************************************************/
+static struct misp_data *misp_intf_spi_data;
+struct file *filp[4];
+//static char spi_databuffer[TX_BUF_SIZE + 1]; /*add 1 for the ctrl byte*/
+static u8 *spi_bulkbuffer;
+/****************************************************************************
+*                        Private Function Prototype                         *
+****************************************************************************/
+
+/**********************************************************************
+*                         Public Function                             *
+**********************************************************************/
+extern int mini_isp_setup_resource(struct device *dev, struct misp_data *drv_data);
+
+
+/******Public Function******/
+struct misp_data *get_mini_isp_intf_spi(void)
+{
+	if (!misp_intf_spi_data) {
+		misp_err("%s - get pdata error", __func__);
+		return NULL;
+	} else {
+		return misp_intf_spi_data;
+	}
+}
+
+#ifdef _SPI_DEBUG
+void spi_data_debug(const void *buf, int data_len, int dbg_len)
+{
+	int len = 0, pos = 0;
+	unsigned char *char_buf = (unsigned char *)buf;
+	   unsigned char string[100], temp[4];
+
+	   memset(string, 0, sizeof(string));
+
+	len = (dbg_len > data_len) ? data_len : dbg_len;
+
+	pos = 0;
+	while (len > 0) {
+		if (len > 7) {
+			misp_info("%02x %02x %02x %02x %02x %02x %02x %02x",
+			char_buf[pos], char_buf[pos+1], char_buf[pos+2],
+			char_buf[pos+3], char_buf[pos+4], char_buf[pos+5],
+			char_buf[pos+6], char_buf[pos+7]);
+
+			len -= 8;
+			pos += 8;
+		} else {
+			for ( ; len > 0; len--) {
+				snprintf(temp, 4, "%02x ", char_buf[pos++]);
+				strlcat(string, temp, 8);
+			}
+			misp_info("%s", string);
+		}
+	}
+}
+#else
+#define spi_data_debug(buf, data_len, dbg_len)
+#endif
+
+int mini_isp_dma_write(struct spi_device *spi, u8 *tx_buf, u32 len)
+{
+	int state;
+	dma_addr_t bus_addr;
+
+	struct spi_transfer t = {
+		.tx_buf		= tx_buf,
+		.len		= len,
+	};
+	struct spi_message	m;
+
+	misp_info("%s - entering ", __func__);
+
+	spi_message_init(&m);
+
+	bus_addr = dma_map_single(&spi->dev, tx_buf, len, DMA_TO_DEVICE);
+
+	if (!bus_addr) {
+		misp_err("%s dma mapping failed.", __func__);
+		state = -ENOMEM;
+		goto mini_isp_dma_write_end;
+	}
+
+	t.tx_dma = bus_addr;
+	m.is_dma_mapped = 1;
+
+	spi_message_add_tail(&t, &m);
+
+	state = spi_sync(spi, &m);
+
+	dma_unmap_single(&spi->dev, bus_addr, len, DMA_TO_DEVICE);
+
+	misp_info("%s - leave   ", __func__);
+
+mini_isp_dma_write_end:
+
+	return state;
+}
+
+/****************************************************************************
+*			Private Function				*
+****************************************************************************/
+
+/*read command from device ,this function will block.
+ *return 0  successful
+ *others	fail
+ */
+
+static int mini_isp_intf_spi_read(void *dev, u8 *tx_buf, u32 tx_len, u8 *rx_buf, u32 rx_len)
+{
+	struct spi_transfer t = {
+		.tx_buf		= tx_buf,
+		.rx_buf		= rx_buf,
+		.len		= tx_len + rx_len,
+		.delay_usecs = 1,
+		.speed_hz	= SPI_BUS_SPEED,
+		};
+	struct spi_message m;
+	struct misp_global_variable *misp_drv_global;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_drv_global = get_mini_isp_global_variable();
+
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata = %p, len = %d", __func__, devdata, tx_len + rx_len);
+		return -EINVAL;
+	}
+
+	if (misp_drv_global->before_booting)
+		t.speed_hz = SPI_BUS_SPEED_BOOT;
+	else if (misp_drv_global->spi_low_speed_mode)
+		t.speed_hz = SPI_BUS_SPEED_LOW;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(devdata->cfg.spi, &m);
+}
+
+
+/*write commadn to device ,this fucntion will block.
+ *return 0  successful
+ *others	fail
+ */
+static int mini_isp_intf_spi_write(void *dev, u8 *tx_buf, u8 *rx_buf, u32 len)
+{
+	struct spi_transfer t = {
+		.tx_buf		= tx_buf,
+		.rx_buf		= rx_buf,
+		.len		= len,
+		.delay_usecs = 1,
+		.speed_hz	= SPI_BUS_SPEED,
+		};
+	struct spi_message m;
+	struct misp_global_variable *misp_drv_global;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_drv_global = get_mini_isp_global_variable();
+	if (!devdata) {
+		misp_err("%s - invalid arg devdata = %p, len = %d", __func__, devdata, len);
+		return -EINVAL;
+	}
+
+	if (misp_drv_global->before_booting)
+		t.speed_hz = SPI_BUS_SPEED_BOOT;
+	else if (misp_drv_global->spi_low_speed_mode)
+		t.speed_hz = SPI_BUS_SPEED_LOW;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(devdata->cfg.spi, &m);
+}
+
+/*
+ *write command data to spi
+ *return 0  successful
+ *others	fail
+ */
+static int mini_isp_intf_spi_send(void *dev, u32 len)
+{
+	int status;
+	u8 check = USPICTRL_MS_CB_ORG;
+	u8 spi_databuffer[TX_BUF_SIZE + 1] = {0};
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	if ((!devdata) || (len > TX_BUF_SIZE)) {
+		misp_err("%s - invalid arg devdata = %p, len = %d", __func__,
+			devdata, len);
+		return -EINVAL;
+	}
+
+	/*put the ctrl byte in the first byte, then put the following data.*/
+	spi_databuffer[0] = check;
+
+	memcpy(spi_databuffer + 1, devdata->tx_buf, len);
+
+	status = mini_isp_intf_spi_write(devdata, spi_databuffer,
+			NULL, len + 1);
+	if (status) {
+		misp_err("%s - sync error: status = %d", __func__, status);
+		return status;
+	}
+
+	return status;
+}
+
+/* read miniISP using spi ,this fucntion will block.
+ *return 0  successful
+ *others	fail
+ */
+static int mini_isp_intf_spi_recv(void *dev, u32 len, bool waitINT)
+{
+	int status;
+	u8 ctrlbyte = USPICTRL_MS_CB_RSP;
+	int i = 0;
+	int original_altek_spi_mode;
+	u32 altek_event_state;
+	u8 spi_databuffer[TX_BUF_SIZE + 1] = {0};
+	struct misp_global_variable *dev_global_variable;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_err("%s - enter", __func__);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	original_altek_spi_mode = dev_global_variable->altek_spi_mode;
+	if ((!devdata) || (len > RX_BUF_SIZE)) {
+		misp_err("%s - invalid arg devdata = %p, len = %d",
+			__func__, devdata, len);
+		status = -EINVAL;
+		goto mini_isp_intf_spi_recv_end;
+	}
+
+	 memset(spi_databuffer, 0, RX_BUF_SIZE + 1);
+
+	if (waitINT) {
+		/*wait for the interrupt*/
+		status = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	} else {
+		if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+			(original_altek_spi_mode == ALTEK_SPI_MODE_A))
+			mini_isp_a_to_e();
+		for (i = 0; i < 200; i++) {
+			status = mini_isp_get_altek_status(devdata,
+				&altek_event_state);
+			if (altek_event_state & COMMAND_COMPLETE) {
+				altek_event_state = (altek_event_state &
+					~((~0) << 1));
+				mini_isp_register_write(INTERRUPT_STATUS_REGISTER_ADDR, altek_event_state);
+				break;
+			}
+			mdelay(5);
+		}
+		if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+			(original_altek_spi_mode !=
+			dev_global_variable->altek_spi_mode))
+			mini_isp_e_to_a();
+		if (i >= 200) {
+			misp_err("%s time out.", __func__);
+			status = ERR_MINIISP_GETDATA_TIMEOUT;
+			goto mini_isp_intf_spi_recv_end;
+		}
+	}
+
+	if (status) {
+		misp_err("%s - irq error: status = %d", __func__, status);
+		goto mini_isp_intf_spi_recv_end;
+	}
+
+	/*send the ctrl byte and get the data in full duplex mode*/
+	/*the data is stored from the 2nd byte*/
+	spi_databuffer[0] = ctrlbyte;
+	status = mini_isp_intf_spi_read(devdata, spi_databuffer, 1, spi_databuffer + 1, len);
+	if (status) {
+		misp_err("%s - sync error: status = %d", __func__, status);
+		goto mini_isp_intf_spi_recv_end;
+	}
+
+	memcpy(devdata->rx_buf, spi_databuffer + 1, len);
+
+	misp_info("%s - recv buf len = %d:", __func__, len);
+	spi_data_debug(devdata->rx_buf, RX_BUF_SIZE, len);
+
+mini_isp_intf_spi_recv_end:
+	return status;
+}
+
+/*used to send the firmware*/
+static int mini_isp_intf_spi_send_bulk(void *dev, struct file *filp,
+	u32 total_size, u32 block_size, bool is_raw, u8 *spi_Sendbulkbuffer)
+{
+	int status = 0, count = 0;
+	int remain_size, one_size;
+	u8 ctrlbyte = USPICTRL_MS_CB_DIS, ack[2];
+	mm_segment_t oldfs;
+	loff_t  offset;
+	int shift = 0;
+	struct misp_data *devdata = (struct misp_data *)dev;
+
+	misp_info("%s - entering", __func__);
+
+	if (spi_Sendbulkbuffer != NULL) {
+		misp_info("%s start. Total size: %d.", __func__, total_size);
+		if (!is_raw) {
+			/*send the ctrl byte*/
+			status = mini_isp_intf_spi_read(devdata, &ctrlbyte,
+						1, ack, 2);
+			if (status) {
+				misp_err("%s send ctrlbyte fail status: %d",
+					__func__, status);
+				status = -EINVAL;
+				goto T_EXIT;
+			}
+		}
+
+		/* Allocate basic code bulk buffer*/
+		if (total_size > SPI_TX_BULK_SIZE)
+			spi_bulkbuffer = kzalloc(SPI_TX_BULK_SIZE, GFP_DMA);
+		/* Allocate boot code bulk buffer*/
+		else
+			spi_bulkbuffer = kzalloc(total_size, GFP_DMA);
+
+		if (!spi_bulkbuffer) {
+			misp_err("%s - Can not alloc SPI bulk buffer",
+				__func__);
+			status = -EINVAL;
+			goto T_EXIT;
+		}
+
+		for (remain_size = total_size; remain_size > 0;
+			remain_size -= one_size) {
+			one_size = (remain_size > block_size) ?
+				block_size : remain_size;
+
+
+			misp_info("remain size: %d one_size: %d.",
+				remain_size, one_size);
+
+			memcpy(spi_bulkbuffer, (spi_Sendbulkbuffer + shift),
+				one_size);
+			shift += one_size;
+
+			/*send the data*/
+			status = mini_isp_intf_spi_write(devdata,
+					spi_bulkbuffer, NULL, one_size);
+
+			if (status != 0) {
+				misp_err(
+				"%s failed! block:%d status:%d",
+				__func__, count, status);
+				break;
+			}
+
+			misp_info("%s write block %d success",
+				__func__, count);
+
+			count++;
+		}
+
+	} else {
+		oldfs = get_fs();
+
+		set_fs(get_ds());
+
+		misp_info("%s start. Total size: %d", __func__, total_size);
+
+		if (!is_raw) {
+			/*send the ctrl byte*/
+			status = mini_isp_intf_spi_read(devdata, &ctrlbyte,
+						1, ack, 2);
+			misp_info("%s is not raw", __func__);
+			if (status) {
+				misp_err("%s ctrl byte fail status: %d",
+				__func__, status);
+				status = -EINVAL;
+				goto T_EXIT;
+			}
+		}
+
+		/* Allocate basic code bulk buffer*/
+		if (total_size > SPI_TX_BULK_SIZE_BOOT)
+			spi_bulkbuffer = kzalloc(SPI_TX_BULK_SIZE, GFP_DMA);
+		/* Allocate boot code bulk buffer*/
+		else
+			spi_bulkbuffer = kzalloc(SPI_TX_BULK_SIZE_BOOT, GFP_DMA);
+
+
+		if (!spi_bulkbuffer) {
+			misp_err("%s - Can not alloc SPI bulk buffer",
+				__func__);
+			status = -EINVAL;
+			goto T_EXIT;
+		}
+
+		for (remain_size = total_size; remain_size > 0;
+			remain_size -= one_size) {
+			one_size = (remain_size > block_size) ?
+				block_size : remain_size;
+
+			misp_info("remain size: %d one_size: %d",
+				remain_size, one_size);
+
+			/*copy the firmware to the buffer*/
+			offset = filp->f_pos;
+			status = vfs_read(filp, spi_bulkbuffer, one_size,
+					&offset);
+
+			if (status == -1) {
+				misp_info("%s Read file failed.", __func__);
+				break;
+			}
+
+			filp->f_pos = offset;
+
+			/*send the data*/
+			status = mini_isp_intf_spi_write(devdata,
+				spi_bulkbuffer, NULL, one_size);
+			if (status != 0) {
+				misp_err("%s send fail, block:%d status: %d",
+					__func__, count, status);
+				break;
+			}
+
+			misp_info("%s write block %d success",
+				__func__, count);
+
+			count++;
+		}
+	}
+T_EXIT:
+	if (filp && (spi_Sendbulkbuffer == NULL))
+		set_fs(oldfs);
+	/* Free SPI bulk buffer*/
+	if (spi_bulkbuffer != NULL) {
+		kfree(spi_bulkbuffer);
+		spi_bulkbuffer = NULL;
+	}
+
+	if (status != ERR_SUCCESS)
+		misp_err("%s error: %d", __func__, status);
+	else
+		misp_info("%s success", __func__);
+
+	return status;
+}
+
+static struct misp_intf_fn_t intf_spi_fn = {
+	.send = mini_isp_intf_spi_send,
+	.recv = mini_isp_intf_spi_recv,
+	.read = mini_isp_intf_spi_read,
+	.write = mini_isp_intf_spi_write,
+	.send_bulk = mini_isp_intf_spi_send_bulk,
+};
+extern struct altek_statefsm *altek_state;
+static int mini_isp_intf_spi_probe(struct spi_device *spi)
+{
+	int status = 0;
+	struct altek_statefsm *fsm = NULL;
+
+	misp_info("%s - start", __func__);
+
+	/*step 1: alloc driver data struct*/
+	misp_intf_spi_data = kzalloc(sizeof(struct misp_data), GFP_KERNEL);
+	if (!misp_intf_spi_data) {
+		misp_err("%s step1. probe - alloc misp_intf_spi_data error", __func__);
+		return -ENOMEM;
+	}
+	misp_info("%s - step1 done.", __func__);
+
+	/*step 2: init driver data*/
+	misp_intf_spi_data->cfg.spi = spi;
+	misp_intf_spi_data->intf_fn = &intf_spi_fn;
+	misp_intf_spi_data->bulk_cmd_blocksize = SPI_TX_BULK_SIZE;
+	misp_intf_spi_data->rx_dummy_len = SPI_RX_DUMMY_LEN;
+	//sema_init(&misp_intf_spi_data->cmd_respond, 1);
+	misp_info("%s - step2 done.", __func__);
+
+	/*step 3: setup spi*/
+	spi->mode = SPI_MODE;
+	spi->max_speed_hz = SPI_BUS_SPEED_BOOT;
+	spi->bits_per_word = 8;
+	status = spi_setup(spi);
+	if (status < 0) {
+		misp_err("%s step3. probe - setup spi error", __func__);
+		goto setup_spi_error;
+	}
+	misp_info("%s - step3 done.", __func__);
+
+	/*step 3: setup recource : gpio, sem*/
+	status = mini_isp_setup_resource(&spi->dev, misp_intf_spi_data);
+	if (status < 0) {
+		misp_err("%s step4. probe - setup resource error", __func__);
+		goto setup_spi_error;
+	}
+	misp_info("%s - step4 done.", __func__);
+
+	/*setp last: set driver_data to device*/
+	spi_set_drvdata(spi, misp_intf_spi_data);
+	set_mini_isp_data(misp_intf_spi_data, INTF_SPI_READY);
+
+	misp_info("%s -success", __func__);
+	fsm = altek_statefsmcreate();
+	altek_state = fsm;
+	mini_isp_poweron();
+	mini_isp_get_chip_id(CHIP_ID_ADDR, NULL);
+	//mini_isp_poweroff();
+	goto probe_done;
+
+setup_spi_error:
+	kfree(misp_intf_spi_data);
+	misp_intf_spi_data = NULL;
+
+probe_done:
+	return status;
+}
+
+static int mini_isp_intf_spi_remove(struct spi_device *spi)
+{
+	//free_irq(misp_intf_spi_data->irq, misp_intf_spi_data);
+	kfree(misp_intf_spi_data);
+	return 0;
+}
+
+/*Compatible node must match dts*/
+static const struct of_device_id mini_isp_dt_spi_match[] = {
+	{  .compatible = "altek,altek_isp",},
+	{  },
+};
+MODULE_DEVICE_TABLE(of, mini_isp_dt_spi_match);
+
+
+static struct spi_driver mini_isp_intf_spi = {
+	.driver = {
+		.name   = "altek_isp",
+		.owner  = THIS_MODULE,
+		.of_match_table = mini_isp_dt_spi_match,
+	},
+	.probe = mini_isp_intf_spi_probe,
+	.remove = mini_isp_intf_spi_remove,
+};
+
+static int __init mini_isp_intf_spi_init(void)
+{
+	int state;
+
+	misp_info("%s - start", __func__);
+	state = spi_register_driver(&mini_isp_intf_spi);
+	if (state) {
+		misp_err("%s - regsiter failed. Errorcode:%d",
+			__func__, state);
+		return state;
+	}
+
+	misp_info("%s - success", __func__);
+	return state;
+}
+
+static void __exit mini_isp_intf_spi_exit(void)
+{
+	misp_info("%s", __func__);
+	spi_unregister_driver(&mini_isp_intf_spi);
+}
+
+module_init(mini_isp_intf_spi_init);
+module_exit(mini_isp_intf_spi_exit);
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_isp.c b/drivers/media/platform/msm/camera/al6100/miniisp_isp.c
new file mode 100644
index 0000000..ad75dcd
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_isp.c
@@ -0,0 +1,432 @@
+/*
+ * File: miniisp_spi.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/04/11; LouisWang; Initial version
+ */
+
+/************************************************************
+*            Include File                                   *
+*************************************************************/
+/* Linux headers*/
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/buffer_head.h>
+#include <linux/of_gpio.h>
+
+
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/miniisp_customer_define.h"
+#include "include/miniisp_chip_base_define.h"
+#include "include/altek_statefsm.h"
+
+#include "include/error/miniisp_err.h"
+
+
+#include "include/miniisp_ctrl_intf.h"
+#ifdef ALTEK_TEST
+#include "include/altek_test.h"
+#endif
+
+/****************************************************************************
+*			             Private Constant Definition	                    *
+****************************************************************************/
+/*#define DEBUG_ALERT*/
+#define MINI_ISP_LOG_TAG "[miniisp_isp]"
+/*drv debug defination*/
+#define _SPI_DEBUG
+
+/****************************************************************************
+*                        Private Global Variable                            *
+****************************************************************************/
+static struct misp_global_variable *misp_drv_global_variable;
+static struct class *mini_isp_class;
+static struct device *mini_isp_dev;
+struct altek_statefsm *altek_state;
+static int dump_reg_range;
+// ALTEK_AL6100_ECHO >>>
+struct file *l_internal_file[OTHER_MAX];
+// ALTEK_AL6100_ECHO <<<
+/************************************************************
+*          Public Global Variable                           *
+*************************************************************/
+
+/************************************************************
+*          Private Macro Definition                         *
+*************************************************************/
+
+/************************************************************
+*          Public Function Prototype                        *
+*************************************************************/
+/// AL6100 debug tool >>>
+extern struct device *miniisp_chdev_create(struct class *mini_isp_class);
+/// AL6100 debug tool <<<
+extern struct misp_data *get_mini_isp_intf_spi(void);
+extern struct misp_data *get_mini_isp_intf_i2c(int i2c_type);
+//extern struct misp_data *get_mini_isp_intf_cci(int i2c_type);
+
+/************************************************************
+*                    Private Function                       *
+*************************************************************/
+
+static ssize_t mini_isp_mode_config_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	/*misp_info("%s - mini_isp_spi_send return %d", __func__, ret);*/
+	return snprintf(buf, 32, "load fw:0 e_to_a:1 a_to_e:2\n");
+}
+
+static ssize_t mini_isp_mode_config_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	u8 buf_chip_id_use[4];
+
+	if ('0' == buf[0]) {
+		mini_isp_poweron();
+		mini_isp_get_chip_id(CHIP_ID_ADDR, buf_chip_id_use);
+		mini_isp_chip_init();
+		mini_isp_e_to_a();
+	} else if ('1' == buf[0]) {
+		mini_isp_chip_init();
+		mini_isp_e_to_a();
+	} else if ('2' == buf[0]) {
+		mini_isp_a_to_e();
+	} else if ('4' == buf[0]) {
+		mini_isp_drv_load_fw();
+	} else if ('7' == buf[0]) {
+		buf_chip_id_use[0] = 0;
+		mini_isp_debug_dump_img();
+		mini_isp_a_to_e();
+		mini_isp_chip_base_dump_irp_and_depth_based_register();
+		mini_isp_memory_write(0x10, buf_chip_id_use, 1);
+		mini_isp_e_to_a();
+// ALTEK_AL6100_ECHO >>>
+	}  else if ('5' == buf[0]) {
+	   struct isp_cmd_led_power_control control_param;
+	   struct isp_cmd_active_ae active_ae;
+	   memset(&control_param, 0, sizeof(struct isp_cmd_led_power_control));
+	   memset(&active_ae, 0, sizeof(struct isp_cmd_active_ae));
+	   // open auto depth mode
+	   mini_isp_poweron();
+
+	   if(0 != mini_isp_drv_setting(MINI_ISP_MODE_GET_CHIP_ID)){
+				misp_err("get chip id failed \n");
+	   }
+	   if(0 != mini_isp_drv_setting(MINI_ISP_MODE_CHIP_INIT)){ //if boot form SPI NOR, do not call this
+				misp_err("chip init failed \n");
+	   }
+	   if(0 != mini_isp_drv_setting(MINI_ISP_MODE_E2A)){
+				misp_err("change MINI_ISP_MODE_E2A failed failed \n");
+	   }
+	   if(0 != mini_isp_drv_setting(MINI_ISP_MODE_NORMAL)){
+				misp_err("misp_load_fw failed \n");
+	   }
+
+
+
+		mini_isp_other_drv_open(IQCALIBRATIONDATA_FILE_LOCATION, IQ_CODE);
+		mini_isp_other_drv_read(l_internal_file[IQ_CODE], IQ_CODE); // IQ calibration data
+
+		mini_isp_other_drv_open(DEPTHPACKDATA_FILE_LOCATION, DEPTH_CODE);
+		mini_isp_other_drv_read(l_internal_file[DEPTH_CODE], DEPTH_CODE); // Depth calibration data
+
+		mini_isp_drv_write_calibration_data(2, NULL, 0); // Scenario table
+		mini_isp_drv_write_calibration_data(3, NULL, 0); // HDR Qmerge
+		mini_isp_drv_write_calibration_data(4, NULL, 0); // IRP0 Qmerge
+		mini_isp_drv_write_calibration_data(5, NULL, 0); // IRP1 Qmerge
+		// mini_isp_drv_write_calibration_data(7, NULL, 0); // Blending table for ground depth
+		// mini_isp_drv_write_calibration_data(8, NULL, 0); // Depth Qmerge
+
+		// set depth output resolution
+		mini_isp_drv_set_output_format(19, 7);// set depth output resolution
+		active_ae.active_ae = 1;
+		active_ae.f_number_x1000 = 2000;
+		mini_isp_drv_active_ae(&active_ae);
+		mini_isp_drv_set_sensor_mode(1,4,0,0,0);  // Set sensor mode
+		//projector control
+		control_param.led_on_off = 1;
+		control_param.control_mode = 3;
+		control_param.led_power_level = 255;
+		control_param.control_projector_id = 0;
+		mini_isp_drv_led_power_control(&control_param);
+		mini_isp_drv_preview_stream_on_off(1,1); // open preview
+		mini_isp_drv_isp_ae_control_mode_on_off(1);
+		}else if ('6' == buf[0]) {
+		 // close auto depth mode
+		 struct isp_cmd_led_power_control control_param;
+		 struct isp_cmd_active_ae active_ae;
+		 memset(&control_param, 0, sizeof(struct isp_cmd_led_power_control));
+		 memset(&active_ae, 0, sizeof(struct isp_cmd_active_ae));
+		 mini_isp_drv_preview_stream_on_off(0,0); // close preview
+		 mini_isp_drv_isp_ae_control_mode_on_off(0);
+		 mini_isp_drv_led_power_control(&control_param);
+		 mini_isp_drv_set_sensor_mode(0,0,0,0,0);  // Set sensor mode
+		 mini_isp_drv_active_ae(&active_ae);
+		 mini_isp_drv_set_output_format(0,0); // set depth output resolution:
+		 // ALTEK_AL6100_ECHO >>>	                 // 0: Disable depth function (Depth engine is disable)
+	}  else {
+		//mini_isp_poweron();
+		mini_isp_get_chip_id(CHIP_ID_ADDR, buf_chip_id_use);
+		mini_isp_pure_bypass(1);
+	}
+	return size;
+}
+
+static DEVICE_ATTR(mini_isp_mode_config, 0660, mini_isp_mode_config_show,
+		mini_isp_mode_config_store);
+
+static ssize_t mini_isp_reset_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int ret = -EINVAL;
+
+	ret = gpio_get_value(misp_drv_global_variable->reset_gpio);
+	misp_info("%s - reset_gpio is %d", __func__, ret);
+
+	return snprintf(buf, 32, "%d", ret);
+}
+
+static ssize_t mini_isp_reset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	if ('0' == buf[0])
+		gpio_set_value(misp_drv_global_variable->reset_gpio, 0);
+	else
+		gpio_set_value(misp_drv_global_variable->reset_gpio, 1);
+
+	misp_info("%s - ", __func__);
+
+	return size;
+}
+
+static DEVICE_ATTR(mini_isp_reset, 0660, mini_isp_reset_show, mini_isp_reset_store);
+
+
+static ssize_t mini_isp_poweron_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int ret = -EINVAL;
+
+	ret = gpio_get_value(misp_drv_global_variable->vcc1_gpio);
+	misp_info("%s - vcc1_gpio is %d", __func__, ret);
+	return snprintf(buf, 32, "%d", ret);
+}
+
+static ssize_t mini_isp_poweron_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	/*int ret = -EINVAL;*/
+	if ('1' == buf[0])
+		mini_isp_poweron();
+	else
+		mini_isp_poweroff();
+
+	misp_info("%s - ", __func__);
+
+	return size;
+}
+
+static DEVICE_ATTR(mini_isp_poweron, S_IRUSR | S_IWUSR, mini_isp_poweron_show,
+		mini_isp_poweron_store);
+
+static ssize_t mini_isp_dump_reg_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int ret = -EINVAL;
+
+	misp_info("%s - enter", __func__);
+	mini_isp_a_to_e();
+	if (dump_reg_range == 0)
+		ret = mini_isp_utility_read_reg_e_mode();
+	else if (dump_reg_range == 1)
+		ret = mini_isp_utility_read_reg_e_mode_for_bypass_use();
+	else
+		ret = mini_isp_chip_base_dump_irp_and_depth_based_register();
+
+	if (!ret)
+		return snprintf(buf, 32, "dump reg success!!\n");
+	else
+		return snprintf(buf, 32, "dump reg fail!!\n");
+}
+
+static ssize_t mini_isp_dump_reg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	/*int ret = -EINVAL;*/
+	/*0 means dump all reg value, 1 means dump bypass mode reg value */
+	if ('0' == buf[0])
+		dump_reg_range = 0;
+	else if ('1' == buf[0])
+		dump_reg_range = 1;
+	else
+		dump_reg_range = 2;
+	misp_info("%s - ", __func__);
+
+	return size;
+}
+
+static DEVICE_ATTR(mini_isp_dump_reg, 0660, mini_isp_dump_reg_show,
+		mini_isp_dump_reg_store);
+
+
+
+/************************************************************
+*                    Public Function                        *
+*************************************************************/
+
+struct misp_data *get_mini_isp_intf(int i2c_type)
+{
+	if (misp_drv_global_variable->intf_status & INTF_SPI_READY) {
+		return get_mini_isp_intf_spi();
+	} else if (misp_drv_global_variable->intf_status & INTF_I2C_READY) {
+		return get_mini_isp_intf_i2c(i2c_type);
+	/*} else if (misp_drv_global_variable->intf_status & INTF_CCI_READY) {
+		return get_mini_isp_intf_cci(i2c_type);*/
+	} else {
+		misp_err("%s - error i2c type %d", __func__,i2c_type);
+		return NULL;
+	}
+}
+void set_mini_isp_data(struct misp_data *data, int intf_type)
+{
+	if (!misp_drv_global_variable) {
+		misp_err("%s - set global_variable error", __func__);
+	} else {
+		misp_drv_global_variable->intf_status |= intf_type;
+	}
+}
+
+struct misp_global_variable *get_mini_isp_global_variable(void)
+{
+	if (!misp_drv_global_variable) {
+		misp_err("%s - get global_variable error", __func__);
+		return NULL;
+	} else {
+		return misp_drv_global_variable;
+	}
+}
+
+struct altek_statefsm *get_mini_isp_fsm(void)
+{
+	if (!altek_state) {
+		misp_err("%s - get fsm error", __func__);
+		return NULL;
+	} else {
+		return altek_state;
+	}
+}
+
+
+int mini_isp_setup_resource(struct device *dev, struct misp_data *drv_data)
+{
+	int status = 0;
+	misp_info("%s - start", __func__);
+	if (misp_drv_global_variable != NULL ) {
+		misp_err("%s - resource already been setupped", __func__);
+		goto setup_done;
+	}
+
+	/*step 1: alloc misp_drv_global_variable*/
+	misp_drv_global_variable = kzalloc(sizeof(*misp_drv_global_variable), GFP_KERNEL);
+	if (!misp_drv_global_variable) {
+		misp_info("%s - Out of memory", __func__);
+		status = -ENOMEM;
+		goto alloc_fail;
+	}
+	misp_info("%s - step1 done.", __func__);
+
+	/*step 2: init mutex and gpio resource*/
+	mutex_init(&misp_drv_global_variable->busy_lock);
+	status = mini_isp_gpio_init(dev, drv_data, misp_drv_global_variable);
+	if (status < 0) {
+		misp_info("%s - gpio init fail", __func__);
+		goto setup_fail;
+	}
+	misp_info("%s - step2 done.", __func__);
+
+	misp_drv_global_variable->before_booting = 1;
+
+
+	/*step 3: register to VFS as character device*/
+	mini_isp_class = class_create(THIS_MODULE, "mini_isp");
+	if (IS_ERR(mini_isp_class))
+		misp_err("Failed to create class(mini_isp_class)!");
+	mini_isp_dev = miniisp_chdev_create(mini_isp_class);
+	if (IS_ERR(mini_isp_dev))
+		misp_err("Failed to create device(mini_isp_dev)!");
+
+	status = device_create_file(mini_isp_dev, &dev_attr_mini_isp_mode_config);
+	if (status < 0)
+		misp_err("Failed to create device file(%s)!", dev_attr_mini_isp_mode_config.attr.name);
+
+	if (RESET_GPIO != NULL) {
+		status = device_create_file(mini_isp_dev, &dev_attr_mini_isp_reset);
+		if (status < 0)
+			misp_err("Failed to create device file(%s)!", dev_attr_mini_isp_reset.attr.name);
+	}
+
+	status = device_create_file(mini_isp_dev, &dev_attr_mini_isp_poweron);
+	if (status < 0)
+		misp_err("Failed to create device file(%s)!", dev_attr_mini_isp_poweron.attr.name);
+
+	status = device_create_file(mini_isp_dev, &dev_attr_mini_isp_dump_reg);
+	if (status < 0)
+		misp_err("Failed to create device file(%s)!", dev_attr_mini_isp_dump_reg.attr.name);
+
+	misp_info("%s - step3 done.", __func__);
+
+	misp_info("%s - success.", __func__);
+	goto setup_done;
+
+setup_fail:
+	mutex_destroy(&misp_drv_global_variable->busy_lock);
+	kfree(misp_drv_global_variable);
+
+alloc_fail:
+	misp_drv_global_variable = NULL;
+
+setup_done:
+	return status;
+}
+
+static int __init mini_isp_init(void)
+{
+	int ret = 0;
+	//struct altek_statefsm *fsm = NULL;
+
+	misp_info("%s - start", __func__);
+
+	//fsm = altek_statefsmcreate();
+	//altek_state = fsm;
+
+	misp_info("%s - success", __func__);
+
+	return ret;
+}
+
+static void __exit mini_isp_exit(void)
+{
+	misp_info("%s", __func__);
+	//free_irq(misp_drv_data->spi->irq, misp_drv_data);
+	if (misp_drv_global_variable->irq_gpio)
+		gpio_free(misp_drv_global_variable->irq_gpio);
+
+	if (misp_drv_global_variable)
+		kfree(misp_drv_global_variable);
+	//spi_unregister_driver(&mini_isp_drv);
+
+	altek_statefsmdelete(altek_state);
+	altek_state = NULL;
+}
+
+module_init(mini_isp_init);
+module_exit(mini_isp_exit);
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_top.c b/drivers/media/platform/msm/camera/al6100/miniisp_top.c
new file mode 100644
index 0000000..a3fa836
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_top.c
@@ -0,0 +1,1681 @@
+/*
+ * File: miniisp_top.c
+ * Description: Mini ISP sample codes
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/04/11; LouisWang; Initial version
+ */
+
+ /******Include File******/
+ /* Linux headers*/
+#include <linux/delay.h>
+#include <linux/buffer_head.h>
+
+#include "include/miniisp.h"
+#include "include/miniisp_ctrl.h"
+#include "include/miniisp_customer_define.h"
+#include "include/miniisp_chip_base_define.h"
+
+#include "include/error/miniisp_err.h"
+
+/****************************************************************************
+*                        Private Constant Definition                        *
+****************************************************************************/
+
+#define MINI_ISP_LOG_TAG "[miniisp_top]"
+static bool irqflag;
+static u32 event = MINI_ISP_RCV_WAITING;
+static u32 current_event = MINI_ISP_RCV_WAITING;
+static DECLARE_WAIT_QUEUE_HEAD(WAITQ);
+/**********************************************************************
+*                         Public Function                             *
+**********************************************************************/
+int mini_isp_get_chip_id(u32 mini_isp_reg_addr, u8 *id_buf)
+{
+	int status = ERR_SUCCESS;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 ctrlbyte = CTRL_BYTE_REGRD;
+	u32 address = mini_isp_reg_addr;
+	struct misp_data *devdata;
+	struct misp_global_variable *dev_global_variable;
+	u8 send_buffer_value[64] = {0};
+	u8 recv_buffer_value[64] = {0};
+	u32 rx_dummy_len;
+
+	misp_info("%s - enter", __func__);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	send_buffer = send_buffer_value;
+	recv_buffer = recv_buffer_value;
+	rx_dummy_len = devdata->rx_dummy_len;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+
+	status = devdata->intf_fn->read(devdata,
+					send_buffer_value, EMODE_TXCMD_LEN,
+					recv_buffer_value, rx_dummy_len + 4); //4bytes chip id value
+
+	if (status) {
+		misp_err("%s - sync error: status=%d", __func__, status);
+		goto mini_isp_get_chip_id_end;
+	}
+
+	if (rx_dummy_len > 0 &&
+		mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+		misp_err("[miniISP]Can't get chip ID");
+		goto mini_isp_get_chip_id_end;
+	}
+
+	misp_err("[miniISP]Get Chip ID %x %x %x %x",
+				*recv_buffer, *(recv_buffer + 1),
+				*(recv_buffer + 2), *(recv_buffer + 3));
+
+mini_isp_get_chip_id_end:
+	return status;
+}
+
+
+void mini_isp_register_write(u32 reg_addr, u32 reg_new_value)
+{
+	u8 *send_buffer;
+	u8 ctrlbyte = CTRL_BYTE_REGWR;
+	u32 address = reg_addr, value = reg_new_value;
+	struct misp_data *devdata;
+	//u8 send_buffer_value[64];
+	struct misp_global_variable *dev_global_variable;
+	misp_info("%s - enter, reg_addr[%#08x], write_value[%#08x]",
+		__func__, reg_addr, reg_new_value);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	send_buffer = devdata->tx_buf;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+	memcpy(send_buffer + 5, &value, 4);
+	dev_global_variable->before_booting = 1;
+	devdata->intf_fn->write(devdata, devdata->tx_buf, devdata->rx_buf, 9);
+	dev_global_variable->before_booting = 0;
+}
+
+void mini_isp_register_write_one_bit(u32 reg_addr, u8 bit_offset, u8 bit_value)
+{
+	u8 *send_buffer;
+	u32 reg_value;
+	u8 ctrlbyte = CTRL_BYTE_REGWR;
+	u32 address = reg_addr;
+	struct misp_data *devdata;
+	//u8 send_buffer_value[64];
+	struct misp_global_variable *dev_global_variable;
+	misp_info("%s - enter", __func__);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	send_buffer = devdata->tx_buf;
+
+	mini_isp_register_read(reg_addr, &reg_value);
+
+	if (bit_value)
+		reg_value |= 1UL << bit_offset;
+	else
+		reg_value &= ~(1UL << bit_offset);
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+	memcpy(send_buffer + 5, &reg_value, 4);
+	dev_global_variable->before_booting = 1;
+	devdata->intf_fn->write(devdata, devdata->tx_buf, devdata->rx_buf, 9);
+	dev_global_variable->before_booting = 0;
+}
+
+
+void mini_isp_register_write_bit_field(u32 reg_addr, u32 mask, u32 mask_value)
+{
+	u8 *send_buffer;
+	u32 reg_value;
+	u8 ctrlbyte = CTRL_BYTE_REGWR;
+	u32 address = reg_addr, value;
+	struct misp_data *devdata;
+	//u8 send_buffer_value[64];
+	struct misp_global_variable *dev_global_variable;
+	misp_info("%s - enter", __func__);
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	send_buffer = devdata->tx_buf;
+
+	mini_isp_register_read(reg_addr, &reg_value);
+	value = (reg_value & ~mask) | mask_value;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+	memcpy(send_buffer + 5, &value, 4);
+	dev_global_variable->before_booting = 1;
+	devdata->intf_fn->write(devdata, devdata->tx_buf, devdata->rx_buf, 9);
+	dev_global_variable->before_booting = 0;
+}
+
+void mini_isp_e_to_a(void)
+{
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	misp_info("mini_isp_drv_setting(1) mini_isp_e_to_a");
+	mini_isp_register_write(0xffef0240, 0x0);
+	mdelay(100);
+	dev_global_variable->altek_spi_mode = ALTEK_SPI_MODE_A;
+}
+
+
+void mini_isp_a_to_e(void)
+{
+	u8 *send_buffer;
+	u8 ctrlbyte = CTRL_BYTE_A2E;
+	struct misp_data *devdata;
+	//u8 send_buffer_value[64];
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	send_buffer = devdata->tx_buf;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	devdata->intf_fn->write(devdata, devdata->tx_buf, devdata->rx_buf, 1);
+	dev_global_variable->altek_spi_mode = ALTEK_SPI_MODE_E;
+	misp_info("mini_isp_drv_setting(2) mini_isp_a_to_e");
+}
+
+void mini_isp_chip_init(void)
+{
+	misp_info("%s - enter", __func__);
+	mini_isp_register_write(0xffe40050, 0x1);
+	mini_isp_register_write(0xffef00a4, 0xe);
+	udelay(70);
+	mini_isp_register_write(0xffef00a0, 0xe);
+	mini_isp_register_write(0xffe81080, 0x8);
+	mini_isp_register_write(0xffef0090, 0x30079241);
+	mini_isp_register_write(0xffe800c4, 0x0);
+	udelay(100);
+	misp_info("%s - leave", __func__);
+}
+
+void mini_isp_cp_mode_suspend_flow(void)
+{
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	misp_info("%s - enter", __func__);
+
+	/*# AP disable OCRAM0*/
+	mini_isp_register_write_one_bit(0xffe609f4, 0, 1);/* # ocr0_disable*/
+
+	/*# 2.AP reset ARC5*/
+	mini_isp_register_write_one_bit(0xffe800c4, 1, 1);/* # base_ck_in*/
+
+	/*# 3.AP reset modules(including arbiter bus)*/
+	mini_isp_register_write_one_bit(0xffe801a4, 1, 1);/* # standby_top*/
+	mini_isp_register_write_one_bit(0xffe80104, 1, 1);/* # arb_bus_stdby_0*/
+
+	/*# 4.AP stop clock of modules(including arbiter bus, OCRAM0) and ARC5*/
+	mini_isp_register_write_one_bit(0xffe800c4, 0, 1);/* # base_ck_in*/
+	mini_isp_register_write_one_bit(0xffe801a4, 0, 1);/* # standby_top*/
+	mini_isp_register_write_one_bit(0xffe80104, 0, 1);/* # arb_bus_stdby_0*/
+	mini_isp_register_write_one_bit(0xffe80104, 2, 1);/* # ocram_0*/
+
+	/*# 5.AP isolate standby power domain*/
+	mini_isp_register_write_one_bit(0xffef00a0, 0, 1);/* # iso_pd_standby*/
+
+	/*# 6.AP power down standby power domain*/
+	mini_isp_register_write_one_bit(0xffef00a4, 0, 1);/* # psw_pd_standby*/
+
+	/*# AP issue global reset of standby power domain*/
+	/* # pd_rstn_standby_top*/
+	mini_isp_register_write_one_bit(0xffe81080, 3, 0);
+	/*# 7.AP keep PLL factor then disable PLLs (Keep PLL_fix)
+	 *# ClkGen have kept PLL factor so don't keep here
+	 *#pll_var_ext_dat = []
+	 *# address of PLL factor
+	 *#pll_var_ext_addr = [0xffe81120, 0xffe81124, 0xffe81128,
+	 *#                    0xffe8112c, 0xffe81130, 0xffe81134,
+	 *#                    0xffe81140, 0xffe81144, 0xffe81148,
+	 *#                    0xffe8114c, 0xffe81150, 0xffe81154 ]
+	 *#for addr in pll_var_ext_addr:
+	 *#    (retsts, retdat) = altek_get_register(interface,
+	 *#                        handle, I2C_SLAVE_ID, addr)
+	 *#    pll_var_ext_dat.append(retdat)
+	 *# bit 11: reset_pll_ext,
+	 *# bit 10: reset_pll_var,
+	 *# bit 3: disable_pll_ext,
+	 *# bit 2: disable_pll_var
+	 */
+	/*# 7.AP keep PLL factor then disable PLLs
+	 *(disable PLL_fix, PLL_ext and PLL_var)
+	 */
+	mini_isp_register_write_bit_field(0xffe81004, 0x0e0e, 0x0e0e);
+	/*# AP do something*/
+	mdelay(10);
+	misp_info("%s - leave", __func__);
+}
+
+void mini_isp_cp_mode_resume_flow(void)
+{
+	u32 magic_number;
+	struct misp_global_variable *dev_global_variable;
+	errcode status = ERR_SUCCESS;
+
+	misp_info("%s - enter", __func__);
+	dev_global_variable = get_mini_isp_global_variable();
+	/*# 1.AP check magic number*/
+	mini_isp_register_read(0xffef0008, &magic_number);/* # magic_number*/
+
+	/*
+	 *# 2.AP check if magic number is equal to RESUME (0x19961224)
+	 *then jump to step 4
+	 */
+	if (magic_number != 0x19961224) {
+		/*
+		 *# 3.Else exit resume flow
+		 *(Note: AP can decide what to do.
+		 *Ex: Toggle system reset of SK1 to reboot SK1)
+		 */
+		misp_err("%s - resume fail!, magic number not equal!", __func__);
+		return;
+	}
+
+	/*# 4.AP enable/configure PLLs*/
+	/*
+	 *# bit 11: reset_pll_ext,
+	 *bit 10: reset_pll_var,
+	 *bit 3: disable_pll_ext,
+	 *bit 2: disable_pll_var
+	 */
+	/*# ClkGen have kept PLL factor so don't set here*/
+	/*#for idx, addr in enumerate(pll_var_ext_addr):*/
+	/*
+	 *#altek_set_register(interface, handle,
+	 *I2C_SLAVE_ID, addr, pll_var_ext_dat[idx])
+	 */
+	/* # 5us, TO-DO: depend on IP spec*/
+	/*
+	 *# bit 11: reset_pll_ext,
+	 *bit 10: reset_pll_var,
+	 *bit 3: disable_pll_ext,
+	 *bit 2: disable_pll_var
+	 */
+
+	// Fix CP mode resume bug >>>
+	//mini_isp_register_write_bit_field(0xffe81004, 0x0e0e, 0x0e0c);
+	//udelay(10);/* # 10us, TO-DO: depend on IP spec*/
+	// Fix CP mode resume bug <<
+
+	//mini_isp_register_write_bit_field(0xffe81004, 0x0e0e, 0x0c0c);
+	//udelay(750);/* # 750us, TO-DO: depend on IP spec*/
+
+	/*# 5.AP power up standby power domain*/
+	mini_isp_register_write_one_bit(0xffef00a4, 0, 0);/* # psw_pd_standby*/
+	udelay(70);/* # 70us, TO-DO: depend on backend spec*/
+
+	/*# 6.AP release isolation of standby power domain*/
+	mini_isp_register_write_one_bit(0xffef00a0, 0, 0);/* # iso_pd_standby*/
+
+	/*# AP release global reset of standby power domain*/
+	/*# pd_rstn_standby_top*/
+	mini_isp_register_write_one_bit(0xffe81080, 3, 1);
+
+	/*# AP power up SRAM of ARC5*/
+	mini_isp_register_write_one_bit(0xffef0090, 22, 0);/*# srampd_base_arc*/
+
+	/*
+	 *# 7.AP enable clock of modules(including arbiter bus, OCRAM0)
+	 *and ARC5
+	 */
+	mini_isp_register_write_one_bit(0xffe800c4, 0, 0);/* # base_ck_in*/
+	mini_isp_register_write_one_bit(0xffe801a4, 0, 0);/* # standby_top*/
+	mini_isp_register_write_one_bit(0xffe80104, 0, 0);/* # arb_bus_stdby_0*/
+	mini_isp_register_write_one_bit(0xffe80104, 2, 0);/* # ocram_0*/
+
+	/*# 8.AP release reset of modules(including arbiter bus)*/
+	mini_isp_register_write_one_bit(0xffe801a4, 1, 0);/* # standby_top*/
+	mini_isp_register_write_one_bit(0xffe80104, 1, 0);/* # arb_bus_stdby_0*/
+
+	/*# AP restore OCRAM0 setting*/
+	mini_isp_register_write(0xffe609f8, 0xdbfc0);
+	mini_isp_register_write(0xffe609f4, 0);
+	mini_isp_register_write(0xffe60800, 0);
+	mini_isp_register_write(0xffe60900, 0);
+
+	/*# 9. AP release reset of ARC5*/
+	mini_isp_register_write_one_bit(0xffe800c4, 1, 0);/* # base_ck_in*/
+
+	/*# 10. AP wait interrupt then clean interrupt status*/
+	status = mini_isp_wait_for_event(MINI_ISP_RCV_CPCHANGE);
+	misp_info("%s - leave", __func__);
+}
+
+void mini_isp_check_and_leave_bypass_mode(void)
+{
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	if (dev_global_variable->be_set_to_bypass) {
+		misp_info("AL6100 is in bypass mode");
+		/*Add code here*/
+		mini_isp_register_write(0xffe80b04, 0x2a2a);/*mipidphy exc*/
+		mini_isp_register_write(0xffe80944, 0x2);/*mipi tx phy 1*/
+		mini_isp_register_write(0xffe80884, 0x2);/*mipi tx phy 0*/
+		mini_isp_register_write(0xffe804e4, 0x2);/*ppibridge 1 exc*/
+		mini_isp_register_write(0xffe804c4, 0x2);/*ppibridge 1*/
+		mini_isp_register_write(0xffe804a4, 0x2);/*ppibridge 0 exc*/
+		mini_isp_register_write(0xffe80484, 0x2);/*ppibridge 0*/
+		mini_isp_register_write(0xffe80444, 0xa);/*mipi rx phy 1*/
+		mini_isp_register_write(0xffe80404, 0xa);/*mipi rx phy 0*/
+
+		dev_global_variable->be_set_to_bypass = 0;
+	} else {
+		/*do nothing*/
+		misp_info("not running bypass mode yet");
+	}
+}
+
+int mini_isp_pure_bypass(u16 mini_isp_mode)
+{
+	struct misp_global_variable *dev_global_variable;
+	errcode err = ERR_SUCCESS;
+	mm_segment_t oldfs;
+	struct file *file_filp;
+	off_t currpos;
+	loff_t offset;
+	char  *allocated_memmory;
+	u8  *keep_allocated_memmory;
+	char  allocated_memmory_buf[64];
+	u32 reg_addr;
+	u32 reg_new_value;
+	u32 file_total_size;
+	u8 byass_setting_file_location[80];
+	u8 buf[8];
+	int i;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	snprintf(byass_setting_file_location, 64,
+		"%saltek_bypass_setting_%d.log",
+		MINIISP_BYPASS_SETTING_FILE_PATH, mini_isp_mode);
+
+	misp_info("altek bypass mode %d", mini_isp_mode);
+	misp_info("%s setting filepath : %s", __func__,
+		byass_setting_file_location);
+
+	allocated_memmory = allocated_memmory_buf;
+	keep_allocated_memmory = allocated_memmory;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	file_filp = filp_open(byass_setting_file_location,
+		O_RDONLY, 0644);
+
+	if (IS_ERR(file_filp)) {
+		err = PTR_ERR(file_filp);
+		misp_err("%s open file failed. err: %d", __func__, err);
+		set_fs(oldfs);
+		return err;
+	}
+	misp_info("%s open file success!", __func__);
+
+#ifndef AL6100_SPI_NOR
+	mini_isp_chip_init();
+#endif
+	/*get bin filie size*/
+	currpos = vfs_llseek(file_filp, 0L, SEEK_END);
+	file_total_size = currpos;
+	currpos = vfs_llseek(file_filp, 0L, SEEK_SET);
+
+	misp_info("%s  file_total_size = %d", __func__, file_total_size);
+	offset = file_filp->f_pos;
+	while (file_total_size > 0) {
+		//		err = file_filp->f_op->read(file_filp,
+		//			allocated_memmory_buf, 1, &offset);
+
+		err = vfs_read(file_filp, allocated_memmory_buf,
+								1, &offset);
+		if (!err)
+			misp_info("err: Read fail!, %s: %d", __func__, __LINE__);
+
+		file_filp->f_pos = offset;
+		file_total_size--;
+		if (allocated_memmory_buf[0] == '0') {
+			vfs_read(file_filp, (char *)allocated_memmory,
+				1, &offset);
+			file_filp->f_pos = offset;
+			file_total_size--;
+			if (allocated_memmory_buf[0] == 'x') {
+				vfs_read(file_filp, (char *)allocated_memmory,
+					8, &offset);
+				file_filp->f_pos = offset;
+				file_total_size = file_total_size - 8;
+
+				for (i = 0; i < 4; i++)
+					err = hex2bin(buf+3-i,
+						allocated_memmory+2*i, 1);
+
+				while (1) {
+					vfs_read(file_filp,
+						(char *)allocated_memmory,
+						1, &offset);
+					file_filp->f_pos = offset;
+					file_total_size = file_total_size - 1;
+
+					if (allocated_memmory[0] == '0')
+						break;
+				}
+
+				if (file_total_size < 0)
+					break;
+
+				vfs_read(file_filp, (char *)allocated_memmory,
+							1, &offset);
+				file_filp->f_pos = offset;
+				file_total_size = file_total_size - 1;
+				if ((allocated_memmory[0] == 'x')) {
+					vfs_read(file_filp,
+						(char *)allocated_memmory,
+						8, &offset);
+					file_filp->f_pos = offset;
+					file_total_size = file_total_size - 8;
+
+					for (i = 0; i < 4; i++)
+						err = hex2bin(buf+4+3-i,
+							allocated_memmory+2*i,
+							1);
+
+					memcpy(&reg_addr, buf, 4);
+					memcpy(&reg_new_value, buf+4, 4);
+
+					mini_isp_register_write(
+						reg_addr,
+						reg_new_value);
+
+				}
+			}
+		} else if (allocated_memmory_buf[0] == 's') {
+			while (1) {
+				vfs_read(file_filp, (char *)allocated_memmory,
+							1, &offset);
+				file_filp->f_pos = offset;
+				file_total_size = file_total_size - 1;
+
+				if (allocated_memmory[0] == 13) {
+					udelay(350);
+					break;
+				}
+			}
+		}
+	}
+	/*Restore segment descriptor*/
+	misp_info("miniisp bypass setting send finish");
+
+	dev_global_variable->be_set_to_bypass = 1;
+	set_fs(oldfs);
+	filp_close(file_filp, NULL);
+
+	return err;
+}
+
+void mini_isp_pure_bypass_debug(u16 mini_isp_mode)
+{
+	mini_isp_chip_init();
+	misp_info("mini_isp_pure_bypass_debug(%d) set bypass mode",
+		mini_isp_mode);
+	switch (mini_isp_mode) {
+	case 1:
+		mini_isp_register_write(0xffe40000, 0x00000008);
+		mini_isp_register_write(0xffe40004, 0x00006621);
+		mini_isp_register_write(0xffe40008, 0x00006621);
+		mini_isp_register_write(0xffe4000c, 0x00006621);
+		mini_isp_register_write(0xffe40010, 0x00006621);
+		mini_isp_register_write(0xffe40050, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000200);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81100, 0x00000000);
+		mini_isp_register_write(0xffe81104, 0x00000000);
+		mini_isp_register_write(0xffe81108, 0x000000dc);
+		mini_isp_register_write(0xffe8110c, 0x00000000);
+		mini_isp_register_write(0xffe81110, 0x00000001);
+		mini_isp_register_write(0xffe81114, 0x00000000);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe800c0, 0x0000000a);
+		mini_isp_register_write(0xffe800e0, 0x0000000a);
+		mini_isp_register_write(0xffe80100, 0x0000000a);
+		mini_isp_register_write(0xffe80120, 0x0000000a);
+		mini_isp_register_write(0xffe81004, 0x00000800);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81120, 0x00000000);
+		mini_isp_register_write(0xffe81124, 0x00000000);
+		mini_isp_register_write(0xffe81128, 0x0000017a);
+		mini_isp_register_write(0xffe8112c, 0x00000000);
+		mini_isp_register_write(0xffe81130, 0x00000001);
+		mini_isp_register_write(0xffe81134, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe81004, 0x00000400);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81140, 0x00000000);
+		mini_isp_register_write(0xffe81144, 0x00000000);
+		mini_isp_register_write(0xffe81148, 0x0000017a);
+		mini_isp_register_write(0xffe8114c, 0x00000000);
+		mini_isp_register_write(0xffe81150, 0x00000001);
+		mini_isp_register_write(0xffe81154, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe80b00, 0x00000819);
+		mini_isp_register_write(0xffe80880, 0x00000400);
+		mini_isp_register_write(0xffe80380, 0x00000004);
+		mini_isp_register_write(0xffe80400, 0x00000802);
+		mini_isp_register_write(0xffed1008, 0x0000aab0);
+		mini_isp_register_write(0xffed100c, 0x00000306);
+		mini_isp_register_write(0xffed1010, 0x00000147);
+		mini_isp_register_write(0xffed1014, 0x0000aa73);
+		mini_isp_register_write(0xffed1018, 0x00000eaa);
+		mini_isp_register_write(0xffed101c, 0x00008e1a);
+		mini_isp_register_write(0xffed1044, 0x000000b8);
+		mini_isp_register_write(0xffed1044, 0x00000098);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed1044, 0x00000088);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed1030, 0x00080000);
+		mini_isp_register_write(0xffed1034, 0x00080000);
+		mini_isp_register_write(0xffed1038, 0x00080000);
+		mini_isp_register_write(0xffed103c, 0x00080000);
+		mini_isp_register_write(0xffed1040, 0x00080000);
+		udelay(0x00000006);
+		mini_isp_register_write(0xffed1030, 0x00080002);
+		mini_isp_register_write(0xffed1034, 0x00080002);
+		mini_isp_register_write(0xffed1038, 0x00080002);
+		mini_isp_register_write(0xffed103c, 0x00080002);
+		mini_isp_register_write(0xffed1040, 0x00080002);
+		mini_isp_register_write(0xffed1000, 0x00000000);
+		mini_isp_register_write(0xfff97000, 0x00000001);
+		mini_isp_register_write(0xfff97004, 0x00003210);
+		mini_isp_register_write(0xfff97008, 0x00003210);
+		mini_isp_register_write(0xfff9700c, 0x145000b4);
+		mini_isp_register_write(0xfff97010, 0x00000000);
+		mini_isp_register_write(0xfff97014, 0x00000000);
+		mini_isp_register_write(0xfff97018, 0x00000000);
+		mini_isp_register_write(0xfff9701c, 0x00000000);
+		mini_isp_register_write(0xfff97020, 0x00000000);
+		mini_isp_register_write(0xfff97024, 0x00000010);
+		mini_isp_register_write(0xfff97028, 0x0000001e);
+		mini_isp_register_write(0xfff9702c, 0x0000000b);
+		mini_isp_register_write(0xfff97030, 0x0f0f0f0f);
+		mini_isp_register_write(0xfff97000, 0x00000000);
+		mini_isp_register_write(0xfff91000, 0x1000000b);
+		mini_isp_register_write(0xfff91024, 0x0000000f);
+		mini_isp_register_write(0xfff91028, 0x00001010);
+		mini_isp_register_write(0xfff9106c, 0x00000c0c);
+		mini_isp_register_write(0xfff91040, 0x00003c02);
+		udelay(0x00000028);
+		mini_isp_register_write(0xfff91004, 0x00000000);
+		mini_isp_register_write(0xfff91008, 0x00003033);
+		mini_isp_register_write(0xfff91010, 0x00003c02);
+		mini_isp_register_write(0xfff91014, 0x00003c02);
+		mini_isp_register_write(0xfff9103c, 0x00000000);
+		mini_isp_register_write(0xfff91098, 0x00444404);
+		mini_isp_register_write(0xfff9104c, 0x000d0011);
+		mini_isp_register_write(0xfff91000, 0x1000000b);
+		mini_isp_register_write(0xfff91024, 0x0000000f);
+		mini_isp_register_write(0xfff91028, 0x0000013f);
+		mini_isp_register_write(0xfff9106c, 0x00000e0e);
+		mini_isp_register_write(0xfff9104c, 0x000d0011);
+		mini_isp_register_write(0xfff91070, 0x01000005);
+		mini_isp_register_write(0xfff910a8, 0x00000000);
+		mini_isp_register_write(0xfff91094, 0x00001021);
+		mini_isp_register_write(0xfff91000, 0x1000000a);
+		break;
+	case 2:
+		mini_isp_register_write(0xffe40000, 0x00000008);
+		mini_isp_register_write(0xffe40004, 0x00006621);
+		mini_isp_register_write(0xffe40008, 0x00006621);
+		mini_isp_register_write(0xffe4000c, 0x00006621);
+		mini_isp_register_write(0xffe40010, 0x00006621);
+		mini_isp_register_write(0xffe40050, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000200);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81100, 0x00000000);
+		mini_isp_register_write(0xffe81104, 0x00000000);
+		mini_isp_register_write(0xffe81108, 0x000000dc);
+		mini_isp_register_write(0xffe8110c, 0x00000000);
+		mini_isp_register_write(0xffe81110, 0x00000001);
+		mini_isp_register_write(0xffe81114, 0x00000000);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe800c0, 0x0000000a);
+		mini_isp_register_write(0xffe800e0, 0x0000000a);
+		mini_isp_register_write(0xffe80100, 0x0000000a);
+		mini_isp_register_write(0xffe80120, 0x0000000a);
+		mini_isp_register_write(0xffe81004, 0x00000800);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81120, 0x00000000);
+		mini_isp_register_write(0xffe81124, 0x00000000);
+		mini_isp_register_write(0xffe81128, 0x0000017a);
+		mini_isp_register_write(0xffe8112c, 0x00000000);
+		mini_isp_register_write(0xffe81130, 0x00000001);
+		mini_isp_register_write(0xffe81134, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe81004, 0x00000400);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81140, 0x00000000);
+		mini_isp_register_write(0xffe81144, 0x00000000);
+		mini_isp_register_write(0xffe81148, 0x0000017a);
+		mini_isp_register_write(0xffe8114c, 0x00000000);
+		mini_isp_register_write(0xffe81150, 0x00000001);
+		mini_isp_register_write(0xffe81154, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe80b00, 0x00000819);
+		mini_isp_register_write(0xffe80940, 0x00000800);
+		mini_isp_register_write(0xffe80440, 0x00000004);
+		mini_isp_register_write(0xffe80460, 0x00000802);
+		mini_isp_register_write(0xffed6008, 0x0000aab0);
+		mini_isp_register_write(0xffed600c, 0x00000306);
+		mini_isp_register_write(0xffed6010, 0x00000147);
+		mini_isp_register_write(0xffed6014, 0x0000aa73);
+		mini_isp_register_write(0xffed6018, 0x00000eaa);
+		mini_isp_register_write(0xffed601c, 0x00008e1a);
+		mini_isp_register_write(0xffed6044, 0x000000b8);
+		mini_isp_register_write(0xffed6044, 0x00000098);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed6044, 0x00000088);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed6030, 0x00080000);
+		mini_isp_register_write(0xffed6034, 0x00080000);
+		mini_isp_register_write(0xffed6038, 0x00080000);
+		mini_isp_register_write(0xffed603c, 0x00080000);
+		mini_isp_register_write(0xffed6040, 0x00080000);
+		udelay(0x00000006);
+		mini_isp_register_write(0xffed6030, 0x00080002);
+		mini_isp_register_write(0xffed6034, 0x00080002);
+		mini_isp_register_write(0xffed6038, 0x00080002);
+		mini_isp_register_write(0xffed603c, 0x00080002);
+		mini_isp_register_write(0xffed6040, 0x00080002);
+		mini_isp_register_write(0xffed6000, 0x00000000);
+		mini_isp_register_write(0xfff98000, 0x00000001);
+		mini_isp_register_write(0xfff98004, 0x00003210);
+		mini_isp_register_write(0xfff98008, 0x00003210);
+		mini_isp_register_write(0xfff9800c, 0x14500344);
+		mini_isp_register_write(0xfff98010, 0x00000000);
+		mini_isp_register_write(0xfff98014, 0x00000000);
+		mini_isp_register_write(0xfff98018, 0x00000000);
+		mini_isp_register_write(0xfff9801c, 0x00000000);
+		mini_isp_register_write(0xfff98020, 0x00000000);
+		mini_isp_register_write(0xfff98024, 0x000000ec);
+		mini_isp_register_write(0xfff98028, 0x0000001e);
+		mini_isp_register_write(0xfff9802c, 0x000000c3);
+		mini_isp_register_write(0xfff98030, 0x56565656);
+		mini_isp_register_write(0xfff98000, 0x00000000);
+		mini_isp_register_write(0xfff94000, 0x1000000b);
+		mini_isp_register_write(0xfff94024, 0x0000000f);
+		mini_isp_register_write(0xfff94028, 0x00001010);
+		mini_isp_register_write(0xfff9406c, 0x00000c0c);
+		mini_isp_register_write(0xfff94040, 0x00003c02);
+		udelay(0x00000028);
+		mini_isp_register_write(0xfff94004, 0x00000000);
+		mini_isp_register_write(0xfff94008, 0x00003033);
+		mini_isp_register_write(0xfff94010, 0x00003c02);
+		mini_isp_register_write(0xfff94014, 0x00003c02);
+		mini_isp_register_write(0xfff9403c, 0x00000000);
+		mini_isp_register_write(0xfff94098, 0x00444404);
+		mini_isp_register_write(0xfff9404c, 0x000d0011);
+		mini_isp_register_write(0xfff94000, 0x1000000b);
+		mini_isp_register_write(0xfff94024, 0x0000000f);
+		mini_isp_register_write(0xfff94028, 0x00003f01);
+		mini_isp_register_write(0xfff9406c, 0x00000e0e);
+		mini_isp_register_write(0xfff9404c, 0x000d0011);
+		mini_isp_register_write(0xfff94070, 0x01000005);
+		mini_isp_register_write(0xfff940a8, 0x00000000);
+		mini_isp_register_write(0xfff94094, 0x00001021);
+		mini_isp_register_write(0xfff94000, 0x1000000a);
+		break;
+	case 3:
+		mini_isp_register_write(0xffe40000, 0x00000008);
+		mini_isp_register_write(0xffe40004, 0x00006621);
+		mini_isp_register_write(0xffe40008, 0x00006621);
+		mini_isp_register_write(0xffe4000c, 0x00006621);
+		mini_isp_register_write(0xffe40010, 0x00006621);
+		mini_isp_register_write(0xffe40050, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000200);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81100, 0x00000000);
+		mini_isp_register_write(0xffe81104, 0x00000000);
+		mini_isp_register_write(0xffe81108, 0x000000dc);
+		mini_isp_register_write(0xffe8110c, 0x00000000);
+		mini_isp_register_write(0xffe81110, 0x00000001);
+		mini_isp_register_write(0xffe81114, 0x00000000);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe800c0, 0x0000000a);
+		mini_isp_register_write(0xffe800e0, 0x0000000a);
+		mini_isp_register_write(0xffe80100, 0x0000000a);
+		mini_isp_register_write(0xffe80120, 0x0000000a);
+		mini_isp_register_write(0xffe81004, 0x00000800);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81120, 0x00000000);
+		mini_isp_register_write(0xffe81124, 0x00000000);
+		mini_isp_register_write(0xffe81128, 0x0000017a);
+		mini_isp_register_write(0xffe8112c, 0x00000000);
+		mini_isp_register_write(0xffe81130, 0x00000001);
+		mini_isp_register_write(0xffe81134, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe81004, 0x00000400);
+		udelay(0x00000005);
+		mini_isp_register_write(0xffe81140, 0x00000000);
+		mini_isp_register_write(0xffe81144, 0x00000000);
+		mini_isp_register_write(0xffe81148, 0x0000017a);
+		mini_isp_register_write(0xffe8114c, 0x00000000);
+		mini_isp_register_write(0xffe81150, 0x00000001);
+		mini_isp_register_write(0xffe81154, 0x00000001);
+		mini_isp_register_write(0xffe81004, 0x00000000);
+		udelay(0x0000015e);
+		mini_isp_register_write(0xffe80b00, 0x00000819);
+		mini_isp_register_write(0xffe80880, 0x00000400);
+		mini_isp_register_write(0xffe80380, 0x00000004);
+		mini_isp_register_write(0xffe80400, 0x00000802);
+		mini_isp_register_write(0xffe80940, 0x00000800);
+		mini_isp_register_write(0xffe80440, 0x00000004);
+		mini_isp_register_write(0xffe80460, 0x00000802);
+		mini_isp_register_write(0xffed1008, 0x0000aab0);
+		mini_isp_register_write(0xffed100c, 0x00000306);
+		mini_isp_register_write(0xffed1010, 0x00000147);
+		mini_isp_register_write(0xffed1014, 0x0000aa73);
+		mini_isp_register_write(0xffed1018, 0x00000eaa);
+		mini_isp_register_write(0xffed101c, 0x00008e1a);
+		mini_isp_register_write(0xffed1044, 0x000000b8);
+		mini_isp_register_write(0xffed1044, 0x00000098);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed1044, 0x00000088);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed1030, 0x00080000);
+		mini_isp_register_write(0xffed1034, 0x00080000);
+		mini_isp_register_write(0xffed1038, 0x00080000);
+		mini_isp_register_write(0xffed103c, 0x00080000);
+		mini_isp_register_write(0xffed1040, 0x00080000);
+		udelay(0x00000006);
+		mini_isp_register_write(0xffed1030, 0x00080002);
+		mini_isp_register_write(0xffed1034, 0x00080002);
+		mini_isp_register_write(0xffed1038, 0x00080002);
+		mini_isp_register_write(0xffed103c, 0x00080002);
+		mini_isp_register_write(0xffed1040, 0x00080002);
+		mini_isp_register_write(0xffed1000, 0x00000000);
+		mini_isp_register_write(0xfff97000, 0x00000001);
+		mini_isp_register_write(0xfff97004, 0x00003210);
+		mini_isp_register_write(0xfff97008, 0x00003210);
+		mini_isp_register_write(0xfff9700c, 0x145000b4);
+		mini_isp_register_write(0xfff97010, 0x00000000);
+		mini_isp_register_write(0xfff97014, 0x00000000);
+		mini_isp_register_write(0xfff97018, 0x00000000);
+		mini_isp_register_write(0xfff9701c, 0x00000000);
+		mini_isp_register_write(0xfff97020, 0x00000000);
+		mini_isp_register_write(0xfff97024, 0x00000010);
+		mini_isp_register_write(0xfff97028, 0x0000001e);
+		mini_isp_register_write(0xfff9702c, 0x0000000b);
+		mini_isp_register_write(0xfff97030, 0x0f0f0f0f);
+		mini_isp_register_write(0xfff97000, 0x00000000);
+		mini_isp_register_write(0xfff91000, 0x1000000b);
+		mini_isp_register_write(0xfff91024, 0x0000000f);
+		mini_isp_register_write(0xfff91028, 0x00001010);
+		mini_isp_register_write(0xfff9106c, 0x00000c0c);
+		mini_isp_register_write(0xfff91040, 0x00003c02);
+		udelay(0x00000028);
+		mini_isp_register_write(0xfff91004, 0x00000000);
+		mini_isp_register_write(0xfff91008, 0x00003033);
+		mini_isp_register_write(0xfff91010, 0x00003c02);
+		mini_isp_register_write(0xfff91014, 0x00003c02);
+		mini_isp_register_write(0xfff9103c, 0x00000000);
+		mini_isp_register_write(0xfff91098, 0x00444404);
+		mini_isp_register_write(0xfff9104c, 0x000d0011);
+		mini_isp_register_write(0xfff91000, 0x1000000b);
+		mini_isp_register_write(0xfff91024, 0x0000000f);
+		mini_isp_register_write(0xfff91028, 0x0000013f);
+		mini_isp_register_write(0xfff9106c, 0x00000e0e);
+		mini_isp_register_write(0xfff9104c, 0x000d0011);
+		mini_isp_register_write(0xfff91070, 0x01000005);
+		mini_isp_register_write(0xfff910a8, 0x00000000);
+		mini_isp_register_write(0xfff91094, 0x00001021);
+		mini_isp_register_write(0xfff91000, 0x1000000a);
+		mini_isp_register_write(0xffed6008, 0x0000aab0);
+		mini_isp_register_write(0xffed600c, 0x00000306);
+		mini_isp_register_write(0xffed6010, 0x00000147);
+		mini_isp_register_write(0xffed6014, 0x0000aa73);
+		mini_isp_register_write(0xffed6018, 0x00000eaa);
+		mini_isp_register_write(0xffed601c, 0x00008e1a);
+		mini_isp_register_write(0xffed6044, 0x000000b8);
+		mini_isp_register_write(0xffed6044, 0x00000098);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed6044, 0x00000088);
+		udelay(0x00000028);
+		mini_isp_register_write(0xffed6030, 0x00080000);
+		mini_isp_register_write(0xffed6034, 0x00080000);
+		mini_isp_register_write(0xffed6038, 0x00080000);
+		mini_isp_register_write(0xffed603c, 0x00080000);
+		mini_isp_register_write(0xffed6040, 0x00080000);
+		udelay(0x00000006);
+		mini_isp_register_write(0xffed6030, 0x00080002);
+		mini_isp_register_write(0xffed6034, 0x00080002);
+		mini_isp_register_write(0xffed6038, 0x00080002);
+		mini_isp_register_write(0xffed603c, 0x00080002);
+		mini_isp_register_write(0xffed6040, 0x00080002);
+		mini_isp_register_write(0xffed6000, 0x00000000);
+		mini_isp_register_write(0xfff98000, 0x00000001);
+		mini_isp_register_write(0xfff98004, 0x00003210);
+		mini_isp_register_write(0xfff98008, 0x00003210);
+		mini_isp_register_write(0xfff9800c, 0x14500344);
+		mini_isp_register_write(0xfff98010, 0x00000000);
+		mini_isp_register_write(0xfff98014, 0x00000000);
+		mini_isp_register_write(0xfff98018, 0x00000000);
+		mini_isp_register_write(0xfff9801c, 0x00000000);
+		mini_isp_register_write(0xfff98020, 0x00000000);
+		mini_isp_register_write(0xfff98024, 0x000000ec);
+		mini_isp_register_write(0xfff98028, 0x0000001e);
+		mini_isp_register_write(0xfff9802c, 0x000000c3);
+		mini_isp_register_write(0xfff98030, 0x56565656);
+		mini_isp_register_write(0xfff98000, 0x00000000);
+		mini_isp_register_write(0xfff94000, 0x1000000b);
+		mini_isp_register_write(0xfff94024, 0x0000000f);
+		mini_isp_register_write(0xfff94028, 0x00001010);
+		mini_isp_register_write(0xfff9406c, 0x00000c0c);
+		mini_isp_register_write(0xfff94040, 0x00003c02);
+		udelay(0x00000028);
+		mini_isp_register_write(0xfff94004, 0x00000000);
+		mini_isp_register_write(0xfff94008, 0x00003033);
+		mini_isp_register_write(0xfff94010, 0x00003c02);
+		mini_isp_register_write(0xfff94014, 0x00003c02);
+		mini_isp_register_write(0xfff9403c, 0x00000000);
+		mini_isp_register_write(0xfff94098, 0x00444404);
+		mini_isp_register_write(0xfff9404c, 0x000d0011);
+		mini_isp_register_write(0xfff94000, 0x1000000b);
+		mini_isp_register_write(0xfff94024, 0x0000000f);
+		mini_isp_register_write(0xfff94028, 0x00003f01);
+		mini_isp_register_write(0xfff9406c, 0x00000e0e);
+		mini_isp_register_write(0xfff9404c, 0x000d0011);
+		mini_isp_register_write(0xfff94070, 0x01000005);
+		mini_isp_register_write(0xfff940a8, 0x00000000);
+		mini_isp_register_write(0xfff94094, 0x00001021);
+		mini_isp_register_write(0xfff94000, 0x1000000a);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(mini_isp_pure_bypass_debug);
+
+
+u32 mini_isp_register_read_then_write_file(u32 start_reg_addr, u32 end_reg_addr,
+							char *module_name)
+{
+	struct misp_data *devdata;
+	struct misp_global_variable *dev_global_variable;
+	u32 retval = ERR_SUCCESS;
+	u32 count;
+	u32 rx_dummy_len;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 *io_buffer = NULL;
+	u32 io_size;
+	u8 *dump_memory = NULL;
+	u8 *keep_dump_memory = NULL;
+	u32 ouput_size;
+	u8 ctrlbyte;
+	u8 filename[80];
+	struct file *f;
+	mm_segment_t fs;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	count = ((end_reg_addr - start_reg_addr) / 4) + 1;  //how many registers(4 bytes) do you want to read?
+	ouput_size = (count + 2) * 4; // read 4 bytes register value
+
+	rx_dummy_len = devdata->rx_dummy_len;
+	io_size = EMODE_TXCMD_LEN + rx_dummy_len + 4; // read 4 bytes register value at a time
+
+	io_buffer = kzalloc(io_size, GFP_KERNEL);
+	if (!io_buffer) {
+		misp_err("%s Allocate memory failed.", __func__);
+		retval = -ENOMEM;
+		goto allocate_memory_fail;
+	}
+
+	dump_memory = kzalloc(ouput_size, GFP_KERNEL);
+	if (!dump_memory){
+		misp_err("%s Allocate memory failed.", __func__);
+		retval = -ENOMEM;
+		goto allocate_memory_fail;
+	}
+	keep_dump_memory = dump_memory;
+
+	send_buffer = io_buffer;
+	recv_buffer = io_buffer + EMODE_TXCMD_LEN;
+
+	memcpy(dump_memory, &start_reg_addr, 4);
+	dump_memory = dump_memory + 4;
+	memcpy(dump_memory, &count, 4);
+	dump_memory = dump_memory + 4;
+
+	ctrlbyte = CTRL_BYTE_REGRD;
+	while (start_reg_addr <= end_reg_addr) {
+
+		memset(io_buffer, 0, io_size);
+		memcpy(send_buffer, &ctrlbyte, 1);
+		memcpy(send_buffer + 1, &start_reg_addr, 4);
+
+		retval = devdata->intf_fn->read((void *)devdata,
+					send_buffer, EMODE_TXCMD_LEN,
+					recv_buffer, rx_dummy_len + 4);
+
+		if (retval) {
+			misp_err("%s read failed.", __func__);
+			goto mini_isp_register_read_get_fail;
+		}
+
+		if (rx_dummy_len > 0 &&
+			mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+			misp_err("%s read failed.", __func__);
+			retval = -EIO;
+			goto mini_isp_register_read_get_fail;
+		}
+
+		memcpy(dump_memory, recv_buffer, 4);
+		start_reg_addr = start_reg_addr + 4;
+		dump_memory = dump_memory + 4;
+	}
+
+	snprintf(filename, 64, "%s/%s_%x.regx",
+		MINIISP_INFO_DUMPLOCATION, module_name, start_reg_addr);
+	f = filp_open(filename, O_APPEND | O_CREAT | O_RDWR, 0777);
+	/*Get current segment descriptor*/
+	fs = get_fs();
+	/*Set segment descriptor associated*/
+	set_fs(get_ds());
+	/*write the file*/
+	f->f_op->write(f, (char *)keep_dump_memory, ouput_size, &f->f_pos);
+	/*Restore segment descriptor*/
+	set_fs(fs);
+	filp_close(f, NULL);
+
+mini_isp_register_read_get_fail:
+
+allocate_memory_fail:
+	kfree(io_buffer);
+	kfree(keep_dump_memory);
+
+	return retval;
+}
+
+u32 mini_isp_register_read(u32 reg_addr, u32 *reg_value)
+{
+	int status = ERR_SUCCESS;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 ctrlbyte = CTRL_BYTE_REGRD;
+	u32 address = reg_addr;
+	struct misp_data *devdata;
+	struct misp_global_variable *dev_global_variable;
+
+	u8 send_buffer_value[64] = {0};
+	u8 recv_buffer_value[64] = {0};
+	u32 rx_dummy_len;;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	send_buffer = send_buffer_value;
+	recv_buffer = recv_buffer_value;
+	rx_dummy_len = devdata->rx_dummy_len;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+
+
+	status = devdata->intf_fn->read(devdata,
+						send_buffer_value, EMODE_TXCMD_LEN,
+						recv_buffer_value, rx_dummy_len + 4); //read 4 bytes register value
+
+	if (status) {
+		misp_err("%s - sync error: status = %d", __func__, status);
+		goto mini_isp_register_read_end;
+	}
+
+	if (rx_dummy_len > 0 &&
+		mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+		misp_err("[miniisp]Can't get reg");
+		goto mini_isp_register_read_end;
+	}
+	memcpy(reg_value, recv_buffer, 4);
+
+mini_isp_register_read_end:
+
+	return status;
+}
+
+void mini_isp_memory_write(u32 memory_addr, u8 *write_buffer, u32 write_len)
+{
+	u8 *send_buffer;
+	u8 ctrlbyte = CTRL_BYTE_MEMWR;
+	u32 address = memory_addr;
+	struct misp_data *devdata;
+	u8 send_buffer_value[EMODE_TXCMD_LEN + write_len];
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	send_buffer = send_buffer_value;
+
+	memcpy(send_buffer, &ctrlbyte, 1);
+	memcpy(send_buffer + 1, &address, 4);
+	memcpy(send_buffer + 5, write_buffer, write_len);
+	dev_global_variable->before_booting = 1;
+	devdata->intf_fn->write(devdata, send_buffer, NULL, EMODE_TXCMD_LEN + write_len);
+	dev_global_variable->before_booting = 0;
+}
+
+u32 mini_isp_memory_read_then_write_file(u32 start_addr, u32 len,
+	char *file_name)
+{
+	struct misp_data *devdata;
+	struct misp_global_variable *dev_global_variable;
+	u32 retval = ERR_SUCCESS;
+	u8 *io_buffer = NULL;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 *dump_memory   = NULL;
+	u8 *keep_dump_memory = NULL;
+	u32 dump_addr = start_addr;
+	u32 ouput_size;
+	u32 io_size, remain_size, one_size;
+	u32 rx_dummy_len;
+	u8 ctrlbyte;
+	u8 filename[80];
+	struct file *f;
+	mm_segment_t fs;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	rx_dummy_len = devdata->rx_dummy_len;
+	io_size = EMODE_TXCMD_LEN + rx_dummy_len + 60000; // read 60000 bytes at a time;
+	io_buffer = kzalloc(io_size, GFP_KERNEL);
+	if (!io_buffer) {
+		misp_err("%s Allocate memory failed.", __func__);
+		goto allocate_memory_fail;
+	}
+
+	dump_memory = kzalloc(len, GFP_KERNEL);
+	if (!dump_memory) {
+		misp_err("%s Allocate memory failed.", __func__);
+		goto allocate_memory_fail;
+	}
+	keep_dump_memory = dump_memory;
+	ouput_size = len;
+	ctrlbyte = CTRL_BYTE_MEMRD; //memory read
+
+	for (remain_size = ouput_size; remain_size > 0;
+		remain_size -= one_size) {
+		one_size = (remain_size > 60000) ?
+			60000 : remain_size;
+
+		memset(io_buffer, 0, io_size);
+		send_buffer = io_buffer;
+		recv_buffer = io_buffer + EMODE_TXCMD_LEN;
+
+		memcpy(send_buffer, &ctrlbyte, 1);
+		memcpy(send_buffer + 1, &dump_addr, 4);
+
+		retval = devdata->intf_fn->read((void *)devdata,
+							send_buffer,
+							EMODE_TXCMD_LEN,
+							recv_buffer,
+							one_size + rx_dummy_len);
+		if (retval) {
+			misp_err("%s get failed.", __func__);
+			goto mini_isp_memory_read_get_fail;
+		}
+
+		if (rx_dummy_len > 0 &&
+			mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+			misp_err("%s get failed.", __func__);
+			retval = -EIO;
+			goto mini_isp_memory_read_get_fail;
+		}
+
+		memcpy(dump_memory, recv_buffer, one_size);
+		misp_info("%s dump_addr = 0x%x one_size = %d",
+			__func__, dump_addr, one_size);
+		dump_memory += one_size;
+		dump_addr += one_size;
+	} //for-loop
+
+	misp_info("%s read_finish", __func__);
+
+	snprintf(filename, 128, "%s/%s.raw",
+		MINIISP_INFO_DUMPLOCATION, file_name);
+	f = filp_open(filename, O_APPEND | O_CREAT | O_RDWR, 0777);
+	/*Get current segment descriptor*/
+	fs = get_fs();
+	/*Set segment descriptor associated*/
+	set_fs(get_ds());
+	/*write the file*/
+	f->f_op->write(f, (char *)keep_dump_memory, ouput_size, &f->f_pos);
+	/*Restore segment descriptor*/
+	set_fs(fs);
+	filp_close(f, NULL);
+
+mini_isp_memory_read_get_fail:
+allocate_memory_fail:
+	kfree(keep_dump_memory);
+	kfree(io_buffer);
+
+	return retval;
+}
+EXPORT_SYMBOL(mini_isp_memory_read_then_write_file);
+
+
+u32 mini_isp_memory_read(u32 start_addr, u8 *read_buffer, u32 len)
+{
+	struct misp_data *devdata;
+	struct misp_global_variable *dev_global_variable;
+	u32 retval = ERR_SUCCESS;
+	u8 *io_buffer = NULL;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 *dump_memory   = NULL;
+	u8 *keep_dump_memory = NULL;
+	u32 dump_addr = start_addr;
+	u32 ouput_size;
+	u32 io_size, remain_size, one_size;
+	u32 rx_dummy_len;
+	u8 ctrlbyte;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+
+	rx_dummy_len = devdata->rx_dummy_len;
+	io_size = EMODE_TXCMD_LEN + rx_dummy_len + 60000; // read 60000 bytes at a time;
+	io_buffer = kzalloc(io_size, GFP_KERNEL);
+	if (!io_buffer) {
+		misp_err("%s Allocate memory failed.", __func__);
+		goto allocate_memory_fail;
+	}
+
+	dump_memory = kzalloc(len, GFP_KERNEL);
+	if (!dump_memory) {
+		misp_err("%s Allocate memory failed.", __func__);
+		goto allocate_memory_fail;
+	}
+	keep_dump_memory = dump_memory;
+	ouput_size = len;
+	ctrlbyte = CTRL_BYTE_MEMRD; //memory read
+
+	for (remain_size = ouput_size; remain_size > 0;
+		remain_size -= one_size) {
+		one_size = (remain_size > 60000) ?
+			60000 : remain_size;
+
+		memset(io_buffer, 0, io_size);
+		send_buffer = io_buffer;
+		recv_buffer = io_buffer + EMODE_TXCMD_LEN;
+
+		memcpy(send_buffer, &ctrlbyte, 1);
+		memcpy(send_buffer + 1, &dump_addr, 4);
+
+		retval = devdata->intf_fn->read((void *)devdata,
+							send_buffer,
+							EMODE_TXCMD_LEN,
+							recv_buffer,
+							one_size + rx_dummy_len);
+		if (retval) {
+			misp_err("%s get failed.", __func__);
+			goto mini_isp_memory_read_get_fail;
+		}
+
+		if (rx_dummy_len > 0 &&
+			mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+			misp_err("%s get failed.", __func__);
+			retval = -EIO;
+			goto mini_isp_memory_read_get_fail;
+		 }
+
+		memcpy(dump_memory, recv_buffer, one_size);
+		misp_info("%s dump_addr = 0x%x one_size = %d",
+			__func__, dump_addr, one_size);
+		dump_memory += one_size;
+		dump_addr += one_size;
+	} //for-loop
+
+	misp_info("%s read_finish", __func__);
+
+	memcpy(read_buffer, keep_dump_memory, ouput_size);
+
+mini_isp_memory_read_get_fail:
+allocate_memory_fail:
+	kfree(keep_dump_memory);
+	kfree(io_buffer);
+
+	return retval;
+}
+EXPORT_SYMBOL(mini_isp_memory_read);
+
+
+int mini_isp_get_bulk(struct misp_data *devdata, u8 *response_buf,
+		u32 total_size, u32 block_size)
+{
+	int status = ERR_SUCCESS, count = 0;
+	int remain_size, one_size;
+	u8 io_buffer[3] = {0}; // 1byte ctrlbyte, 2bytes recv
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 ctrlbyte = USPICTRL_MS_CB_DIS;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	send_buffer = io_buffer;
+	send_buffer[0] = ctrlbyte;
+	recv_buffer = io_buffer + 1;
+
+	misp_info("%s started.", __func__);
+
+	status = devdata->intf_fn->read(devdata, send_buffer, 1, recv_buffer, 2);
+	if (status) {
+		misp_err("mini_isp_send_bulk send ctrl byte failed. status:%d", status);
+		status = -EINVAL;
+		goto G_EXIT;
+	}
+
+	for (remain_size = total_size; remain_size > 0; remain_size -= one_size) {
+		one_size = (remain_size > block_size) ? block_size : remain_size;
+		/*get the data*/
+		misp_info("%s dump start", __func__);
+		status = devdata->intf_fn->read((void *)devdata, response_buf, 0, response_buf, one_size);
+		if (status != 0) {
+			misp_err("%s failed!! block:%d status: %d", __func__, count, status);
+			break;
+		}
+
+		response_buf += one_size;
+		count++;
+	}
+
+G_EXIT:
+
+	if (status != ERR_SUCCESS)
+		misp_info("%s - error: %d", __func__, status);
+	else
+		misp_info("%s - success.", __func__);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(mini_isp_get_bulk);
+
+
+int mini_isp_debug_dump_img(void)
+{
+	int errcode = ERR_SUCCESS;
+	u8 write_buffer[4];
+	u32 rg_img_in_size;
+	u32 crop_src;
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	/*
+	if (dev_global_variable->now_state != 4) {
+		misp_err("%s Error dump state, no dump", __func__);
+		return ~0;
+	}
+	*/
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_A)) {
+		misp_info("%s a_to_e", __func__);
+		mini_isp_a_to_e();
+	}
+	mini_isp_register_read(0xfff8401c, &rg_img_in_size);
+	mini_isp_register_read(0xfffa7020, &crop_src);
+	write_buffer[0] = 1;
+	mini_isp_memory_write(0x10, write_buffer, 1);
+
+	errcode = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	if (errcode) {
+		misp_info("%s wait first interrupt fail", __func__);
+		return errcode;
+	}
+	misp_info("%s - crop_src %x, width = %d, height = %d",
+			__func__, crop_src, ((rg_img_in_size & 0x00001fff)+1),
+			(((rg_img_in_size & 0x1fff0000)>>16)+1));
+	if (crop_src)
+		mini_isp_memory_read_then_write_file(0x20500000,
+			((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1)*10/8,
+			"irp");
+	else
+		mini_isp_memory_read_then_write_file(0x20500000,
+			((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1),
+			"irp");
+	mini_isp_register_read(0xfff5601c, &rg_img_in_size);
+	write_buffer[0] = 2;
+	mini_isp_memory_write(0x10, write_buffer, 1);
+	errcode = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	if (errcode) {
+		misp_info("%s wait second interrupt fail", __func__);
+		return errcode;
+	}
+	mini_isp_memory_read_then_write_file(0x20715400,
+		((rg_img_in_size & 0x00001fff)+1)*
+		(((rg_img_in_size & 0x1fff0000)>>16)+1)*10/8,
+		"depth");
+	if (dev_global_variable->intf_status & INTF_SPI_READY) {
+		misp_info("%s e_to_a", __func__);
+		mini_isp_e_to_a();
+	}
+	return errcode;
+}
+EXPORT_SYMBOL(mini_isp_debug_dump_img);
+
+/*
+ *param dump_item[In],8 bit value
+ *bit 0 stand for dump detail mode
+ *bit 1 stand for dump Main_RectReg
+ *bit 2 stand for dump Sub RectReg, DGCa/ DGMcc Reg, DG output image
+ *bit 3 stand for dump DP Reg, DP output image
+ *bit 4 stand for dump InvRect Reg, InvRect output image
+ *bit 5 stand for dump detail mode
+*/
+int mini_isp_debug_depth_dump(u8 dump_item)
+{
+	int errcode = ERR_SUCCESS;
+	u8 write_buffer[4];
+	u32 rg_img_in_size;
+	u32 crop_src;
+	u8 fov_mode;
+	u8 dump_step;
+	u8 count = 0;
+	u8 filename[80];
+	struct misp_global_variable *dev_global_variable;
+
+	dev_global_variable = get_mini_isp_global_variable();
+
+	if (dev_global_variable->now_state != 4) {
+		misp_err("%s Error dump state, no dump", __func__);
+		return ~0;
+	}
+
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+		(dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_A)) {
+		misp_info("%s a_to_e", __func__);
+		mini_isp_a_to_e();
+	}
+
+	write_buffer[0] = 1;
+	mini_isp_memory_write(0x10, write_buffer, 1);
+
+	errcode = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	if (errcode) {
+		misp_info("%s wait first interrupt fail", __func__);
+		return errcode;
+	}
+
+	mini_isp_memory_read(0x24, &fov_mode, 1);
+
+	mini_isp_register_read(0xfff8401c, &rg_img_in_size);
+	mini_isp_register_read(0xfffa7020, &crop_src);
+	misp_info("%s - crop_src %x, width = %d, height = %d",
+		__func__, crop_src, ((rg_img_in_size & 0x00001fff)+1),
+		(((rg_img_in_size & 0x1fff0000)>>16)+1));
+
+	if (fov_mode) {
+		/*sub image*/
+		mini_isp_memory_read_then_write_file(
+			0x20500000+288000-((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1)/2,
+			((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1)/2, "sub_y");
+		/*main image*/
+		mini_isp_memory_read_then_write_file(
+			0x20500000+288000-((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1),
+			((rg_img_in_size & 0x00001fff)+1)*
+			(((rg_img_in_size & 0x1fff0000)>>16)+1)/2, "main_y");
+	} else {
+		if (crop_src)
+			mini_isp_memory_read_then_write_file(0x20500000,
+				((rg_img_in_size & 0x00001fff)+1)*
+				(((rg_img_in_size & 0x1fff0000)>>16)+1)*10/8,
+				"irp");
+		else
+			mini_isp_memory_read_then_write_file(0x20500000,
+				((rg_img_in_size & 0x00001fff)+1)*
+				(((rg_img_in_size & 0x1fff0000)>>16)+1), "irp");
+	}
+
+	if (dump_item&0x1) {
+		dump_step = dump_item >> 1;
+		while (!(dump_step & 0x1) && (count < 6)) {
+			dump_step = dump_step >> 1;
+			count++;
+			}
+		write_buffer[0] = count;
+		mini_isp_memory_write(0x20, write_buffer, 1);
+		dump_step = dump_step >> 1;
+		count++;
+	}
+
+	mini_isp_register_read(0xfff5601c, &rg_img_in_size);
+	write_buffer[0] = 2;
+	mini_isp_memory_write(0x10, write_buffer, 1);
+	errcode = mini_isp_wait_for_event(MINI_ISP_RCV_CMD_READY);
+	if (errcode) {
+		misp_info("%s wait second interrupt fail", __func__);
+		return errcode;
+	}
+
+	if ((dump_item & 0x1) && (count < 6)) {
+		snprintf(filename, 128, "%d.dump", count);
+		mini_isp_memory_read_then_write_file(0x20715400,
+		((rg_img_in_size & 0x00001fff)+1)*
+		(((rg_img_in_size & 0x1fff0000)>>16)+1)*10/8, filename);
+		while (count < 6) {
+			dump_step = dump_step >> 1;
+			count++;
+			if (dump_step & 0x1)
+				count++;
+			else
+				break;
+		}
+
+	}
+
+	mini_isp_memory_read_then_write_file(0x20715400,
+		((rg_img_in_size & 0x00001fff)+1)*
+		(((rg_img_in_size & 0x1fff0000)>>16)+1)*10/8, "depth");
+	if (dev_global_variable->intf_status & INTF_SPI_READY) {
+		misp_info("%s e_to_a", __func__);
+		mini_isp_e_to_a();
+	}
+	return errcode;
+}
+EXPORT_SYMBOL(mini_isp_debug_depth_dump);
+
+
+int mini_isp_get_altek_status(void *devdata, u32 *altek_status)
+{
+	int status = ERR_SUCCESS;
+	u8 *send_buffer;
+	u8 *recv_buffer;
+	u8 send_buffer_value[64] = {0};
+	u8 recv_buffer_value[64] = {0};
+	u32 write_register_addr = INTERRUPT_STATUS_REGISTER_ADDR;
+	u32 rx_dummy_len = ((struct misp_data *)devdata)->rx_dummy_len;
+
+	struct misp_global_variable *dev_global_variable;
+	dev_global_variable = get_mini_isp_global_variable();
+
+	misp_info("%s - entering", __func__);
+
+	recv_buffer = recv_buffer_value;
+	send_buffer = send_buffer_value;
+
+	send_buffer_value[0] = CTRL_BYTE_REGRD;
+	memcpy(send_buffer + 1, &write_register_addr, 4);
+
+	/*get altek status*/
+	status = ((struct misp_data *)devdata)->intf_fn->read(
+					devdata, send_buffer, EMODE_TXCMD_LEN,
+					recv_buffer, rx_dummy_len + 4);
+
+	if (status) {
+		misp_err("%s - sync error: status = %d", __func__, status);
+		goto mini_isp_get_altek_status;
+	}
+
+	if (rx_dummy_len > 0 &&
+		mini_isp_check_rx_dummy(&recv_buffer, rx_dummy_len)) {
+		misp_err("%s - polling fail", __func__);
+		status = -EAGAIN;
+		goto mini_isp_get_altek_status;
+	}
+
+	memcpy(altek_status, recv_buffer, 4);
+	misp_info("%s - altek_status = %#x", __func__, *altek_status);
+
+mini_isp_get_altek_status:
+	return status;
+}
+
+/*interrupt handler function */
+extern irqreturn_t mini_isp_irq(int irq, void *handle)
+{
+	struct misp_data *devdata = NULL;
+	struct misp_global_variable *dev_global_variable;
+	int errcode = ERR_SUCCESS;
+	int original_altek_spi_mode;
+	u32 altek_event_state = 0;
+
+	misp_info("%s - enter", __func__);
+
+	irqflag = true;
+
+	dev_global_variable = get_mini_isp_global_variable();
+	devdata = get_mini_isp_intf(MINIISP_I2C_SLAVE);
+	if (!devdata || !dev_global_variable)
+		return -IRQ_NONE;
+
+	original_altek_spi_mode = dev_global_variable->altek_spi_mode;
+	if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+	  (dev_global_variable->altek_spi_mode == ALTEK_SPI_MODE_A)) {
+			mini_isp_a_to_e();
+	}
+	errcode = mini_isp_get_altek_status(devdata,
+		&altek_event_state);
+	misp_info("%s - read spi register: %#x",
+			__func__, altek_event_state);
+
+	event = MINI_ISP_RCV_WAITING;
+
+	if (errcode == ERR_SUCCESS) {
+		/*error event*/
+		if (altek_event_state & SYSTEM_ERROR_LEVEL1) {
+			event = event | MINI_ISP_RCV_ERROR;
+			if (dev_global_variable->intf_status & INTF_SPI_READY)
+				mini_isp_e_to_a();
+			//mini_isp_drv_get_err_code_cmd(); // need to port out of this ISR
+			mini_isp_drv_get_err_code_cmd_in_irq();
+			if (dev_global_variable->intf_status & INTF_SPI_READY)
+				mini_isp_a_to_e();
+		}
+		if (altek_event_state & SYSTEM_ERROR_LEVEL2) {
+			event = event | MINI_ISP_RCV_ERROR2;
+			mini_isp_utility_read_reg_e_mode();
+		}
+		/*set sensor mode event*/
+		if (altek_event_state & SET_SENSOR_MODE_READY)
+			event = event | MINI_ISP_RCV_SETSENSORMODE;
+		/*change cp mode event*/
+		if (altek_event_state & CP_STATUS_CHANGE_DONE)
+			event = event | MINI_ISP_RCV_CPCHANGE;
+		/*ready event*/
+		/*CMD*/
+		if (altek_event_state & COMMAND_COMPLETE)
+			event = event | MINI_ISP_RCV_CMD_READY;
+		/*Bulk Data*/
+		if (altek_event_state & BULK_DATA_COMPLETE)
+			event = event | MINI_ISP_RCV_BULKDATA;
+		/* streamoff event*/
+		if (altek_event_state & STRMOFF_READY)
+			event = event | MINI_ISP_RCV_STRMOFF;
+
+		mini_isp_register_write(
+				INTERRUPT_STATUS_REGISTER_ADDR,
+				altek_event_state);
+		} else {
+			misp_err("%s - err: %d", __func__, errcode);
+		}
+
+		if ((dev_global_variable->intf_status & INTF_SPI_READY) &&
+			original_altek_spi_mode !=
+			dev_global_variable->altek_spi_mode)
+			mini_isp_e_to_a();
+
+	wake_up_interruptible(&WAITQ);
+
+	return IRQ_HANDLED;
+}
+
+int mini_isp_wait_for_event(u32 e)
+{
+	int state  = 0;
+
+	misp_info("%s - entering. event: %#x", __func__, e);
+
+	state = wait_event_interruptible(WAITQ, event & e);
+
+	current_event = event;
+
+	event = (~e) & event;/*MINI_ISP_RCV_WAITING;*/
+
+	if (state)
+		misp_err("%s - irq error. err: %d", __func__, state);
+
+	misp_info("%s - leaving. event: %#x", __func__, e);
+
+	return state;
+}
+
+u32 mini_isp_get_currentevent(void)
+{
+	return current_event;
+}
+
+u32 mini_isp_check_rx_dummy(u8 **recv_buffer, u32 rx_dummy_len)
+{
+	u32 ret = 0;
+	u32 get_count = 0;
+	while (**recv_buffer == 0x00 && get_count < rx_dummy_len) {
+		(*recv_buffer)++;
+		get_count++;
+	}
+	if (**recv_buffer == 0xa5) {
+		(*recv_buffer)++;
+	} else {
+		ret = -EIO;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/platform/msm/camera/al6100/miniisp_utility.c b/drivers/media/platform/msm/camera/al6100/miniisp_utility.c
new file mode 100644
index 0000000..0666ad0
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/miniisp_utility.c
@@ -0,0 +1,95 @@
+/*
+ * File: miniisp_utility.c
+ * Description: Mini ISP Utility sample codes
+ *
+ * (C)Copyright altek Corporation 2017
+ *
+ *  2017/03/29; Louis Wang; Initial version
+ */
+ /******Include File******/
+#include "linux/init.h"
+#include "linux/module.h"
+
+#include "include/miniisp.h"
+#include "include/error.h"
+#include "include/miniisp_chip_base_define.h"
+
+
+ #define MINI_ISP_LOG_TAG	"[miniisp_utility]"
+
+ /******Private Global Variable******/
+
+
+ /******Public Function******/
+/**
+ *\brief Read memory in E mode for bypass mode
+ *\return Error code
+*/
+errcode mini_isp_utility_read_reg_e_mode_for_bypass_use(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	err = mini_isp_chip_base_dump_bypass_mode_register();
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_utility_read_reg_e_mode_for_bypass_use);
+
+
+/**
+ *\brief Read memory in E mode
+ *\return Error code
+*/
+errcode mini_isp_utility_read_reg_e_mode(void)
+{
+	errcode err = ERR_SUCCESS;
+
+	err = mini_isp_chip_base_dump_normal_mode_register();
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_utility_read_reg_e_mode);
+
+/**
+ *\brief Read irp and depth image based information
+ *\return Error code
+*/
+errcode mini_isp_utility_get_irp_and_depth_information(
+	struct irp_and_depth_information *info)
+{
+	errcode err = ERR_SUCCESS;
+	u32 rg_img_in_size;
+	u32 rg_depth_in_size;
+	u32 crop_src;
+	u8 fov_mode;
+
+	mini_isp_register_read(0xfff8401c, &rg_img_in_size);
+	info->irp_width = ((rg_img_in_size & 0x00001fff)+1);
+	info->irp_height = (((rg_img_in_size & 0x1fff0000)>>16)+1);
+
+	mini_isp_register_read(0xfffa7020, &crop_src);
+
+	if (crop_src)
+		info->irp_format = 1;
+	else
+		info->irp_format = 0;
+
+	mini_isp_register_read(0xfff5601c, &rg_depth_in_size);
+	info->depth_width = ((rg_depth_in_size & 0x00001fff)+1);
+	info->depth_height = (((rg_depth_in_size & 0x1fff0000)>>16)+1);
+
+	info->depth_image_address = 0x20715400;
+
+	mini_isp_memory_read(0x24, &fov_mode, 1);
+
+	info->fov_mode = fov_mode;
+	if (fov_mode == 1)
+		info->irp_image_address = 0x20500000 + 288000 -
+			((rg_img_in_size & 0x00001fff) + 1) *
+			(((rg_img_in_size & 0x1fff0000)>>16) + 1);
+	else
+		info->irp_image_address = 0x20500000;
+	misp_info("%s:depth_image_address:%u, depth_width:%u, depth_height:%u, irp_format:%u, irp_image_address:%u, irp_width:%u, irp_height:%u, fov_mode:%u\n", __func__,
+		info->depth_image_address, info->depth_width, info->depth_height,
+		info->irp_format, info->irp_image_address, info->irp_width, info->irp_height, info->fov_mode);
+	return err;
+}
+EXPORT_SYMBOL(mini_isp_utility_get_irp_and_depth_information);
diff --git a/drivers/media/platform/msm/camera/al6100/operation_cmd.c b/drivers/media/platform/msm/camera/al6100/operation_cmd.c
new file mode 100644
index 0000000..b06a5ac
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/operation_cmd.c
@@ -0,0 +1,195 @@
+/*
+ * File: operation_cmd.c
+ * Description: operation command
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ *  2013/12/05; Bruce Chung; 2nd version
+ */
+
+/******Include File******/
+
+
+#include <linux/string.h>
+
+#include "include/error.h"
+#include "include/mtype.h"
+#include "include/error.h"
+#include "include/isp_camera_cmd.h"
+#include "include/miniisp.h"
+#include "include/ispctrl_if_master.h"
+
+
+/******Private Constant Definition******/
+
+
+#define MINI_ISP_LOG_TAG "[operation_cmd]"
+
+/******Public Function******/
+
+/**
+ *\brief Mini ISP open
+ *\param devdata [In], CMD param
+ *\param opcode [In], CMD param
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_operation_cmd_miniisp_open(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u64 *boot_pointer,
+		*basic_pointer,
+		*advanced_pointer,
+		*scenario_pointer,
+		*hdr_pointer,
+		*irp0_pointer,
+		*irp1_pointer,
+		*ppmap_pointer;
+
+	char *bootpath,  /*boot code*/
+		 *basicpath,  /*basic code*/
+		 *advancedpath, /*advanced code*/
+		 *scenariopath,  /*scenario data*/
+		 *hdrpath,  /*hdr qmerge data*/
+		 *irp0path, /*irp0 qmerge data*/
+		 *irp1path, /*irp1 qmerge data*/
+		 *ppmappath; /*pp map*/;
+
+	boot_pointer	= (u64 *)&param[0];
+	basic_pointer = (u64 *)&param[8];
+	advanced_pointer	= (u64 *)&param[16];
+	scenario_pointer	= (u64 *)&param[24];
+	hdr_pointer = (u64 *)&param[32];
+	irp0_pointer	= (u64 *)&param[40];
+	irp1_pointer	= (u64 *)&param[48];
+	ppmap_pointer	= (u64 *)&param[56];
+
+	bootpath	 = (char *)*boot_pointer;
+	basicpath	 = (char *)*basic_pointer;
+	advancedpath = (char *)*advanced_pointer;
+	scenariopath	 = (char *)*scenario_pointer;
+	hdrpath	 = (char *)*hdr_pointer;
+	irp0path = (char *)*irp0_pointer;
+	irp1path	 = (char *)*irp1_pointer;
+	ppmappath	 = (char *)*ppmap_pointer;
+
+
+	misp_info("%s - start", __func__);
+
+	/*open boot code*/
+	if (bootpath) {
+		/*
+		 *misp_info("%s - boot code, path: %s",
+		 *		__func__, bootpath);
+		 */
+		err = ispctrl_if_mast_request_firmware(bootpath,
+						BOOT_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open boot code failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+	/*open basic code*/
+	if (basicpath) {
+		/*
+		 *misp_info("%s - basic code, path: %s",
+		 *		__func__, basicpath);
+		 */
+		err = ispctrl_if_mast_request_firmware(basicpath,
+						BASIC_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open basic code failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+	/*open advanced code*/
+	if (advancedpath) {
+		/*
+		 *misp_info("%s - advanced code, path: %s",
+		 *		__func__, advancedpath);
+		 */
+		err = ispctrl_if_mast_request_firmware(advancedpath,
+						ADVANCED_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open advanced code failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+
+	/*open scenario data*/
+	if (scenariopath) {
+		/*
+		 *misp_info("%s - scenario data, path: %s",
+		 *		__func__, scenariopath);
+		 */
+		err = ispctrl_if_mast_request_firmware(scenariopath,
+						SCENARIO_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open scenario data failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+	/*open hdr qmerge data*/
+	if (hdrpath) {
+
+		err = ispctrl_if_mast_request_firmware(hdrpath,
+						HDR_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open hdr qmerge data failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+	/*open irp0 qmerge data*/
+	if (irp0path) {
+
+		err = ispctrl_if_mast_request_firmware(irp0path,
+						IRP0_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open irp0 qmerge data failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+	/*open irp1 qmerge data*/
+	if (irp1path) {
+
+		err = ispctrl_if_mast_request_firmware(irp1path,
+						IRP1_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open irp1 qmerge data failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+	/*open pp map*/
+	if (ppmappath) {
+
+		err = ispctrl_if_mast_request_firmware(ppmappath,
+						PPMAP_CODE);
+		if (err != ERR_SUCCESS) {
+			misp_err("%s - open PP map failed", __func__);
+			goto mast_operation_cmd_miniisp_open_end;
+		}
+	}
+
+
+	misp_info("%s end", __func__);
+
+mast_operation_cmd_miniisp_open_end:
+
+	return err;
+}
+
+/******Private Function******/
+
+
+
+
+
+/****** End Of File******/
diff --git a/drivers/media/platform/msm/camera/al6100/sys_manage_cmd.c b/drivers/media/platform/msm/camera/al6100/sys_manage_cmd.c
new file mode 100644
index 0000000..7c116cd
--- /dev/null
+++ b/drivers/media/platform/msm/camera/al6100/sys_manage_cmd.c
@@ -0,0 +1,226 @@
+/*
+ * File:  sys_managec_md.c
+ * Description: System manage command
+ *
+ * (C)Copyright altek Corporation 2013
+ *
+ *  2013/10/14; Aaron Chuang; Initial version
+ */
+/* Standard C*/
+
+/* Global Header Files*/
+/*#include <osshell.h>*/
+
+#include "include/isp_camera_cmd.h"
+/* ISP Ctrl IF slave*/
+#include "include/ispctrl_if_master.h"
+/* ISP Ctrl IF slave error*/
+#include "include/error/ispctrl_if_master_err.h"
+
+/* Local Header Files*/
+#include "include/ispctrl_if_master_local.h"
+
+
+
+/******Include File******/
+
+
+
+/******Private Constant Definition******/
+
+
+#define MINI_ISP_LOG_TAG "[sys_manage_cmd]"
+
+
+/******Private Type Declaration******/
+
+
+
+/******Private Function Prototype******/
+
+/******Private Global Variable******/
+
+
+
+/******Public Global Variable******/
+
+/******Public Function******/
+
+/**
+ *\brief Get Status of Last Executed Command
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_status_of_last_exec_command(
+			void *devdata, u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Parameter size*/
+	u32 para_size = sizeof(struct system_cmd_status_of_last_command);
+
+
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode, param, 0);
+	if (err  != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_status_of_last_exec_command_end;
+
+	/* Get data from slave*/
+	err = ispctrl_mast_recv_response_from_slave(devdata, param,
+						para_size, true);
+mast_sys_manage_cmd_get_status_of_last_exec_command_end:
+
+	return err;
+
+
+}
+
+/**
+ *\brief Get Error Code Command
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_error_code_command(void *devdata,
+							u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Parameter size*/
+	/*get last ten error code and error status*/
+	u32 para_size = (sizeof(errcode))*10;
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode, param, 0);
+	if (err  != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_error_code_command_end;
+
+	/* Get data from slave*/
+	err = ispctrl_mast_recv_response_from_slave(devdata, param,
+							para_size, false);
+	if (err  != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_error_code_command_end;
+
+	misp_err("%s last error code %x %x %x %x", __func__, *(param),
+		*(param+1), *(param+2), *(param+3));
+mast_sys_manage_cmd_get_error_code_command_end:
+
+	return err;
+}
+
+/**
+ *\brief Set ISP register
+ *\param devdata [In], misp_data
+ *\param opCode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_set_isp_register(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Parameter size*/
+	u32 para_size = sizeof(struct system_cmd_isp_register);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+						param, para_size);
+	return err;
+}
+
+/**
+ *\brief Get ISP register
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_isp_register(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	/* Parameter size*/
+	u32 para_size = sizeof(struct system_cmd_isp_register);
+	/* Response size*/
+	u32 *reg_count = (u32 *)&param[4];
+
+
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+						param, para_size);
+	if (err  != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_isp_register_end;
+
+	/* Update response size*/
+	para_size = sizeof(struct system_cmd_isp_register) + *reg_count*4;
+
+	/* Get data from slave*/
+	err = ispctrl_if_mast_recv_isp_register_response_from_slave(
+								devdata,
+								param,
+								&para_size,
+								*reg_count);
+mast_sys_manage_cmd_get_isp_register_end:
+
+	return err;
+}
+
+/**
+ *\brief Set common log level
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_set_comomn_log_level(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size = sizeof(struct system_cmd_common_log_level);
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+					param, para_size);
+	return err;
+}
+
+/**
+ *\brief Get chip test report
+ *\param  devdata [In], misp_data
+ *\param opcode [In], Operation code
+ *\param param [In], CMD param
+ *\return Error code
+ */
+errcode mast_sys_manage_cmd_get_chip_test_report(void *devdata,
+						u16 opcode, u8 *param)
+{
+	/* Error Code*/
+	errcode err = ERR_SUCCESS;
+	u32 para_size = 0;
+
+	/* Send command to slave*/
+	err = ispctrl_mast_send_cmd_to_slave(devdata, opcode,
+						param, para_size);
+	if (err  != ERR_SUCCESS)
+		goto mast_sys_manage_cmd_get_chip_test_report_end;
+
+	/* Update response size*/
+	para_size = ReportRegCount;
+
+	/* Get data from slave*/
+	err = ispctrl_mast_recv_response_from_slave(devdata, param,
+						para_size, true);
+mast_sys_manage_cmd_get_chip_test_report_end:
+
+	return err;
+}
+
+/******End Of File******/
diff --git a/include/uapi/Kbuild b/include/uapi/Kbuild
index aeb3366..96815bd 100644
--- a/include/uapi/Kbuild
+++ b/include/uapi/Kbuild
@@ -14,3 +14,4 @@ header-y += xen/
 header-y += scsi/
 header-y += misc/
 header-y += media/
+header-y += miniISP/
diff --git a/include/uapi/miniISP/Kbuild b/include/uapi/miniISP/Kbuild
new file mode 100644
index 0000000..fec4be9
--- /dev/null
+++ b/include/uapi/miniISP/Kbuild
@@ -0,0 +1,2 @@
+#header-y += miniISP_ioctl.h
+header-y += miniISP_ioctl32.h
diff --git a/include/uapi/miniISP/miniISP_ioctl.h b/include/uapi/miniISP/miniISP_ioctl.h
new file mode 100644
index 0000000..0a0c572
--- /dev/null
+++ b/include/uapi/miniISP/miniISP_ioctl.h
@@ -0,0 +1,93 @@
+///ALTEK_TAG_HwMiniISP>>>
+
+#include <linux/types.h>
+#include <asm-generic/ioctl.h>         //_IOW(), _IOR()
+
+#define SPIBULK_BLOCKSIZE 8192 // 8k bytes
+#define SPI_CMD_LENGTH 64
+
+#define ISPCMD_LOAD_FW 0x0001
+#define ISPCMD_PURE_BYPASS 0x0010
+#define ISPCMD_POWER_OFF 0x0100
+#define ISPCMD_ENTER_CP_MODE 0x0200
+#define ISPCMD_LEAVE_CP_MODE_STANDBY 0x0002
+
+/*Calibration Profile*/
+#define ISPCMD_CAMERA_SET_SENSORMODE 0x300A
+#define ISPCMD_CAMERA_GET_SENSORMODE 0x300B
+#define ISPCMD_CAMERA_SET_OUTPUTFORMAT 0x300D
+#define ISPCMD_CAMERA_SET_CP_MODE 0x300E
+#define ISPCMD_CAMERA_SET_AE_STATISTICS 0x300F
+#define ISPCMD_CAMERA_PREVIEWSTREAMONOFF 0x3010
+#define ISPCMD_CAMERA_DUALPDYCALCULATIONWEIGHT 0x3011
+#define ISPCMD_LED_POWERCONTROL 0x3012
+#define ISPCMD_CAMERA_ACTIVE_AE 0x3013
+#define ISPCMD_ISP_AECONTROLONOFF 0x3014
+#define ISPCMD_CAMERA_SET_FRAMERATELIMITS 0x3015
+#define ISPCMD_CAMERA_SET_PERIODDROPFRAME 0x3016
+#define ISPCMD_CAMERA_SET_MAX_EXPOSURE 0x3017
+#define ISPCMD_CAMERA_SET_AE_TARGET_MEAN 0x3018
+
+/* Bulk Data*/
+#define ISPCMD_BULK_WRITE_BASICCODE 0x2002
+#define ISPCMD_BULK_WRITE_BOOTCODE 0x2008
+#define ISPCMD_BULK_READ_MEMORY 0x2101
+#define ISPCMD_BULK_READ_COMLOG 0x2102
+#define ISPCMD_BULK_WRITE_CALIBRATION_DATA 0x210B
+
+/*Basic Setting*/
+#define ISPCMD_BASIC_SET_DEPTH_3A_INFO 0x10B9
+#define ISPCMD_BASIC_SET_DEPTH_AUTO_INTERLEAVE_MODE 0x10BC
+#define ISPCMD_BASIC_SET_INTERLEAVE_MODE_DEPTH_TYPE 0x10BD
+#define ISPCMD_BASIC_SET_DEPTH_POLISH_LEVEL 0x10BE
+
+/*System Cmd*/
+#define ISPCMD_SYSTEM_GET_STATUSOFLASTEXECUTEDCOMMAND 0x0015
+#define ISPCMD_SYSTEM_GET_ERRORCODE 0x0016
+#define ISPCMD_SYSTEM_SET_ISPREGISTER 0x0100
+#define ISPCMD_SYSTEM_GET_ISPREGISTER 0x0101
+/*#define ISPCMD_SYSTEM_SET_DEBUGCMD 0x0104*/
+#define ISPCMD_SYSTEM_SET_COMLOGLEVEL 0x0109
+#define ISPCMD_SYSTEM_GET_CHIPTESTREPORT 0x010A
+
+/*Operarion Code*/
+#define ISPCMD_MINIISPOPEN 0x4000
+
+
+
+// ALTEK_AL6100_KERNEL >>>
+#define IOC_ISP_CTRL_FLOW_CHI_MAGIC 'D'
+
+#define IOCTL_ISP_RUN_TASK_START \
+	_IOWR(IOC_ISP_CTRL_FLOW_CHI_MAGIC, BASE_MINIISP_CONTROL, struct miniISP_cmd_config)
+
+#define IOCTL_ISP_RUN_TASK_STOP \
+	_IOWR(IOC_ISP_CTRL_FLOW_CHI_MAGIC, BASE_MINIISP_CONTROL + 1, struct miniISP_cmd_config)
+// ALTEK_AL6100_KERNEL <<<
+
+
+
+
+//TODO: Need to solve the kernel panic >>>
+struct miniISP_cmd_config{
+    uint16_t opcode;
+    uint32_t size;
+    //__u8 *param;
+    uint32_t param;
+} __attribute__ ((packed));
+
+#define BASE_MINIISP_CONTROL 100
+
+#define IOC_ISP_CTRL_FLOW_MAGIC 'C'
+
+#define IOCTL_ISP_LOAD_FW \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL, struct miniISP_cmd_config)
+
+#define IOCTL_ISP_PURE_BYPASS \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL + 1, struct miniISP_cmd_config)
+
+#define IOCTL_ISP_POWER_OFF \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL + 2, struct miniISP_cmd_config)
+//TODO: Need to solve the kernel panic <<<
+
+///ALTEK_TAG_HwMiniISP<<<
diff --git a/include/uapi/miniISP/miniISP_ioctl32.h b/include/uapi/miniISP/miniISP_ioctl32.h
new file mode 100644
index 0000000..1639c3f
--- /dev/null
+++ b/include/uapi/miniISP/miniISP_ioctl32.h
@@ -0,0 +1,28 @@
+#include <linux/types.h>
+#include <asm-generic/ioctl.h>         //_IOW(), _IOR()
+#include <linux/compat.h> // compat_uptr_t
+#include <uapi/miniISP/miniISP_ioctl.h>
+
+
+struct miniISP_cmd_config32{
+	uint16_t opcode;
+	uint32_t size;
+	uint32_t param;
+} __attribute__ ((packed));
+
+
+#define BASE_MINIISP_CONTROL 100
+
+#define IOC_ISP_CTRL_FLOW_MAGIC 'C'
+
+#define IOCTL_ISP_LOAD_FW32 \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL, struct miniISP_cmd_config32)
+
+#define IOCTL_ISP_PURE_BYPASS32 \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL + 1, struct miniISP_cmd_config32)
+
+#define IOCTL_ISP_POWER_OFF32 \
+	_IOWR(IOC_ISP_CTRL_FLOW_MAGIC, BASE_MINIISP_CONTROL + 2, struct miniISP_cmd_config32)
+
+
+
-- 
2.7.4

